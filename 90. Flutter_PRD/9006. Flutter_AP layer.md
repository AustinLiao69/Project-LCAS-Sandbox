# PRD_Flutter_AP Layer

**æ–‡ä»¶ç·¨è™Ÿ**: 9006  
**ç‰ˆæœ¬**: 2.1.0  
**å»ºç«‹æ—¥æœŸ**: 2025-08-01  
**å»ºç«‹è€…**: LCAS PM Team  
**æœ€å¾Œæ›´æ–°**: 2025-08-08

---

## ç›®æ¬¡

1. [æ¨¡çµ„æ¦‚è¿°](#10-æ¨¡çµ„æ¦‚è¿°module-overview)
2. [ç³»çµ±å±¤ç´šæ¶æ§‹](#20-ç³»çµ±å±¤ç´šæ¶æ§‹system-level-architecture)
3. [AP Layeræ¨¡çµ„æ¶æ§‹](#30-ap-layeræ¨¡çµ„æ¶æ§‹ap-layer-module-architecture)
4. [ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹](#40-ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹code-organization-architecture)
5. [æ¶æ§‹é—œä¿‚å°æ‡‰](#50-æ¶æ§‹é—œä¿‚å°æ‡‰architecture-relationship-mapping)
6. [APIæœå‹™å±¤è¨­è¨ˆ](#60-apiæœå‹™å±¤è¨­è¨ˆapi-services-layer)
7. [32å€‹APIç«¯é»æ•´åˆ](#70-32å€‹apiç«¯é»æ•´åˆapi-endpoints-integration)
8. [è³‡æ–™æ¨¡å‹å®šç¾©](#80-è³‡æ–™æ¨¡å‹å®šç¾©data-models)
9. [ç‹€æ…‹ç®¡ç†ç­–ç•¥](#90-ç‹€æ…‹ç®¡ç†ç­–ç•¥state-management)
10. [éŒ¯èª¤è™•ç†æ©Ÿåˆ¶](#100-éŒ¯èª¤è™•ç†æ©Ÿåˆ¶error-handling)
11. [å¿«å–ç­–ç•¥è¨­è¨ˆ](#110-å¿«å–ç­–ç•¥è¨­è¨ˆcaching-strategy)
12. [é›¢ç·šåŒæ­¥æ©Ÿåˆ¶](#120-é›¢ç·šåŒæ­¥æ©Ÿåˆ¶offline-sync)
13. [æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](#130-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥performance-optimization)
14. [æ¸¬è©¦ç­–ç•¥](#140-æ¸¬è©¦ç­–ç•¥testing-strategy)
15. [ç‰ˆæœ¬å‡ç´šè¨ˆç•«](#150-ç‰ˆæœ¬å‡ç´šè¨ˆç•«version-upgrade)

---

## 1.0 æ¨¡çµ„æ¦‚è¿°ï¼ˆModule Overviewï¼‰

### 1.1 ç”¢å“å®šä½
Flutter AP Layerï¼ˆæ‡‰ç”¨é‚è¼¯å±¤ï¼‰æ˜¯LCAS 2.0ç³»çµ±çš„æ ¸å¿ƒä¸­ä»‹å±¤ï¼Œè² è²¬é€£æ¥Presentation Layerèˆ‡Business Layerï¼Œæ•´åˆ32å€‹RESTful APIç«¯é»ï¼Œæä¾›çµ±ä¸€çš„è³‡æ–™å­˜å–ä»‹é¢å’Œæ¥­å‹™é‚è¼¯å°è£ã€‚

### 1.2 æ ¸å¿ƒè·è²¬
- **APIæ•´åˆç®¡ç†**: å°è£32å€‹RESTful APIç«¯é»ï¼Œæä¾›é¡å‹å®‰å…¨çš„èª¿ç”¨ä»‹é¢
- **è³‡æ–™è½‰æ›è™•ç†**: è™•ç†APIæ•¸æ“šèˆ‡UIæ•¸æ“šé–“çš„æ ¼å¼è½‰æ›
- **ç‹€æ…‹ç®¡ç†å”èª¿**: ç®¡ç†æ‡‰ç”¨ç‹€æ…‹ï¼Œç¢ºä¿æ•¸æ“šä¸€è‡´æ€§
- **éŒ¯èª¤è™•ç†çµ±ä¸€**: æä¾›çµ±ä¸€çš„éŒ¯èª¤è™•ç†å’Œç”¨æˆ¶å‹å–„çš„éŒ¯èª¤è¨Šæ¯
- **å¿«å–ç­–ç•¥åŸ·è¡Œ**: å¯¦æ–½æ™ºæ…§å¿«å–ï¼Œæå‡æ‡‰ç”¨æ•ˆèƒ½
- **é›¢ç·šåŠŸèƒ½æ”¯æ´**: æ”¯æ´é›¢ç·šæ“ä½œå’Œæ•¸æ“šåŒæ­¥

### 1.3 åœ¨LCAS 2.0ç³»çµ±ä¸­çš„å®šä½
```
LCAS 2.0 ç³»çµ±æ¶æ§‹
â”œâ”€â”€ Flutter Presentation Layer (å±•ç¤ºå±¤)
â”‚   â”œâ”€â”€ UI Components â†’ ä½¿ç”¨è€…ä»‹é¢å…ƒä»¶
â”‚   â”œâ”€â”€ Screens & Views â†’ ç•«é¢èˆ‡è¦–åœ–
â”‚   â””â”€â”€ User Interactions â†’ ä½¿ç”¨è€…äº’å‹•
â”œâ”€â”€ Flutter AP Layer (æ‡‰ç”¨é‚è¼¯å±¤) â˜… æœ¬æ–‡ä»¶ç¯„åœ â˜…
â”‚   â”œâ”€â”€ 32å€‹APIç«¯é» â†’ F001-F032
â”‚   â”œâ”€â”€ State Management â†’ ç‹€æ…‹ç®¡ç†
â”‚   â”œâ”€â”€ Data Transformation â†’ è³‡æ–™è½‰æ›
â”‚   â””â”€â”€ Cache Management â†’ å¿«å–ç®¡ç†
â”œâ”€â”€ Business Layer (å•†æ¥­é‚è¼¯å±¤)
â”‚   â”œâ”€â”€ API Integration â†’ APIæ•´åˆæœå‹™
â”‚   â””â”€â”€ Business Logic â†’ å•†æ¥­é‚è¼¯
â””â”€â”€ Data Layer (è³‡æ–™å±¤)
    â”œâ”€â”€ Collections â†’ è³‡æ–™é›†åˆ
    â”œâ”€â”€ Documents â†’ æ–‡ä»¶è³‡æ–™
    â””â”€â”€ Security Rules â†’ å®‰å…¨è¦å‰‡
```

---

## 2.0 ç³»çµ±å±¤ç´šæ¶æ§‹ï¼ˆSystem Level Architectureï¼‰

### 2.1 LCAS 2.0ç³»çµ±æ¶æ§‹æ¦‚è¦½

Flutter AP Layeråœ¨æ•´å€‹LCAS 2.0ç³»çµ±ä¸­æ‰®æ¼”**æ‡‰ç”¨é‚è¼¯å±¤**çš„è§’è‰²ï¼Œè² è²¬é€£æ¥å‰ç«¯å±•ç¤ºå±¤èˆ‡å¾Œç«¯å•†æ¥­é‚è¼¯å±¤ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Flutter Presentation Layer       â”‚  â† 9005æ–‡ä»¶ç¯„åœ
â”‚    (UI Components, Screens, Views)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ Widget Events & State Updates
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Flutter AP Layer â˜…              â”‚  â† 9006æ–‡ä»¶ç¯„åœ
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚       9å¤§æœå‹™ç¾¤çµ„ (F001-F032)         â”‚ â”‚
â”‚  â”‚ AuthService | EntryService | ...    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Repository & Use Cases Pattern    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     Cache & Offline Management      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ HTTP/HTTPS Requests
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         RESTful API Layer               â”‚  â† 6001æ–‡ä»¶ç¯„åœ
â”‚         (32å€‹APIç«¯é»)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ Database Operations
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Firestore Database             â”‚  â† 6002æ–‡ä»¶ç¯„åœ
â”‚       (Collections & Documents)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
``` 

### 2.2 è³‡æ–™æµå‘èˆ‡è·è²¬åˆ†é›¢

#### 2.2.1 å‘ä¸Šè³‡æ–™æµï¼ˆå¾€Presentation Layerï¼‰
- **ç‹€æ…‹æ›´æ–°**: Provider/Riverpodç‹€æ…‹è®Šæ›´
- **äº‹ä»¶å›èª¿**: æ“ä½œçµæœé€šçŸ¥
- **éŒ¯èª¤è™•ç†**: ä½¿ç”¨è€…å‹å–„çš„éŒ¯èª¤è¨Šæ¯

#### 2.2.2 å‘ä¸‹è³‡æ–™æµï¼ˆå¾€Business Layerï¼‰
- **APIè«‹æ±‚**: RESTful HTTPè«‹æ±‚
- **è³‡æ–™é©—è­‰**: è«‹æ±‚åƒæ•¸é©—è­‰
- **èªè­‰ç®¡ç†**: JWT Tokenè‡ªå‹•é™„åŠ 

#### 2.2.3 æ©«å‘è³‡æ–™æµï¼ˆAP Layerå…§éƒ¨ï¼‰
- **æœå‹™å”ä½œ**: 9å¤§æœå‹™ç¾¤çµ„é–“çš„å”èª¿
- **å¿«å–ç®¡ç†**: æœ¬åœ°è³‡æ–™å¿«å–èˆ‡åŒæ­¥
- **ç‹€æ…‹åŒæ­¥**: å…¨åŸŸç‹€æ…‹èˆ‡å€åŸŸç‹€æ…‹åŒæ­¥

---

## 3.0 AP Layeræ¨¡çµ„æ¶æ§‹ï¼ˆAP Layer Module Architectureï¼‰

### 3.1 åŠŸèƒ½æ€§åˆ†å±¤æ¶æ§‹

AP Layerå…§éƒ¨æ¡ç”¨åŠŸèƒ½æ€§åˆ†å±¤ï¼ŒåŒ…å«9å¤§æœå‹™ç¾¤çµ„å°æ‡‰32å€‹APIç«¯é»ï¼š

```
Flutter AP Layer åŠŸèƒ½æ€§æ¶æ§‹
â”œâ”€â”€ ğŸ” èªè­‰èˆ‡å¸³æˆ¶ç®¡ç†æœå‹™ (F001-F005)
â”‚   â”œâ”€â”€ F001: ä½¿ç”¨è€…è¨»å†Š â†’ AuthService.registerUser()
â”‚   â”œâ”€â”€ F002: ä½¿ç”¨è€…ç™»å…¥ â†’ AuthService.loginUser()
â”‚   â”œâ”€â”€ F003: ä½¿ç”¨è€…ç™»å‡º â†’ AuthService.logoutUser()
â”‚   â”œâ”€â”€ F004: å¸³è™Ÿåˆªé™¤ â†’ AuthService.deleteAccount()
â”‚   â””â”€â”€ F005: å¯†ç¢¼é‡è¨­ â†’ AuthService.resetPassword()
â”œâ”€â”€ ğŸ’° åŸºç¤è¨˜å¸³æœå‹™ (F006-F009)
â”‚   â”œâ”€â”€ F006: APPè¨˜å¸³åŠŸèƒ½ â†’ EntryService.createEntry()
â”‚   â”œâ”€â”€ F007: APPè¨˜éŒ„æŸ¥è©¢ â†’ EntryService.queryEntries()
â”‚   â”œâ”€â”€ F008: ç§‘ç›®ä»£ç¢¼ç®¡ç† â†’ EntryService.getSubjectsList()
â”‚   â””â”€â”€ F009: ä½¿ç”¨è€…è¨­å®šç®¡ç† â†’ EntryService.updateUserSettings()
â”œâ”€â”€ ğŸ“– å¤šå¸³æœ¬ç®¡ç†æœå‹™ (F010-F015)
â”‚   â”œâ”€â”€ F010: å°ˆæ¡ˆå¸³æœ¬å»ºç«‹ â†’ ProjectLedgerService.createProject()
â”‚   â”œâ”€â”€ F011: å°ˆæ¡ˆå¸³æœ¬ç®¡ç† â†’ ProjectLedgerService.manageProject()
â”‚   â”œâ”€â”€ F012: å°ˆæ¡ˆå¸³æœ¬åˆªé™¤ â†’ ProjectLedgerService.deleteProject()
â”‚   â”œâ”€â”€ F013: åˆ†é¡å¸³æœ¬å»ºç«‹ â†’ ProjectLedgerService.createCategory()
â”‚   â”œâ”€â”€ F014: åˆ†é¡å¸³æœ¬ç®¡ç† â†’ ProjectLedgerService.manageCategory()
â”‚   â””â”€â”€ F015: å¤šå¸³æœ¬åˆ‡æ› â†’ ProjectLedgerService.switchLedger()
â”œâ”€â”€ ğŸ’µ é ç®—ç®¡ç†æœå‹™ (F016-F018)
â”‚   â”œâ”€â”€ F016: é ç®—è¨­å®šå»ºç«‹ â†’ BudgetService.createBudget()
â”‚   â”œâ”€â”€ F017: é ç®—è¿½è¹¤ç›£æ§ â†’ BudgetService.monitorBudget()
â”‚   â””â”€â”€ F018: é ç®—è­¦ç¤ºè¨­å®š â†’ BudgetService.setBudgetAlerts()
â”œâ”€â”€ ğŸ‘¥ å”ä½œæœå‹™ (F019-F021)
â”‚   â”œâ”€â”€ F019: å…±äº«å¸³æœ¬å»ºç«‹ â†’ CollaborationService.createSharedLedger()
â”‚   â”œâ”€â”€ F020: å¤šäººå”ä½œæ¬Šé™ â†’ CollaborationService.setMemberPermissions()
â”‚   â””â”€â”€ F021: å³æ™‚å”ä½œåŒæ­¥ â†’ CollaborationService.realtimeSync()
â”œâ”€â”€ ğŸ“ˆ å ±è¡¨æœå‹™ (F022-F024)
â”‚   â”œâ”€â”€ F022: æ¨™æº–å ±è¡¨ç”¢å‡º â†’ ReportService.generateReport()
â”‚   â”œâ”€â”€ F023: è‡ªå®šç¾©å ±è¡¨è¨­è¨ˆ â†’ ReportService.createCustomReport()
â”‚   â””â”€â”€ F024: å ±è¡¨åŒ¯å‡ºåŠŸèƒ½ â†’ ReportService.exportReport()
â”œâ”€â”€ ğŸ’¾ å‚™ä»½èˆ‡åŒæ­¥æœå‹™ (F025-F028)
â”‚   â”œâ”€â”€ F025: å®šæœŸè‡ªå‹•å‚™ä»½ â†’ SystemService.scheduleBackup()
â”‚   â”œâ”€â”€ F026: æ‰‹å‹•å‚™ä»½é‚„åŸ â†’ SystemService.manualBackup()
â”‚   â”œâ”€â”€ F027: å‚™ä»½æª”æ¡ˆç®¡ç† â†’ SystemService.manageBackup()
â”‚   â””â”€â”€ F028: è³‡æ–™åŒæ­¥æª¢æŸ¥ â†’ SystemService.checkSyncStatus()
â”œâ”€â”€ ğŸ–¥ï¸ ç³»çµ±ç›£æ§æœå‹™ (F029-F030)
â”‚   â”œâ”€â”€ F029: ç³»çµ±å¥åº·ç›£æ§ â†’ SystemService.getSystemHealth()
â”‚   â””â”€â”€ F030: éŒ¯èª¤æ—¥èªŒç®¡ç† â†’ SystemService.getErrorLogs()
â””â”€â”€ â° æ’ç¨‹æé†’æœå‹™ (F031-F032)
    â”œâ”€â”€ F031: æ’ç¨‹æé†’è¨­å®š â†’ SystemService.createReminder()
    â””â”€â”€ F032: æ’ç¨‹æé†’åŸ·è¡Œ â†’ SystemService.executeReminder()
```

### 3.2 æœå‹™ç¾¤çµ„è·è²¬çŸ©é™£

| æœå‹™ç¾¤çµ„ | ä¸»è¦è·è²¬ | APIç«¯é»æ•¸é‡ | æ ¸å¿ƒåŠŸèƒ½ | ç›¸ä¾æ€§ |
|----------|----------|-------------|----------|--------|
| **AuthService** | èªè­‰èˆ‡å¸³æˆ¶æœå‹™ | 5å€‹ (F001-F005) | ç™»å…¥è¨»å†Šã€æ¬Šé™é©—è­‰ã€å¸³æˆ¶ç®¡ç† | ç¨ç«‹æœå‹™ |
| **EntryService** | åŸºç¤è¨˜å¸³æœå‹™ | 4å€‹ (F006-F009) | CRUDè¨˜å¸³è¨˜éŒ„ã€ç§‘ç›®ç®¡ç† | ä¾è³´AuthService |
| **ProjectLedgerService** | å¤šå¸³æœ¬ç®¡ç†æœå‹™ | 6å€‹ (F010-F015) | å°ˆæ¡ˆå¸³æœ¬ã€åˆ†é¡ç®¡ç†ã€å¸³æœ¬åˆ‡æ› | ä¾è³´AuthService |
| **BudgetService** | é ç®—ç®¡ç†æœå‹™ | 3å€‹ (F016-F018) | é ç®—è¨­å®šã€é€²åº¦è¿½è¹¤ã€è­¦ç¤ºç®¡ç† | ä¾è³´EntryService |
| **CollaborationService** | å”ä½œæœå‹™ | 3å€‹ (F019-F021) | å…±äº«å¸³æœ¬ã€æ¬Šé™ç®¡ç†ã€å³æ™‚åŒæ­¥ | ä¾è³´ProjectLedgerService |
| **ReportService** | å ±è¡¨æœå‹™ | 3å€‹ (F022-F024) | æ¨™æº–å ±è¡¨ã€è‡ªå®šç¾©å ±è¡¨ã€åŒ¯å‡ºåŠŸèƒ½ | ä¾è³´EntryService |
| **BackupSyncService** | å‚™ä»½èˆ‡åŒæ­¥æœå‹™ | 4å€‹ (F025-F028) | è‡ªå‹•å‚™ä»½ã€æ‰‹å‹•å‚™ä»½ã€åŒæ­¥æª¢æŸ¥ | ä¾è³´æ‰€æœ‰æœå‹™ |
| **MonitoringService** | ç³»çµ±ç›£æ§æœå‹™ | 2å€‹ (F029-F030) | å¥åº·ç›£æ§ã€éŒ¯èª¤æ—¥èªŒç®¡ç† | ç¨ç«‹æœå‹™ |
| **ScheduleService** | æ’ç¨‹æé†’æœå‹™ | 2å€‹ (F031-F032) | æé†’è¨­å®šã€æ’ç¨‹åŸ·è¡Œ | ä¾è³´AuthService |

---

## 4.0 ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹ï¼ˆCode Organization Architectureï¼‰

### 4.1 Clean Architectureå¯¦ä½œçµæ§‹

AP Layeræ¡ç”¨Clean Architectureæ¨¡å¼ï¼Œç¢ºä¿ç¨‹å¼ç¢¼çš„å¯ç¶­è­·æ€§å’Œå¯æ¸¬è©¦æ€§ï¼š

```dart
lib/  â† Flutter AP Layer ç¨‹å¼ç¢¼æ ¹ç›®éŒ„
â”œâ”€â”€ core/  â† ğŸ—ï¸ åŸºç¤è¨­æ–½å±¤ (Infrastructure Layer)
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ api_client.dart          â†’ çµ±ä¸€APIå®¢æˆ¶ç«¯
â”‚   â”‚   â”œâ”€â”€ api_interceptors.dart    â†’ è«‹æ±‚æ””æˆªå™¨
â”‚   â”‚   â””â”€â”€ api_endpoints.dart       â†’ APIç«¯é»å®šç¾© (F001-F032)
â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”œâ”€â”€ cache_manager.dart       â†’ å¿«å–ç®¡ç†å™¨
â”‚   â”‚   â””â”€â”€ cache_strategies.dart    â†’ å¿«å–ç­–ç•¥
â”‚   â”œâ”€â”€ error/
â”‚   â”‚   â”œâ”€â”€ app_exceptions.dart      â†’ æ‡‰ç”¨ç•°å¸¸å®šç¾©
â”‚   â”‚   â””â”€â”€ error_handler.dart       â†’ éŒ¯èª¤è™•ç†å™¨
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â”œâ”€â”€ network_info.dart        â†’ ç¶²è·¯ç‹€æ…‹æª¢æ¸¬
â”‚   â”‚   â””â”€â”€ connectivity_service.dart â†’ é€£ç·šæœå‹™
â”‚   â””â”€â”€ di/
â”‚       â””â”€â”€ service_locator.dart     â†’ ä¾è³´æ³¨å…¥è¨­å®š
â”œâ”€â”€ data/  â† ğŸ“Š è³‡æ–™å±¤ (Data Layer)
â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”œâ”€â”€ remote/  â† ğŸŒ 9å¤§æœå‹™ç¾¤çµ„çš„é ç«¯è³‡æ–™æº
â”‚   â”‚   â”‚   â”œâ”€â”€ auth_remote_datasource.dart           â†’ F001-F005
â”‚   â”‚   â”‚   â”œâ”€â”€ entry_remote_datasource.dart          â†’ F006-F009
â”‚   â”‚   â”‚   â”œâ”€â”€ project_ledger_remote_datasource.dart â†’ F010-F015
â”‚   â”‚   â”‚   â”œâ”€â”€ budget_remote_datasource.dart         â†’ F016-F018
â”‚   â”‚   â”‚   â”œâ”€â”€ collaboration_remote_datasource.dart  â†’ F019-F021
â”‚   â”‚   â”‚   â”œâ”€â”€ report_remote_datasource.dart         â†’ F022-F024
â”‚   â”‚   â”‚   â”œâ”€â”€ backup_sync_remote_datasource.dart    â†’ F025-F028
â”‚   â”‚   â”‚   â”œâ”€â”€ monitoring_remote_datasource.dart     â†’ F029-F030
â”‚   â”‚   â”‚   â””â”€â”€ schedule_remote_datasource.dart       â†’ F031-F032
â”‚   â”‚   â””â”€â”€ local/  â† ğŸ’¾ æœ¬åœ°å¿«å–è³‡æ–™æº
â”‚   â”‚       â”œâ”€â”€ auth_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ entry_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ project_ledger_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ budget_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ collaboration_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ report_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ backup_sync_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ monitoring_local_datasource.dart
â”‚   â”‚       â””â”€â”€ schedule_local_datasource.dart
â”‚   â”œâ”€â”€ models/  â† ğŸ“‹ è³‡æ–™å‚³è¼¸ç‰©ä»¶ (DTO)
â”‚   â”‚   â”œâ”€â”€ user_model.dart
â”‚   â”‚   â”œâ”€â”€ entry_model.dart
â”‚   â”‚   â”œâ”€â”€ project_model.dart
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ repositories/  â† ğŸ”„ Repositoryå¯¦ä½œ
â”‚       â”œâ”€â”€ auth_repository_impl.dart
â”‚       â”œâ”€â”€ entry_repository_impl.dart
â”‚       â”œâ”€â”€ project_ledger_repository_impl.dart
â”‚       â”œâ”€â”€ budget_repository_impl.dart
â”‚       â”œâ”€â”€ collaboration_repository_impl.dart
â”‚       â”œâ”€â”€ report_repository_impl.dart
â”‚       â”œâ”€â”€ backup_sync_repository_impl.dart
â”‚       â”œâ”€â”€ monitoring_repository_impl.dart
â”‚       â””â”€â”€ schedule_repository_impl.dart
â”œâ”€â”€ domain/  â† ğŸ¯ é ˜åŸŸå±¤ (Domain Layer)
â”‚   â”œâ”€â”€ entities/  â† ğŸ’ æ¥­å‹™å¯¦é«”
â”‚   â”‚   â”œâ”€â”€ user.dart
â”‚   â”‚   â”œâ”€â”€ entry.dart
â”‚   â”‚   â”œâ”€â”€ project.dart
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ repositories/  â† ğŸ“œ RepositoryæŠ½è±¡ä»‹é¢
â”‚   â”‚   â”œâ”€â”€ auth_repository.dart
â”‚   â”‚   â”œâ”€â”€ entry_repository.dart
â”‚   â”‚   â”œâ”€â”€ project_ledger_repository.dart
â”‚   â”‚   â”œâ”€â”€ budget_repository.dart
â”‚   â”‚   â”œâ”€â”€ collaboration_repository.dart
â”‚   â”‚   â”œâ”€â”€ report_repository.dart
â”‚   â”‚   â”œâ”€â”€ backup_sync_repository.dart
â”‚   â”‚   â”œâ”€â”€ monitoring_repository.dart
â”‚   â”‚   â””â”€â”€ schedule_repository.dart
â”‚   â””â”€â”€ usecases/  â† âš™ï¸ æ¥­å‹™ç”¨ä¾‹ (Use Cases)
â”‚       â”œâ”€â”€ auth/
â”‚       â”‚   â”œâ”€â”€ login_user.dart      â†’ F002 ç™»å…¥ç”¨ä¾‹
â”‚       â”‚   â”œâ”€â”€ register_user.dart   â†’ F001 è¨»å†Šç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ entry/
â”‚       â”‚   â”œâ”€â”€ create_entry.dart    â†’ F006 æ–°å¢è¨˜å¸³ç”¨ä¾‹
â”‚       â”‚   â”œâ”€â”€ get_entries.dart     â†’ F007 æŸ¥è©¢è¨˜å¸³ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ project_ledger/
â”‚       â”‚   â”œâ”€â”€ create_project.dart  â†’ F010 å»ºç«‹å°ˆæ¡ˆç”¨ä¾‹
â”‚       â”‚   â”œâ”€â”€ switch_ledger.dart   â†’ F015 åˆ‡æ›å¸³æœ¬ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ budget/
â”‚       â”‚   â”œâ”€â”€ create_budget.dart   â†’ F016 å»ºç«‹é ç®—ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ collaboration/
â”‚       â”‚   â”œâ”€â”€ create_shared_ledger.dart â†’ F019 å»ºç«‹å…±äº«å¸³æœ¬ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ report/
â”‚       â”‚   â”œâ”€â”€ generate_report.dart â†’ F022 ç”¢ç”Ÿå ±è¡¨ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ backup_sync/
â”‚       â”‚   â”œâ”€â”€ schedule_backup.dart â†’ F025 æ’ç¨‹å‚™ä»½ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ monitoring/
â”‚       â”‚   â”œâ”€â”€ check_system_health.dart â†’ F029 ç³»çµ±å¥åº·æª¢æŸ¥ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â””â”€â”€ schedule/
â”‚           â”œâ”€â”€ create_reminder.dart â†’ F031 å»ºç«‹æé†’ç”¨ä¾‹
â”‚           â””â”€â”€ ...
â””â”€â”€ presentation/  â† ğŸ¨ å±•ç¤ºå±¤æ¥å£ (èˆ‡9005æ–‡ä»¶çš„éŠœæ¥é»)
    â”œâ”€â”€ providers/  â† ğŸ”„ ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ auth_provider.dart            â†’ èªè­‰ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ entry_provider.dart           â†’ è¨˜å¸³ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ project_ledger_provider.dart  â†’ å¤šå¸³æœ¬ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ budget_provider.dart          â†’ é ç®—ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ collaboration_provider.dart   â†’ å”ä½œç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ report_provider.dart          â†’ å ±è¡¨ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ backup_sync_provider.dart     â†’ å‚™ä»½åŒæ­¥ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ monitoring_provider.dart      â†’ ç³»çµ±ç›£æ§ç‹€æ…‹ç®¡ç†
    â”‚   â””â”€â”€ schedule_provider.dart        â†’ æ’ç¨‹æé†’ç‹€æ…‹ç®¡ç†
    â””â”€â”€ widgets/  â† ğŸ§© å…±ç”¨UIå…ƒä»¶ (ç”±9005æ–‡ä»¶è©³ç´°å®šç¾©)
        â”œâ”€â”€ common/
        â””â”€â”€ ...
```

### 4.2 ä¾è³´æ–¹å‘èˆ‡åŸå‰‡

Clean Architectureçš„ä¾è³´è¦å‰‡åœ¨AP Layerä¸­çš„å¯¦ä½œï¼š

```
ğŸ¨ Presentation â”€â”€ä¾è³´â”€â”€â–º ğŸ¯ Domain â—„â”€â”€å¯¦ä½œâ”€â”€ ğŸ“Š Data
     â”‚                      â–²                    â”‚
     â””â”€â”€â”€â”€â”€â”€ä¾è³´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
                                                 â–¼
                                            ğŸ—ï¸ Core
                                         (Infrastructure)
```

**ä¾è³´åŸå‰‡**ï¼š
- **Presentation Layer**: ä¾è³´Domainçš„Use Caseså’ŒEntities
- **Data Layer**: å¯¦ä½œDomainçš„Repositoryä»‹é¢
- **Domain Layer**: å®Œå…¨ç¨ç«‹ï¼Œä¸ä¾è³´ä»»ä½•å¤–éƒ¨å±¤
- **Core Layer**: è¢«æ‰€æœ‰å±¤å…±ç”¨ï¼Œæä¾›åŸºç¤è¨­æ–½

---

## 5.0 æ¶æ§‹é—œä¿‚å°æ‡‰ï¼ˆArchitecture Relationship Mappingï¼‰

### 5.1 ä¸‰å±¤æ¶æ§‹å°æ‡‰é—œä¿‚

ä»¥ä¸‹è¡¨æ ¼èªªæ˜**ç³»çµ±å±¤ç´šæ¶æ§‹**ã€**æ¨¡çµ„åŠŸèƒ½æ¶æ§‹**ã€**ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹**ä¹‹é–“çš„å°æ‡‰é—œä¿‚ï¼š

| ç³»çµ±å±¤ç´šæ¶æ§‹ | æ¨¡çµ„åŠŸèƒ½æ¶æ§‹ | ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹ | èªªæ˜ |
|-------------|-------------|---------------|------|
| **Flutter AP Layer** | **7å¤§æœå‹™ç¾¤çµ„** | **lib/** | æ•´å€‹AP Layerçš„ç¯„åœ |
| â†³ Business Logic | â†³ AuthService (F001-F005) | â†³ data/datasources/remote/auth_remote_datasource.dart | èªè­‰æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ EntryService (F006-F009) | â†³ data/datasources/remote/entry_remote_datasource.dart | è¨˜å¸³æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ ProjectLedgerService (F010-F015) | â†³ data/datasources/remote/project_ledger_remote_datasource.dart | å¤šå¸³æœ¬æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ BudgetService (F016-F018) | â†³ data/datasources/remote/budget_remote_datasource.dart | é ç®—æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ CollaborationService (F019-F021) | â†³ data/datasources/remote/collaboration_remote_datasource.dart | å”ä½œæœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ ReportService (F022-F024) | â†³ data/datasources/remote/report_remote_datasource.dart | å ±è¡¨æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ SystemService (F025-F032) | â†³ data/datasources/remote/system_remote_datasource.dart | ç³»çµ±æœå‹™å¯¦ä½œ |
| â†³ API Integration | â†³ HTTP Client | â†³ core/api/api_client.dart | çµ±ä¸€APIå®¢æˆ¶ç«¯ |
| â†³ State Management | â†³ Repository Pattern | â†³ domain/repositories/ + data/repositories/ | è³‡æ–™å­˜å–æŠ½è±¡ |
| â†³ Data Transformation | â†³ Data Models | â†³ data/models/ + domain/entities/ | è³‡æ–™æ¨¡å‹è½‰æ› |
| â†³ Cache Management | â†³ Cache Strategies | â†³ core/cache/ + data/datasources/local/ | å¿«å–ç®¡ç† |

### 5.2 APIç«¯é»åˆ°ç¨‹å¼ç¢¼çš„å°æ‡‰

#### 5.2.1 èªè­‰ç®¡ç†ç¾¤çµ„ (F001-F005) å°æ‡‰
```
F001 ä½¿ç”¨è€…è¨»å†Š â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.registerUser()
                   â”œâ”€â”€ domain/usecases/auth/register_user.dart
                   â”œâ”€â”€ data/repositories/auth_repository_impl.dart
                   â””â”€â”€ presentation/providers/auth_provider.dart

F002 ä½¿ç”¨è€…ç™»å…¥ â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.loginUser()
F003 ä½¿ç”¨è€…ç™»å‡º â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.logoutUser()
F004 å¸³è™Ÿåˆªé™¤   â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.deleteAccount()
F005 å¯†ç¢¼é‡è¨­   â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.resetPassword()
```

#### 5.2.2 åŸºç¤è¨˜å¸³ç¾¤çµ„ (F006-F009) å°æ‡‰
```
F006 APPè¨˜å¸³åŠŸèƒ½     â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.createEntry()
F007 APPè¨˜éŒ„æŸ¥è©¢     â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.queryEntries()
F008 ç§‘ç›®ä»£ç¢¼ç®¡ç†    â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.getSubjectsList()
F009 ä½¿ç”¨è€…è¨­å®šç®¡ç†  â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.updateUserSettings()
```

#### 5.2.3 å…¶ä»–æœå‹™ç¾¤çµ„é¡ä¼¼å°æ‡‰...

### 5.3 7å¤§æœå‹™ç¾¤çµ„åœ¨Clean Architectureä¸­çš„å®šä½

å›ç­”ä½¿ç”¨è€…çš„æ ¸å¿ƒå•é¡Œï¼š**7å¤§æœå‹™ç¾¤çµ„åœ¨åˆ†å±¤æ¶æ§‹è¨­è¨ˆçš„å“ªè£¡ï¼Ÿ**

```
Clean Architectureåˆ†å±¤æ¶æ§‹
â”‚
â”œâ”€â”€ ğŸ¯ Domain Layer (é ˜åŸŸå±¤)
â”‚   â”œâ”€â”€ entities/ â†’ æ¥­å‹™å¯¦é«”å®šç¾©
â”‚   â”œâ”€â”€ repositories/ â†’ RepositoryæŠ½è±¡ä»‹é¢
â”‚   â””â”€â”€ usecases/ â†’ æ¥­å‹™ç”¨ä¾‹å¯¦ä½œ â˜… 7å¤§æœå‹™ç¾¤çµ„çš„æ¥­å‹™é‚è¼¯åœ¨é€™è£¡ â˜…
â”‚       â”œâ”€â”€ auth/ â†’ AuthServiceçš„Use Cases
â”‚       â”œâ”€â”€ entry/ â†’ EntryServiceçš„Use Cases
â”‚       â”œâ”€â”€ project_ledger/ â†’ ProjectLedgerServiceçš„Use Cases
â”‚       â”œâ”€â”€ budget/ â†’ BudgetServiceçš„Use Cases
â”‚       â”œâ”€â”€ collaboration/ â†’ CollaborationServiceçš„Use Cases
â”‚       â”œâ”€â”€ report/ â†’ ReportServiceçš„Use Cases
â”‚       â””â”€â”€ system/ â†’ SystemServiceçš„Use Cases
â”‚
â”œâ”€â”€ ğŸ“Š Data Layer (è³‡æ–™å±¤)
â”‚   â””â”€â”€ datasources/remote/ â˜… 7å¤§æœå‹™ç¾¤çµ„çš„APIèª¿ç”¨åœ¨é€™è£¡ â˜…
â”‚       â”œâ”€â”€ auth_remote_datasource.dart â†’ AuthService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ entry_remote_datasource.dart â†’ EntryService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ project_ledger_remote_datasource.dart â†’ ProjectLedgerService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ budget_remote_datasource.dart â†’ BudgetService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ collaboration_remote_datasource.dart â†’ CollaborationService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ report_remote_datasource.dart â†’ ReportService APIå¯¦ä½œ
â”‚       â””â”€â”€ system_remote_datasource.dart â†’ SystemService APIå¯¦ä½œ
â”‚
â””â”€â”€ ğŸ¨ Presentation Layer (å±•ç¤ºæ¥å£å±¤)
    â””â”€â”€ providers/ â˜… 7å¤§æœå‹™ç¾¤çµ„çš„ç‹€æ…‹ç®¡ç†åœ¨é€™è£¡ â˜…
        â”œâ”€â”€ auth_provider.dart â†’ AuthServiceç‹€æ…‹ç®¡ç†
        â”œâ”€â”€ entry_provider.dart â†’ EntryServiceç‹€æ…‹ç®¡ç†
        â””â”€â”€ ... (å…¶ä»–Provider)
```

**ç¸½çµå›ç­”**ï¼š
1. **7å¤§æœå‹™ç¾¤çµ„çš„æ¥­å‹™é‚è¼¯** â†’ `domain/usecases/` ç›®éŒ„
2. **7å¤§æœå‹™ç¾¤çµ„çš„APIèª¿ç”¨** â†’ `data/datasources/remote/` ç›®éŒ„  
3. **7å¤§æœå‹™ç¾¤çµ„çš„ç‹€æ…‹ç®¡ç†** â†’ `presentation/providers/` ç›®éŒ„

### 5.4 ä¾è³´æ³¨å…¥è¨­è¨ˆ
```dart
// lib/core/di/service_locator.dart
import 'package:get_it/get_it.dart';

final GetIt sl = GetIt.instance;

Future<void> init() async {
  // API Servicesè¨»å†Š
  sl.registerLazySingleton<ApiClient>(() => ApiClient(sl()));
  sl.registerLazySingleton<AuthService>(() => AuthService(sl()));
  sl.registerLazySingleton<EntryService>(() => EntryService(sl()));
  sl.registerLazySingleton<ProjectLedgerService>(() => ProjectLedgerService(sl()));
  sl.registerLazySingleton<BudgetService>(() => BudgetService(sl()));
  sl.registerLazySingleton<CollaborationService>(() => CollaborationService(sl()));
  sl.registerLazySingleton<ReportService>(() => ReportService(sl()));
  sl.registerLazySingleton<SystemService>(() => SystemService(sl()));

  // Repositoryè¨»å†Š
  sl.registerLazySingleton<AuthRepository>(() => AuthRepositoryImpl(sl(), sl()));
  sl.registerLazySingleton<EntryRepository>(() => EntryRepositoryImpl(sl(), sl()));

  // Use Casesè¨»å†Š
  sl.registerLazySingleton(() => LoginUser(sl()));
  sl.registerLazySingleton(() => CreateEntry(sl()));

  // åŸºç¤è¨­æ–½è¨»å†Š
  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(sl()));
  sl.registerLazySingleton<CacheManager>(() => CacheManagerImpl());
}
```

### 2.2 Repository Pattern å¯¦ä½œ

#### 2.2.1 Repositoryä»‹é¢å®šç¾©
```dart
// lib/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Future<Either<Failure, User>> registerUser(RegisterUserParams params);
  Future<Either<Failure, LoginResponse>> loginUser(LoginUserParams params);
  Future<Either<Failure, User>> getUserProfile();
  Future<Either<Failure, User>> updateUserProfile(UpdateUserParams params);
  Future<Either<Failure, void>> logoutUser();
}
```

#### 2.2.2 Repositoryå¯¦ä½œ
```dart
// lib/data/repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;
  final NetworkInfo networkInfo;

  AuthRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
    required this.networkInfo,
  });

  @override
  Future<Either<Failure, User>> registerUser(RegisterUserParams params) async {
    try {
      if (await networkInfo.isConnected) {
        final result = await remoteDataSource.registerUser(params);
        await localDataSource.cacheUser(result);
        return Right(result);
      } else {
        return Left(NetworkFailure('ç¶²è·¯é€£ç·šç•°å¸¸'));
      }
    } on ServerException {
      return Left(ServerFailure('ä¼ºæœå™¨éŒ¯èª¤'));
    } on CacheException {
      return Left(CacheFailure('æœ¬åœ°å„²å­˜éŒ¯èª¤'));
    }
  }
}
```

---

## 6.0 APIæœå‹™å±¤è¨­è¨ˆï¼ˆAPI Services Layerï¼‰

### 3.1 çµ±ä¸€APIå®¢æˆ¶ç«¯è¨­è¨ˆ

#### 3.1.1 APIå®¢æˆ¶ç«¯æ ¸å¿ƒå¯¦ä½œ
```dart
// lib/core/api/api_client.dart
class ApiClient {
  static const String baseUrl = 'https://lcas-api.replit.app/api/v1';
  late final Dio _dio;

  ApiClient() {
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ));

    _setupInterceptors();
  }

  void _setupInterceptors() {
    _dio.interceptors.addAll([
      AuthInterceptor(), // JWT Tokenè‡ªå‹•ç®¡ç†
      LoggingInterceptor(), // è«‹æ±‚/å›æ‡‰æ—¥èªŒ
      CacheInterceptor(), // å¿«å–è™•ç†
      ErrorInterceptor(), // éŒ¯èª¤è™•ç†
    ]);
  }

  // For integration tests
  void setAuthToken(String token) {
    _dio.options.headers['Authorization'] = 'Bearer $token';
  }

  Future<Response> get(String path, {Map<String, dynamic>? queryParameters}) async {
    return await _dio.get(path, queryParameters: queryParameters);
  }

  Future<Response> post(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async {
    return await _dio.post(path, data: data, queryParameters: queryParameters);
  }

  Future<Response> put(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async {
    return await _dio.put(path, data: data, queryParameters: queryParameters);
  }

  Future<Response> delete(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async {
    return await _dio.delete(path, data: data, queryParameters: queryParameters);
  }

  // Generic request method for flexibility
  Future<Response> request(String path, {
    required Options options,
    dynamic data,
    Map<String, dynamic>? queryParameters,
  }) async {
    return await _dio.request(
      path,
      data: data,
      queryParameters: queryParameters,
      options: options,
    );
  }
}
```

#### 3.1.2 JWT Tokenè‡ªå‹•ç®¡ç†
```dart
// lib/core/api/auth_interceptor.dart
class AuthInterceptor extends Interceptor {
  final TokenRepository _tokenRepository; // Assume TokenRepository is available via DI

  AuthInterceptor({required TokenRepository tokenRepository}) : _tokenRepository = tokenRepository;

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final token = await _tokenRepository.getAccessToken(); // Assuming async getter
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode == 401) {
      // TokenéæœŸï¼Œå˜—è©¦åˆ·æ–°
      final refreshed = await _refreshToken();
      if (refreshed) {
        // é‡è©¦åŸå§‹è«‹æ±‚
        final response = await _retry(err.requestOptions);
        handler.resolve(response);
        return;
      }
      // åˆ·æ–°å¤±æ•—ï¼Œæ¸…é™¤Tokenä¸¦å°å‘ç™»å…¥
      await _tokenRepository.clearTokens();
      NavigationService.pushAndClearStack('/login'); // Assuming NavigationService is available
    }
    handler.next(err);
  }

  Future<bool> _refreshToken() async {
    // Implement token refresh logic here
    // e.g., call a refresh token API, store new tokens
    return false; // Placeholder
  }

  Future<Response<dynamic>> _retry(RequestOptions requestOptions) async {
    // Retry the original request
    final options = Options(method: requestOptions.method, headers: requestOptions.headers);
    return await Dio().request<dynamic>(
      requestOptions.path,
      data: requestOptions.data,
      queryParameters: requestOptions.queryParameters,
      options: options,
    );
  }
}
```

### 3.2 APIç«¯é»å®šç¾©

#### 3.2.1 APIç«¯é»å¸¸æ•¸å®šç¾©
```dart
// lib/core/api/api_endpoints.dart
class ApiEndpoints {
  // èªè­‰ç®¡ç†ç¾¤çµ„ (F001-F005)
  static const String registerUser = '/auth/register';
  static const String loginUser = '/auth/login';
  static const String getUserProfile = '/auth/user';
  static const String updateUserProfile = '/auth/user';
  static const String logoutUser = '/auth/logout';

  // åŸºç¤è¨˜å¸³ç¾¤çµ„ (F006-F009)
  static const String createEntry = '/entries'; // Used by create_entry.dart
  static const String quickEntry = '/entries/quick';
  static const String getEntries = '/entries'; // Used by get_entries.dart
  static const String updateEntry = '/entries/{id}';
  static const String deleteEntry = '/entries/{id}';

  // å¤šå¸³æœ¬ç®¡ç†ç¾¤çµ„ (F010-F015)
  static const String createProject = '/projects';
  static const String getProjects = '/projects';
  static const String updateProject = '/projects/{id}';
  static const String deleteProject = '/projects/{id}';
  static const String getProjectMembers = '/projects/{id}/members';
  static const String switchLedger = '/ledgers/switch'; // Corrected path

  // é ç®—ç®¡ç†ç¾¤çµ„ (F016-F018)
  static const String createBudget = '/budgets';
  static const String getBudgetProgress = '/budgets/{id}/progress';
  static const String setBudgetAlerts = '/budgets/{id}/alerts';

  // å”ä½œåŠŸèƒ½ç¾¤çµ„ (F019-F021)
  static const String createSharedLedger = '/shared/ledgers';
  static const String setMemberPermissions = '/shared/ledgers/{id}/permissions';
  static const String realtimeSync = '/sync/realtime'; // WebSocket

  // å ±è¡¨åŠŸèƒ½ç¾¤çµ„ (F022-F024)
  static const String generateReport = '/reports/generate';
  static const String createCustomReport = '/reports/custom';
  static const String exportReport = '/reports/{id}/export';

  // ç³»çµ±ç®¡ç†ç¾¤çµ„ (F025-F032)
  static const String scheduleBackup = '/system/backup/schedule';
  static const String manualBackup = '/backups/manual';
  static const String listBackups = '/backups';
  static const String checkSyncStatus = '/system/sync/status'; // Corrected path
  static const String systemHealth = '/system/health';
  static const String errorLogs = '/system/logs/errors';
  static const String createReminder = '/reminders';
  static const String executeReminder = '/reminders/execute';
}
```

---

## 7.0 32å€‹APIç«¯é»æ•´åˆï¼ˆAPI Endpoints Integrationï¼‰

### 4.1 èªè­‰ç®¡ç†æœå‹™ (F001-F005)

#### 4.1.1 AuthServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/auth_remote_datasource.dart
abstract class AuthRemoteDataSource {
  Future<UserModel> registerUser(RegisterUserParams params);
  Future<LoginResponseModel> loginUser(LoginUserParams params);
  Future<UserModel> getUserProfile();
  Future<UserModel> updateUserProfile(UpdateUserParams params);
  Future<void> logoutUser();
}

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final ApiClient apiClient;

  AuthRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<UserModel> registerUser(RegisterUserParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.registerUser,
      data: params.toJson(),
    );
    return UserModel.fromJson(response.data);
  }

  @override
  Future<LoginResponseModel> loginUser(LoginUserParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.loginUser,
      data: params.toJson(),
    );
    return LoginResponseModel.fromJson(response.data);
  }

  @override
  Future<UserModel> getUserProfile() async {
    final response = await apiClient.get(ApiEndpoints.getUserProfile);
    return UserModel.fromJson(response.data);
  }

  @override
  Future<UserModel> updateUserProfile(UpdateUserParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateUserProfile,
      data: params.toJson(),
    );
    return UserModel.fromJson(response.data);
  }

  @override
  Future<void> logoutUser() async {
    await apiClient.post(ApiEndpoints.logoutUser);
  }
}
```

### 4.2 åŸºç¤è¨˜å¸³æœå‹™ (F006-F009)

#### 4.2.1 EntryServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/entry_remote_datasource.dart
// Assuming EntryRemoteDataSource abstract class is defined elsewhere
abstract class EntryRemoteDataSource {
  Future<EntryModel> createEntry(CreateEntryParams params);
  Future<PaginatedEntriesModel> queryEntries(EntryQueryParams params);
  Future<SubjectsListModel> getSubjectsList(SubjectsQueryParams params);
  Future<UserSettingsModel> updateUserSettings(UpdateUserSettingsParams params);
  Future<EntryModel> updateEntry(String id, UpdateEntryParams params);
  Future<void> deleteEntry(String id);
}

class EntryRemoteDataSourceImpl implements EntryRemoteDataSource {
  final ApiClient apiClient;

  EntryRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<EntryModel> createEntry(CreateEntryParams params) async {
    final response = await apiClient.post(
      '/app/ledger/entry', // This path seems different from ApiEndpoints.createEntry. Keeping as is from original code.
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }

  @override
  Future<PaginatedEntriesModel> queryEntries(EntryQueryParams params) async {
    final response = await apiClient.get(
      '/app/ledger/query', // This path seems different from ApiEndpoints.getEntries. Keeping as is from original code.
      queryParameters: params.toJson(),
    );
    return PaginatedEntriesModel.fromJson(response.data);
  }

  @override
  Future<SubjectsListModel> getSubjectsList(SubjectsQueryParams params) async {
    final response = await apiClient.get(
      '/app/subjects/list', // Corrected path
      queryParameters: params.toJson(),
    );
    return SubjectsListModel.fromJson(response.data);
  }

  @override
  Future<UserSettingsModel> updateUserSettings(UpdateUserSettingsParams params) async {
    final response = await apiClient.put(
      '/app/user/settings', // This path seems different from ApiEndpoints.updateUserSettings. Keeping as is from original code.
      data: params.toJson(),
    );
    return UserSettingsModel.fromJson(response.data);
  }

  @override
  Future<EntryModel> updateEntry(String id, UpdateEntryParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateEntry.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }

  @override
  Future<void> deleteEntry(String id) async {
    await apiClient.delete(ApiEndpoints.deleteEntry.replaceAll('{id}', id));
  }
}
```

### 4.3 å¤šå¸³æœ¬ç®¡ç†æœå‹™ (F010-F015)

#### 4.3.1 ProjectLedgerServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/project_ledger_remote_datasource.dart
// Assuming ProjectLedgerRemoteDataSource abstract class is defined elsewhere
abstract class ProjectLedgerRemoteDataSource {
  Future<ProjectModel> createProject(CreateProjectParams params);
  Future<ProjectModel> manageProject(ManageProjectParams params);
  Future<void> deleteProject(DeleteProjectParams params);
  Future<CategoryModel> createCategory(CreateCategoryParams params);
  Future<CategoryModel> manageCategory(ManageCategoryParams params);
  Future<LedgerSwitchResponseModel> switchLedger(SwitchLedgerParams params);
  Future<List<ProjectModel>> getProjects(); // Added for preloading
}

class ProjectLedgerRemoteDataSourceImpl implements ProjectLedgerRemoteDataSource {
  final ApiClient apiClient;

  ProjectLedgerRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<ProjectModel> createProject(CreateProjectParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createProject,
      data: params.toJson(),
    );
    return ProjectModel.fromJson(response.data);
  }

  @override
  Future<ProjectModel> manageProject(ManageProjectParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateProject.replaceAll('{id}', params.projectId),
      data: params.toJson(),
    );
    return ProjectModel.fromJson(response.data);
  }

  @override
  Future<void> deleteProject(DeleteProjectParams params) async {
    await apiClient.delete(
      ApiEndpoints.deleteProject.replaceAll('{id}', params.projectId),
      data: params.toJson(),
    );
  }

  @override
  Future<CategoryModel> createCategory(CreateCategoryParams params) async {
    final response = await apiClient.post(
      '/app/categories/create', // This path seems different from ApiEndpoints.createCategory. Keeping as is from original code.
      data: params.toJson(),
    );
    return CategoryModel.fromJson(response.data);
  }

  @override
  Future<CategoryModel> manageCategory(ManageCategoryParams params) async {
    final response = await apiClient.put(
      '/app/categories/manage', // This path seems different from ApiEndpoints.manageCategory. Keeping as is from original code.
      data: params.toJson(),
    );
    return CategoryModel.fromJson(response.data);
  }

  @override
  Future<LedgerSwitchResponseModel> switchLedger(SwitchLedgerParams params) async {
    final response = await apiClient.get(
      '/app/ledgers/switch', // Corrected path
      queryParameters: params.toJson(),
    );
    return LedgerSwitchResponseModel.fromJson(response.data);
  }

  @override
  Future<List<ProjectModel>> getProjects() async {
    final response = await apiClient.get(ApiEndpoints.getProjects);
    final List<dynamic> dataList = response.data;
    return dataList.map((json) => ProjectModel.fromJson(json)).toList();
  }
}
```

### 4.4 é ç®—ç®¡ç†æœå‹™ (F016-F018)

#### 4.4.1 BudgetServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/budget_remote_datasource.dart
// Assuming BudgetRemoteDataSource abstract class is defined elsewhere
abstract class BudgetRemoteDataSource {
  Future<BudgetModel> createBudget(CreateBudgetParams params);
  Future<BudgetProgressModel> getBudgetProgress(String id);
  Future<BudgetAlertResponseModel> setBudgetAlerts(String id, SetBudgetAlertsParams params);
}

class BudgetRemoteDataSourceImpl implements BudgetRemoteDataSource {
  final ApiClient apiClient;

  BudgetRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<BudgetModel> createBudget(CreateBudgetParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createBudget,
      data: params.toJson(),
    );
    return BudgetModel.fromJson(response.data);
  }

  @override
  Future<BudgetProgressModel> getBudgetProgress(String id) async {
    final response = await apiClient.get(
      ApiEndpoints.getBudgetProgress.replaceAll('{id}', id)
    );
    return BudgetProgressModel.fromJson(response.data);
  }

  @override
  Future<BudgetAlertResponseModel> setBudgetAlerts(
    String id, 
    SetBudgetAlertsParams params
  ) async {
    final response = await apiClient.put(
      ApiEndpoints.setBudgetAlerts.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return BudgetAlertResponseModel.fromJson(response.data);
  }
}
```

### 4.5 å”ä½œåŠŸèƒ½æœå‹™ (F019-F021)

#### 4.5.1 CollaborationServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/collaboration_remote_datasource.dart
// Assuming CollaborationRemoteDataSource abstract class is defined elsewhere
abstract class CollaborationRemoteDataSource {
  Future<SharedLedgerModel> createSharedLedger(CreateSharedLedgerParams params);
  Future<PermissionResponseModel> setMemberPermissions(String id, SetPermissionsParams params);
  Stream<RealtimeSyncEvent> connectRealtimeSync(String ledgerId);
}

class CollaborationRemoteDataSourceImpl implements CollaborationRemoteDataSource {
  final ApiClient apiClient;

  CollaborationRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<SharedLedgerModel> createSharedLedger(CreateSharedLedgerParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createSharedLedger,
      data: params.toJson(),
    );
    return SharedLedgerModel.fromJson(response.data);
  }

  @override
  Future<PermissionResponseModel> setMemberPermissions(
    String id, 
    SetPermissionsParams params
  ) async {
    final response = await apiClient.put(
      ApiEndpoints.setMemberPermissions.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return PermissionResponseModel.fromJson(response.data);
  }

  // WebSocketé€£ç·šè™•ç†
  @override
  Stream<RealtimeSyncEvent> connectRealtimeSync(String ledgerId) {
    // Using IOWebSocketChannel for WebSocket connection
    final channel = IOWebSocketChannel.connect(
      '${ApiClient.baseUrl}${ApiEndpoints.realtimeSync}?ledger_id=$ledgerId'
    );

    return channel.stream.map((data) {
      final json = jsonDecode(data);
      return RealtimeSyncEvent.fromJson(json);
    });
  }
}
```

### 4.6 å ±è¡¨åŠŸèƒ½æœå‹™ (F022-F024)

#### 4.6.1 ReportServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/report_remote_datasource.dart
// Assuming ReportRemoteDataSource abstract class is defined elsewhere
abstract class ReportRemoteDataSource {
  Future<ReportModel> generateReport(GenerateReportParams params);
  Future<CustomReportModel> createCustomReport(CreateCustomReportParams params);
  Future<ExportResponseModel> exportReport(String id, ExportReportParams params);
}

class ReportRemoteDataSourceImpl implements ReportRemoteDataSource {
  final ApiClient apiClient;

  ReportRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<ReportModel> generateReport(GenerateReportParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.generateReport,
      data: params.toJson(),
    );
    return ReportModel.fromJson(response.data);
  }

  @override
  Future<CustomReportModel> createCustomReport(CreateCustomReportParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createCustomReport,
      data: params.toJson(),
    );
    return CustomReportModel.fromJson(response.data);
  }

  @override
  Future<ExportResponseModel> exportReport(String id, ExportReportParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.exportReport.replaceAll('{id}', id),
      queryParameters: params.toJson(),
    );
    return ExportResponseModel.fromJson(response.data);
  }
}
```

### 4.7 ç³»çµ±ç®¡ç†æœå‹™ (F025-F032)

#### 4.7.1 SystemServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/system_remote_datasource.dart
// Assuming SystemRemoteDataSource abstract class is defined elsewhere
abstract class SystemRemoteDataSource {
  Future<BackupScheduleModel> scheduleBackup(ScheduleBackupParams params);
  Future<BackupResponseModel> manualBackup(ManualBackupParams params);
  Future<BackupListModel> listBackups(ListBackupsParams params);
  Future<SyncStatusModel> checkSyncStatus(CheckSyncParams params);
  Future<SystemHealthModel> getSystemHealth();
  Future<ErrorLogsModel> getErrorLogs(ErrorLogsParams params);
  Future<ReminderModel> createReminder(CreateReminderParams params);
  Future<ReminderExecutionModel> executeReminder(ExecuteReminderParams params);
}

class SystemRemoteDataSourceImpl implements SystemRemoteDataSource {
  final ApiClient apiClient;

  SystemRemoteDataSourceImpl({required this.apiClient});

  @override
  Future<BackupScheduleModel> scheduleBackup(ScheduleBackupParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.scheduleBackup,
      data: params.toJson(),
    );
    return BackupScheduleModel.fromJson(response.data);
  }

  @override
  Future<BackupResponseModel> manualBackup(ManualBackupParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.manualBackup,
      data: params.toJson(),
    );
    return BackupResponseModel.fromJson(response.data);
  }

  @override
  Future<BackupListModel> listBackups(ListBackupsParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.listBackups,
      queryParameters: params.toJson(),
    );
    return BackupListModel.fromJson(response.data);
  }

  @override
  Future<SyncStatusModel> checkSyncStatus(CheckSyncParams params) async {
    final response = await apiClient.get(
      '/system/sync/status', // Corrected path
      queryParameters: params.toJson(),
    );
    return SyncStatusModel.fromJson(response.data);
  }

  @override
  Future<SystemHealthModel> getSystemHealth() async {
    final response = await apiClient.get(ApiEndpoints.systemHealth);
    return SystemHealthModel.fromJson(response.data);
  }

  @override
  Future<ErrorLogsModel> getErrorLogs(ErrorLogsParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.errorLogs,
      queryParameters: params.toJson(),
    );
    return ErrorLogsModel.fromJson(response.data);
  }

  @override
  Future<ReminderModel> createReminder(CreateReminderParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createReminder,
      data: params.toJson(),
    );
    return ReminderModel.fromJson(response.data);
  }

  @override
  Future<ReminderExecutionModel> executeReminder(ExecuteReminderParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.executeReminder,
      data: params.toJson(),
    );
    return ReminderExecutionModel.fromJson(response.data);
  }
}
```

---

## 8.0 è³‡æ–™æ¨¡å‹å®šç¾©ï¼ˆData Modelsï¼‰

### 5.1 æ ¸å¿ƒè³‡æ–™æ¨¡å‹

#### 5.1.1 ä½¿ç”¨è€…ç›¸é—œæ¨¡å‹
```dart
// lib/data/models/user_model.dart
// Assuming User entity is defined in domain/entities/user.dart
// Assuming LocationModel is defined elsewhere
@JsonSerializable()
class UserModel extends User {
  final String uid;
  final String displayName;
  final String email;
  final String userType;
  final DateTime createdAt;
  final DateTime lastLogin;

  const UserModel({
    required this.uid,
    required this.displayName,
    required this.email,
    required this.userType,
    required this.createdAt,
    required this.lastLogin,
  }) : super(
    uid: uid,
    displayName: displayName,
    email: email,
    userType: userType,
    createdAt: createdAt,
    lastLogin: lastLogin,
  );

  factory UserModel.fromJson(Map<String, dynamic> json) => _$UserModelFromJson(json);
  Map<String, dynamic> toJson() => _$UserModelToJson(this);
}

@JsonSerializable()
class LoginResponseModel {
  final bool success;
  final String accessToken;
  final String refreshToken;
  final UserModel userInfo;
  final int expiresIn;

  const LoginResponseModel({
    required this.success,
    required this.accessToken,
    required this.refreshToken,
    required this.userInfo,
    required this.expiresIn,
  });

  factory LoginResponseModel.fromJson(Map<String, dynamic> json) => 
      _$LoginResponseModelFromJson(json);
  Map<String, dynamic> toJson() => _$LoginResponseModelToJson(this);
}
```

#### 5.1.2 è¨˜å¸³ç›¸é—œæ¨¡å‹
```dart
// lib/data/models/entry_model.dart
// Assuming Entry entity, SubjectsListModel, UserSettingsModel are defined
@JsonSerializable()
class EntryModel extends Entry {
  final String entryId;
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;

  const EntryModel({
    required this.entryId,
    required this.entryType,
    required this.amount,
    required this.subjectCode,
    required this.subjectName,
    required this.ledgerId,
    required this.entryDate,
    this.description,
    this.tags,
    this.location,
  }) : super(
    entryId: entryId,
    entryType: entryType,
    amount: amount,
    subjectCode: subjectCode,
    subjectName: subjectName,
    ledgerId: ledgerId,
    entryDate: entryDate,
    description: description,
    tags: tags,
    location: location,
  );

  factory EntryModel.fromJson(Map<String, dynamic> json) => _$EntryModelFromJson(json);
  Map<String, dynamic> toJson() => _$EntryModelToJson(this);
}

@JsonSerializable()
class PaginatedEntriesModel {
  final bool success;
  final List<EntryModel> entries;
  final EntrySummaryModel summary;
  final PaginationModel pagination;

  const PaginatedEntriesModel({
    required this.success,
    required this.entries,
    required this.summary,
    required this.pagination,
  });

  factory PaginatedEntriesModel.fromJson(Map<String, dynamic> json) => 
      _$PaginatedEntriesModelFromJson(json);
  Map<String, dynamic> toJson() => _$PaginatedEntriesModelToJson(this);
}

// Dummy classes for compilation, replace with actual definitions
class Entry {}
class LocationModel {}
class EntrySummaryModel {}
class PaginationModel {}
class SubjectsListModel {}
class UserSettingsModel {}
```

#### 5.1.3 å°ˆæ¡ˆå¸³æœ¬æ¨¡å‹
```dart
// lib/data/models/project_model.dart
// Assuming Project entity, BudgetSettingsModel, AccessSettingsModel are defined
@JsonSerializable()
class ProjectModel extends Project {
  final String projectId;
  final String projectName;
  final String description;
  final DateTime startDate;
  final DateTime endDate;
  final String currency;
  final String projectType;
  final String status;
  final String ownerUid;
  final BudgetSettingsModel? budgetSettings;
  final AccessSettingsModel accessSettings;

  const ProjectModel({
    required this.projectId,
    required this.projectName,
    required this.description,
    required this.startDate,
    required this.endDate,
    required this.currency,
    required this.projectType,
    required this.status,
    required this.ownerUid,
    this.budgetSettings,
    required this.accessSettings,
  }) : super(
    projectId: projectId,
    projectName: projectName,
    description: description,
    startDate: startDate,
    endDate: endDate,
    currency: currency,
    projectType: projectType,
    status: status,
    ownerUid: ownerUid,
  );

  factory ProjectModel.fromJson(Map<String, dynamic> json) => 
      _$ProjectModelFromJson(json);
  Map<String, dynamic> toJson() => _$ProjectModelToJson(this);
}

// Dummy classes for compilation, replace with actual definitions
class Project {}
class BudgetSettingsModel {}
class AccessSettingsModel {}
```

### 5.2 APIåƒæ•¸æ¨¡å‹

#### 5.2.1 è«‹æ±‚åƒæ•¸æ¨¡å‹
```dart
// lib/data/models/params/auth_params.dart
// Assuming DeviceInfoModel is defined elsewhere
@JsonSerializable()
class RegisterUserParams {
  final String platform;
  final String? lineUid;
  final DeviceInfoModel deviceInfo;
  final String displayName;
  final String timezone;
  final String authProvider;

  const RegisterUserParams({
    required this.platform,
    this.lineUid,
    required this.deviceInfo,
    required this.displayName,
    required this.timezone,
    required this.authProvider,
  });

  factory RegisterUserParams.fromJson(Map<String, dynamic> json) => 
      _$RegisterUserParamsFromJson(json);
  Map<String, dynamic> toJson() => _$RegisterUserParamsToJson(this);
}

@JsonSerializable()
class LoginUserParams {
  final String platform;
  final String? lineUid;
  final String? email;
  final String? password;
  final String authProvider;
  final DeviceInfoModel deviceInfo;

  const LoginUserParams({
    required this.platform,
    this.lineUid,
    this.email,
    this.password,
    required this.authProvider,
    required this.deviceInfo,
  });

  factory LoginUserParams.fromJson(Map<String, dynamic> json) => 
      _$LoginUserParamsFromJson(json);
  Map<String, dynamic> toJson() => _$LoginUserParamsToJson(this);
}

class DeviceInfoModel {
  final String deviceType;
  final String appVersion;
  DeviceInfoModel({required this.deviceType, required this.appVersion});
  factory DeviceInfoModel.fromJson(Map<String, dynamic> json) => DeviceInfoModel(deviceType: json['deviceType'], appVersion: json['appVersion']);
  Map<String, dynamic> toJson() => {'deviceType': deviceType, 'appVersion': appVersion};
}
```

#### 5.2.2 è¨˜å¸³åƒæ•¸æ¨¡å‹
```dart
// lib/data/models/params/entry_params.dart
// Assuming EntryFiltersModel, PaginationParamsModel, SortOptionsModel are defined
@JsonSerializable()
class CreateEntryParams {
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;

  const CreateEntryParams({
    required this.entryType,
    required this.amount,
    required this.subjectCode,
    required this.subjectName,
    required this.ledgerId,
    required this.entryDate,
    this.description,
    this.tags,
    this.location,
  });

  factory CreateEntryParams.fromJson(Map<String, dynamic> json) => 
      _$CreateEntryParamsFromJson(json);
  Map<String, dynamic> toJson() => _$CreateEntryParamsToJson(this);
}

@JsonSerializable()
class EntryQueryParams {
  final EntryFiltersModel? filters;
  final PaginationParamsModel? pagination;
  final SortOptionsModel? sort;

  const EntryQueryParams({
    this.filters,
    this.pagination,
    this.sort,
  });

  factory EntryQueryParams.fromJson(Map<String, dynamic> json) => 
      _$EntryQueryParamsFromJson(json);
  Map<String, dynamic> toJson() => _$EntryQueryParamsToJson(this);
}

// Dummy classes for compilation, replace with actual definitions
class EntryFiltersModel {}
class PaginationParamsModel {}
class SortOptionsModel {}
```

---

## 9.0 ç‹€æ…‹ç®¡ç†ç­–ç•¥ï¼ˆState Managementï¼‰

### 6.1 Providerç‹€æ…‹ç®¡ç†å¯¦ä½œ

#### 6.1.1 å…¨åŸŸç‹€æ…‹ç®¡ç†
```dart
// lib/presentation/providers/app_state_provider.dart
// Assuming User, Project, LoginUser, LogoutUser, SwitchLedger, SwitchLedgerParams are defined
class AppStateProvider extends ChangeNotifier {
  // èªè­‰ç‹€æ…‹
  User? _currentUser;
  bool _isAuthenticated = false;

  // å¸³æœ¬ç‹€æ…‹
  String? _currentLedgerId;
  List<ProjectModel> _projects = [];

  // ç¶²è·¯ç‹€æ…‹
  bool _isOnline = true;

  // Getters
  User? get currentUser => _currentUser;
  bool get isAuthenticated => _isAuthenticated;
  String? get currentLedgerId => _currentLedgerId;
  List<ProjectModel> get projects => _projects;
  bool get isOnline => _isOnline;

  // èªè­‰ç›¸é—œæ–¹æ³•
  Future<void> login(LoginUserParams params) async {
    try {
      final result = await sl<LoginUser>().call(params);
      result.fold(
        (failure) => throw Exception(failure.message),
        (loginResponse) {
          _currentUser = loginResponse.userInfo;
          _isAuthenticated = true;
          notifyListeners();
        },
      );
    } catch (e) {
      throw Exception('ç™»å…¥å¤±æ•—: $e');
    }
  }

  Future<void> logout() async {
    try {
      await sl<LogoutUser>().call();
      _currentUser = null;
      _isAuthenticated = false;
      _currentLedgerId = null;
      _projects.clear();
      notifyListeners();
    } catch (e) {
      throw Exception('ç™»å‡ºå¤±æ•—: $e');
    }
  }

  // å¸³æœ¬ç›¸é—œæ–¹æ³•
  Future<void> switchLedger(String ledgerId) async {
    try {
      final result = await sl<SwitchLedger>().call(
        SwitchLedgerParams(targetLedgerId: ledgerId)
      );
      result.fold(
        (failure) => throw Exception(failure.message),
        (switchResponse) {
          _currentLedgerId = ledgerId;
          notifyListeners();
        },
      );
    } catch (e) {
      throw Exception('å¸³æœ¬åˆ‡æ›å¤±æ•—: $e');
    }
  }

  // ç¶²è·¯ç‹€æ…‹ç®¡ç†
  void updateNetworkStatus(bool isOnline) {
    _isOnline = isOnline;
    notifyListeners();
  }
}
```

#### 6.1.2 åŠŸèƒ½å°ˆå±¬ç‹€æ…‹ç®¡ç†
```dart
// lib/presentation/providers/entry_provider.dart
// Assuming Entry, CreateEntryParams, EntryQueryParams, PaginatedEntries, PaginationModel, etc. are defined
class EntryProvider extends ChangeNotifier {
  final CreateEntry _createEntry;
  final GetEntries _getEntries;
  final UpdateEntry _updateEntry;
  final DeleteEntry _deleteEntry;

  EntryProvider({
    required CreateEntry createEntry,
    required GetEntries getEntries,
    required UpdateEntry updateEntry,
    required DeleteEntry deleteEntry,
  }) : _createEntry = createEntry,
       _getEntries = getEntries,
       _updateEntry = updateEntry,
       _deleteEntry = deleteEntry;

  // ç‹€æ…‹è®Šæ•¸
  List<Entry> _entries = [];
  bool _isLoading = false;
  String? _error;
  PaginationModel? _pagination;

  // Getters
  List<Entry> get entries => _entries;
  bool get isLoading => _isLoading;
  String? get error => _error;
  PaginationModel? get pagination => _pagination;

  // æ–°å¢è¨˜å¸³è¨˜éŒ„
  Future<void> createEntry(CreateEntryParams params) async {
    _setLoading(true);
    _clearError();

    final result = await _createEntry(params);
    result.fold(
      (failure) => _setError(failure.message),
      (entry) {
        _entries.insert(0, entry);
        notifyListeners();
      },
    );

    _setLoading(false);
  }

  // æŸ¥è©¢è¨˜å¸³è¨˜éŒ„
  Future<void> getEntries(EntryQueryParams params) async {
    _setLoading(true);
    _clearError();

    final result = await _getEntries(params);
    result.fold(
      (failure) => _setError(failure.message),
      (paginatedEntries) {
        _entries = paginatedEntries.entries;
        _pagination = paginatedEntries.pagination;
        notifyListeners();
      },
    );

    _setLoading(false);
  }

  // è¼‰å…¥æ›´å¤šè¨˜éŒ„
  Future<void> loadMore() async {
    if (_pagination?.hasNext != true || _isLoading) return;

    final nextPage = (_pagination?.currentPage ?? 0) + 1;
    final params = EntryQueryParams(
      pagination: PaginationParamsModel(
        page: nextPage,
        limit: _pagination?.limit ?? 20,
      ),
    );

    final result = await _getEntries(params);
    result.fold(
      (failure) => _setError(failure.message),
      (paginatedEntries) {
        _entries.addAll(paginatedEntries.entries);
        _pagination = paginatedEntries.pagination;
        notifyListeners();
      },
    );
  }

  // ç§æœ‰æ–¹æ³•
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
  }
}
```

### 6.2 Use Caseså¯¦ä½œ

#### 6.2.1 èªè­‰ç›¸é—œUse Cases
```dart
// lib/domain/usecases/auth/login_user.dart
// Assuming UseCase, LoginResponse, LoginUserParams, AuthRepository are defined
class LoginUser implements UseCase<LoginResponse, LoginUserParams> {
  final AuthRepository repository;

  LoginUser(this.repository);

  @override
  Future<Either<Failure, LoginResponse>> call(LoginUserParams params) async {
    return await repository.loginUser(params);
  }
}

// lib/domain/usecases/auth/register_user.dart
// Assuming UseCase, User, RegisterUserParams, AuthRepository are defined
class RegisterUser implements UseCase<User, RegisterUserParams> {
  final AuthRepository repository;

  RegisterUser(this.repository);

  @override
  Future<Either<Failure, User>> call(RegisterUserParams params) async {
    return await repository.registerUser(params);
  }
}

// Dummy definitions for compilation
abstract class UseCase<Type, Params> {
  Future<Either<Failure, Type>> call(Params params);
}
class LoginResponse {
  final dynamic userInfo;
  final dynamic accessToken;
  final dynamic refreshToken;
  final bool success;
  final int expiresIn;
  LoginResponse({required this.userInfo, required this.accessToken, required this.refreshToken, required this.success, required this.expiresIn});
}
class User {}
class AuthRepository {}
class Failure {}
class Right<L, R> extends Either<L, R> {
  final R value;
  const Right(this.value);
  @override
  Either<L, R> get orElse => this;
  @override
  R get getOrNull => value;
}
class Left<L, R> extends Either<L, R> {
  final L value;
  const Left(this.value);
  @override
  Either<L, R> get orElse => this;
  @override
  R? get getOrNull => null;
}
abstract class Either<L, R> {
  const Either();
  bool get isRight => this is Right<L, R>;
  bool get isLeft => this is Left<L, R>;
  R get orElse;
  R? get getOrNull;
  factory Either.right(R value) = Right<L, R>;
  factory Either.left(L value) = Left<L, R>;
}
```

#### 6.2.2 è¨˜å¸³ç›¸é—œUse Cases
```dart
// lib/domain/usecases/entry/create_entry.dart
// Assuming Entry, CreateEntryParams, EntryRepository are defined
class CreateEntry implements UseCase<Entry, CreateEntryParams> {
  final EntryRepository repository;

  CreateEntry(this.repository);

  @override
  Future<Either<Failure, Entry>> call(CreateEntryParams params) async {
    // æ¥­å‹™é‚è¼¯é©—è­‰
    if (params.amount <= 0) {
      return Left(ValidationFailure('é‡‘é¡å¿…é ˆå¤§æ–¼0'));
    }

    if (params.subjectCode.isEmpty) {
      return Left(ValidationFailure('ç§‘ç›®ä»£ç¢¼ä¸èƒ½ç‚ºç©º'));
    }

    return await repository.createEntry(params);
  }
}

// lib/domain/usecases/entry/get_entries.dart
// Assuming PaginatedEntries, EntryQueryParams, EntryRepository are defined
class GetEntries implements UseCase<PaginatedEntries, EntryQueryParams> {
  final EntryRepository repository;

  GetEntries(this.repository);

  @override
  Future<Either<Failure, PaginatedEntries>> call(EntryQueryParams params) async {
    return await repository.getEntries(params);
  }
}

// Dummy definitions for compilation
class EntryRepository {}
class PaginatedEntries {}
class ValidationFailure extends Failure {}
```

---

## 10.0 éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼ˆError Handlingï¼‰

### 7.1 çµ±ä¸€éŒ¯èª¤å®šç¾©

#### 7.1.1 éŒ¯èª¤é¡å‹å®šç¾©
```dart
// lib/core/error/failures.dart
import 'package:equatable/equatable.dart';

abstract class Failure extends Equatable {
  final String message;
  final String? code;
  final dynamic details;

  const Failure({
    required this.message,
    this.code,
    this.details,
  });

  @override
  List<Object?> get props => [message, code, details];
}

class ServerFailure extends Failure {
  const ServerFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class NetworkFailure extends Failure {
  const NetworkFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class CacheFailure extends Failure {
  const CacheFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class ValidationFailure extends Failure {
  const ValidationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class AuthenticationFailure extends Failure {
  const AuthenticationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class AuthorizationFailure extends Failure {
  const AuthorizationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}
```

#### 7.1.2 ç•°å¸¸å®šç¾©
```dart
// lib/core/error/exceptions.dart
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic details;

  const AppException({
    required this.message,
    this.code,
    this.details,
  });
}

class ServerException extends AppException {
  const ServerException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}

class NetworkException extends AppException {
  const NetworkException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}

class CacheException extends AppException {
  const CacheException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}
```

### 7.2 éŒ¯èª¤è™•ç†å™¨å¯¦ä½œ

#### 7.2.1 APIéŒ¯èª¤è™•ç†å™¨
```dart
// lib/core/error/api_error_handler.dart
import 'package:dio/dio.dart';
import 'failures.dart'; // Assuming failures.dart is in the same directory or imported correctly

class ApiErrorHandler {
  static Failure handleError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return NetworkFailure(
          'ç¶²è·¯é€£ç·šé€¾æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²è·¯ç‹€æ…‹',
          code: 'NETWORK_TIMEOUT',
        );

      case DioExceptionType.badResponse:
        return _handleHttpError(error.response!);

      case DioExceptionType.connectionError:
        return NetworkFailure(
          'ç„¡æ³•é€£ç·šåˆ°ä¼ºæœå™¨ï¼Œè«‹æª¢æŸ¥ç¶²è·¯è¨­å®š',
          code: 'NETWORK_ERROR',
        );

      case DioExceptionType.cancel:
        return NetworkFailure(
          'è«‹æ±‚å·²å–æ¶ˆ',
          code: 'REQUEST_CANCELLED',
        );

      default:
        return ServerFailure(
          'æœªçŸ¥éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦',
          code: 'UNKNOWN_ERROR',
          details: error.message,
        );
    }
  }

  static Failure _handleHttpError(Response response) {
    final statusCode = response.statusCode;
    final data = response.data;

    String message = 'ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦';
    String? errorCode;

    if (data is Map<String, dynamic>) {
      message = data['message'] ?? message;
      errorCode = data['error_code'];
    }

    switch (statusCode) {
      case 400:
        return ValidationFailure(
          message.isNotEmpty ? message : 'è«‹æ±‚æ ¼å¼éŒ¯èª¤',
          code: errorCode ?? 'BAD_REQUEST',
          details: data,
        );

      case 401:
        return AuthenticationFailure(
          message.isNotEmpty ? message : 'èªè­‰å¤±æ•—ï¼Œè«‹é‡æ–°ç™»å…¥',
          code: errorCode ?? 'UNAUTHORIZED',
          details: data,
        );

      case 403:
        return AuthorizationFailure(
          message.isNotEmpty ? message : 'æ¬Šé™ä¸è¶³ï¼Œç„¡æ³•åŸ·è¡Œæ­¤æ“ä½œ',
          code: errorCode ?? 'FORBIDDEN',
          details: data,
        );

      case 404:
        return ServerFailure(
          message.isNotEmpty ? message : 'æ‰¾ä¸åˆ°è«‹æ±‚çš„è³‡æº',
          code: errorCode ?? 'NOT_FOUND',
          details: data,
        );

      case 422:
        return ValidationFailure(
          message.isNotEmpty ? message : 'è³‡æ–™é©—è­‰å¤±æ•—',
          code: errorCode ?? 'VALIDATION_ERROR',
          details: data,
        );

      case 500:
        return ServerFailure(
          message.isNotEmpty ? message : 'ä¼ºæœå™¨å…§éƒ¨éŒ¯èª¤',
          code: errorCode ?? 'INTERNAL_SERVER_ERROR',
          details: data,
        );

      default:
        return ServerFailure(
          message.isNotEmpty ? message : 'HTTPéŒ¯èª¤ $statusCode',
          code: errorCode ?? 'HTTP_$statusCode',
          details: data,
        );
    }
  }
}
```

#### 7.2.2 éŒ¯èª¤æ””æˆªå™¨
```dart
// lib/core/api/error_interceptor.dart
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart'; // For debugPrint
import 'failures.dart';
import 'api_error_handler.dart';
// Assuming NavigationService, ToastService, TokenRepository are available via DI or globally

class ErrorInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    // è¨˜éŒ„éŒ¯èª¤æ—¥èªŒ
    _logError(err);

    // è™•ç†ç‰¹å®šéŒ¯èª¤é¡å‹
    if (err.response?.statusCode == 401) {
      // TokenéæœŸï¼Œè§¸ç™¼é‡æ–°ç™»å…¥
      await _handleTokenExpired();
    } else if (err.response?.statusCode == 503) {
      // æœå‹™ä¸å¯ç”¨ï¼Œé¡¯ç¤ºç¶­è­·é é¢
      _handleServiceUnavailable();
    }

    // è½‰æ›ç‚ºæ‡‰ç”¨éŒ¯èª¤
    final failure = ApiErrorHandler.handleError(err);

    // é¡¯ç¤ºç”¨æˆ¶å‹å–„çš„éŒ¯èª¤è¨Šæ¯
    _showUserFriendlyError(failure);

    handler.next(err); // Pass the error to the next interceptor or handler
  }

  void _logError(DioException error) {
    debugPrint('API Error: ${error.type}');
    debugPrint('URL: ${error.requestOptions.uri}');
    debugPrint('Method: ${error.requestOptions.method}');
    debugPrint('Status Code: ${error.response?.statusCode}');
    debugPrint('Response: ${error.response?.data}');
  }

  Future<void> _handleTokenExpired() async {
    // Clear local tokens
    // Assume sl<TokenRepository>() is available for dependency injection
    // sl<TokenRepository>().clearTokens();

    // Navigate to login page
    // Assume NavigationService.pushAndClearStack('/login') is available
    // NavigationService.pushAndClearStack('/login');

    // Show a toast message
    // Assume ToastService.showError('ç™»å…¥å·²éæœŸï¼Œè«‹é‡æ–°ç™»å…¥') is available
    // ToastService.showError('ç™»å…¥å·²éæœŸï¼Œè«‹é‡æ–°ç™»å…¥');
  }

  void _handleServiceUnavailable() {
    // Navigate to maintenance page
    // Assume NavigationService.pushNamed('/maintenance') is available
    // NavigationService.pushNamed('/maintenance');
  }

  void _showUserFriendlyError(Failure failure) {
    String message;

    switch (failure.runtimeType) {
      case NetworkFailure:
        message = 'ç¶²è·¯é€£ç·šå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯è¨­å®š';
        break;
      case ServerFailure:
        message = 'ä¼ºæœå™¨æš«æ™‚ç„¡æ³•å›æ‡‰ï¼Œè«‹ç¨å¾Œå†è©¦';
        break;
      case ValidationFailure:
        message = failure.message;
        break;
      case AuthenticationFailure:
        message = 'ç™»å…¥é©—è­‰å¤±æ•—ï¼Œè«‹é‡æ–°ç™»å…¥';
        break;
      case AuthorizationFailure:
        message = 'æ‚¨æ²’æœ‰æ¬Šé™åŸ·è¡Œæ­¤æ“ä½œ';
        break;
      default:
        message = 'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦';
    }

    // Assume ToastService.showError(message) is available
    // ToastService.showError(message);
  }
}
```

---

## 11.0 å¿«å–ç­–ç•¥è¨­è¨ˆï¼ˆCaching Strategyï¼‰

### 8.1 å¤šå±¤æ¬¡å¿«å–æ¶æ§‹

#### 8.1.1 å¿«å–ç®¡ç†å™¨å¯¦ä½œ
```dart
// lib/core/cache/cache_manager.dart
// Using Hive for local storage as an example
import 'package:hive/hive.dart';
import 'package:flutter/foundation.dart'; // For debugPrint

abstract class CacheManager {
  Future<void> put<T>(String key, T data, {Duration? expiry});
  Future<T?> get<T>(String key);
  Future<bool> exists(String key);
  Future<bool> isExpired(String key);
  Future<void> delete(String key);
  Future<void> clear();
  Future<void> clearExpired();
}

class CacheManagerImpl implements CacheManager {
  final Box _box;
  static const String _expiryPrefix = '_expiry_';

  CacheManagerImpl(this._box); // Inject the Hive box

  @override
  Future<void> put<T>(String key, T data, {Duration? expiry}) async {
    await _box.put(key, data);

    if (expiry != null) {
      final expiryTime = DateTime.now().add(expiry);
      await _box.put('$_expiryPrefix$key', expiryTime.millisecondsSinceEpoch);
    }
  }

  @override
  Future<T?> get<T>(String key) async {
    if (await isExpired(key)) {
      await delete(key);
      return null;
    }

    return _box.get(key) as T?;
  }

  @override
  Future<bool> exists(String key) async {
    return _box.containsKey(key) && !await isExpired(key);
  }

  @override
  Future<bool> isExpired(String key) async {
    final expiryKey = '$_expiryPrefix$key';
    if (!_box.containsKey(expiryKey)) {
      return false;
    }

    final expiryTime = _box.get(expiryKey) as int;
    return DateTime.now().millisecondsSinceEpoch > expiryTime;
  }

  @override
  Future<void> delete(String key) async {
    await _box.delete(key);
    await _box.delete('$_expiryPrefix$key');
  }

  @override
  Future<void> clear() async {
    await _box.clear();
  }

  @override
  Future<void> clearExpired() async {
    // Get all keys that start with the expiry prefix
    final expiryKeys = _box.keys.where((key) => key.toString().startsWith(_expiryPrefix)).toList();

    for (final expiryKey in expiryKeys) {
      final dataKey = expiryKey.toString().substring(_expiryPrefix.length);
      if (await isExpired(dataKey)) {
        await delete(dataKey);
      }
    }
  }
}
```

#### 8.1.2 å¿«å–ç­–ç•¥å®šç¾©
```dart
// lib/core/cache/cache_strategies.dart
enum CacheStrategy {
  cacheFirst,    // å„ªå…ˆä½¿ç”¨å¿«å–
  networkFirst,  // å„ªå…ˆç¶²è·¯è«‹æ±‚
  cacheOnly,     // åƒ…ä½¿ç”¨å¿«å–
  networkOnly,   // åƒ…ç¶²è·¯è«‹æ±‚
  staleWhileRevalidate, // ä½¿ç”¨å¿«å–åŒæ™‚æ›´æ–°
}

class CacheConfig {
  final CacheStrategy strategy;
  final Duration? expiry;
  final bool storeOnFailure;
  final int maxRetries;

  const CacheConfig({
    required this.strategy,
    this.expiry,
    this.storeOnFailure = false,
    this.maxRetries = 3,
  });
}

class ApiCacheManager {
  static const Map<String, CacheConfig> _cacheConfigs = {
    // ä½¿ç”¨è€…è³‡æ–™ - ä¸­ç­‰é »ç‡å¿«å–
    'GET:/auth/user': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 30),
    ),

    // è¨˜å¸³æ­·å² - çŸ­æœŸå¿«å–
    'GET:/entries': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 5),
    ),

    // å°ˆæ¡ˆåˆ—è¡¨ - ä¸­æœŸå¿«å–
    'GET:/projects': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 15),
    ),

    // é ç®—é€²åº¦ - çŸ­æœŸå¿«å–
    'GET:/budgets/{id}/progress': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 2),
    ),

    // å ±è¡¨æ•¸æ“š - é•·æœŸå¿«å–
    'GET:/reports': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(hours: 1),
    ),

    // ç³»çµ±å¥åº· - æ¥µçŸ­æœŸå¿«å–
    'GET:/system/health': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(seconds: 30),
    ),

    // å‚™ä»½åˆ—è¡¨ - ä¸­æœŸå¿«å–
    'GET:/backups': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 10),
    ),

    // å³æ™‚æ•¸æ“š - ä¸å¿«å–
    'POST:/entries': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),

    'POST:/entries/quick': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),

    'PUT:/entries/{id}': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),

    'DELETE:/entries/{id}': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
  };

  static CacheConfig getConfig(String method, String path) {
    final key = '$method:$path';
    return _cacheConfigs[key] ?? const CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 5),
    );
  }
}
```

#### 8.1.3 å¿«å–æ””æˆªå™¨å¯¦ä½œ
```dart
// lib/core/api/cache_interceptor.dart
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart'; // For debugPrint
import '../cache/cache_manager.dart';
import 'cache_strategies.dart';

class CacheInterceptor extends Interceptor {
  final CacheManager _cacheManager;

  CacheInterceptor(this._cacheManager);

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(options);
    final config = ApiCacheManager.getConfig(options.method, options.path);

    switch (config.strategy) {
      case CacheStrategy.cacheFirst:
        final cachedData = await _cacheManager.get(cacheKey);
        if (cachedData != null) {
          final response = Response(
            requestOptions: options,
            data: cachedData,
            statusCode: 200,
            headers: Headers.fromMap({'x-cache': ['HIT']}),
          );
          handler.resolve(response);
          return;
        }
        break;

      case CacheStrategy.cacheOnly:
        final cachedData = await _cacheManager.get(cacheKey);
        if (cachedData != null) {
          final response = Response(
            requestOptions: options,
            data: cachedData,
            statusCode: 200,
            headers: Headers.fromMap({'x-cache': ['HIT']}),
          );
          handler.resolve(response);
        } else {
          handler.reject(DioException(
            requestOptions: options,
            error: 'å¿«å–ä¸­ç„¡æ­¤è³‡æ–™ï¼Œä¸”åƒ…å…è¨±å¿«å–å­˜å–',
          ));
        }
        return;

      case CacheStrategy.networkOnly:
        // ä¸ä½¿ç”¨å¿«å–ï¼Œç›´æ¥ç¶²è·¯è«‹æ±‚
        break;

      case CacheStrategy.networkFirst:
      case CacheStrategy.staleWhileRevalidate:
        // å…ˆå˜—è©¦ç¶²è·¯è«‹æ±‚ï¼Œå¤±æ•—æ™‚ä½¿ç”¨å¿«å–
        break;
    }

    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(response.requestOptions);
    final config = ApiCacheManager.getConfig(
      response.requestOptions.method,
      response.requestOptions.path,
    );

    // æ ¹æ“šç­–ç•¥æ±ºå®šæ˜¯å¦å¿«å–
    if (_shouldCache(config, response)) {
      await _cacheManager.put(
        cacheKey,
        response.data,
        expiry: config.expiry,
      );
    }

    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(err.requestOptions);
    final config = ApiCacheManager.getConfig(
      err.requestOptions.method,
      err.requestOptions.path,
    );

    // ç¶²è·¯è«‹æ±‚å¤±æ•—æ™‚ï¼Œå˜—è©¦ä½¿ç”¨å¿«å–
    if (config.strategy == CacheStrategy.networkFirst ||
        config.strategy == CacheStrategy.staleWhileRevalidate) {
      final cachedData = await _cacheManager.get(cacheKey);
      if (cachedData != null) {
        final response = Response(
          requestOptions: err.requestOptions,
          data: cachedData,
          statusCode: 200,
          headers: Headers.fromMap({'x-cache': ['STALE']}),
        );
        handler.resolve(response);
        return;
      }
    }

    handler.next(err);
  }

  String _generateCacheKey(RequestOptions options) {
    final uri = options.uri.toString();
    final method = options.method;
    final queryParams = options.queryParameters.entries
        .map((e) => '${e.key}=${e.value}')
        .join('&');

    return '$method:$uri${queryParams.isNotEmpty ? '?$queryParams' : ''}';
  }

  bool _shouldCache(CacheConfig config, Response response) {
    // åªå¿«å–æˆåŠŸçš„å›æ‡‰
    if (response.statusCode != 200) {
      return config.storeOnFailure;
    }

    // ä¸å¿«å–ç©ºè³‡æ–™
    if (response.data == null) {
      return false;
    }

    return config.strategy != CacheStrategy.networkOnly;
  }
}
```

---

## 12.0 é›¢ç·šåŒæ­¥æ©Ÿåˆ¶ï¼ˆOffline Syncï¼‰

### 9.1 é›¢ç·šæ“ä½œä½‡åˆ—

#### 9.1.1 é›¢ç·šæ“ä½œæ¨¡å‹
```dart
// lib/core/sync/offline_operation.dart
import 'package:json_annotation/json_annotation.dart';
import 'dart:convert'; // For jsonDecode
import 'dart:math' as math; // For math.pow
import 'dart:async'; // For Timer, Completer
import 'package:collection/collection.dart'; // For Iterable.first

part 'offline_operation.g.dart'; // Generated by json_serializable

@JsonSerializable()
class OfflineOperation {
  final String id;
  final String operationType; // create, update, delete
  final String endpoint;
  final String method;
  final Map<String, dynamic>? data;
  final Map<String, String>? headers;
  final DateTime timestamp;
  final int retryCount;
  final DateTime? nextRetry;
  final OperationStatus status;
  final String? errorMessage;

  OfflineOperation({
    required this.id,
    required this.operationType,
    required this.endpoint,
    required this.method,
    this.data,
    this.headers,
    required this.timestamp,
    this.retryCount = 0,
    this.nextRetry,
    this.status = OperationStatus.pending,
    this.errorMessage,
  });

  factory OfflineOperation.fromJson(Map<String, dynamic> json) => _$OfflineOperationFromJson(json);
  Map<String, dynamic> toJson() => _$OfflineOperationToJson(this);
}

enum OperationStatus {
  pending,    // ç­‰å¾…åŒæ­¥
  syncing,    // åŒæ­¥ä¸­
  synced,     // å·²åŒæ­¥
  failed,     // åŒæ­¥å¤±æ•—
  cancelled,  // å·²å–æ¶ˆ
}
```

#### 9.1.2 é›¢ç·šåŒæ­¥ç®¡ç†å™¨
```dart
// lib/core/sync/offline_sync_manager.dart
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:math' as math;
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import '../cache/cache_manager.dart';
import '../api/api_client.dart';
import '../network/connectivity_service.dart'; // Assuming this exists
import 'offline_operation.dart';

class OfflineSyncManager {
  final CacheManager _cacheManager;
  final ApiClient _apiClient;
  final ConnectivityService _connectivity;
  final Queue<OfflineOperation> _syncQueue = Queue();

  static const String _queueKey = 'offline_sync_queue';
  static const int _maxRetries = 3;

  OfflineSyncManager({
    required CacheManager cacheManager,
    required ApiClient apiClient,
    required ConnectivityService connectivity,
  }) : _cacheManager = cacheManager,
       _apiClient = apiClient,
       _connectivity = connectivity;

  // Initialize the sync manager
  Future<void> initialize() async {
    await _loadSyncQueue();
    _connectivity.onConnectivityChanged.listen(_onConnectivityChanged);
    // Process queue if already connected on initialization
    if (await _connectivity.isConnected) {
      _processSyncQueue();
    }
  }

  // Add an offline operation to the queue
  Future<void> queueOperation(OfflineOperation operation) async {
    // Execute the operation locally first
    await _executeLocalOperation(operation);

    // Add to the sync queue
    _syncQueue.add(operation);
    await _persistSyncQueue();

    // If online, try to sync immediately
    if (await _connectivity.isConnected) {
      _processSyncQueue();
    }
  }

  // Process the sync queue
  void _processSyncQueue() {
    // Check connectivity before processing
    if (!_connectivity.isConnected) return;

    Timer.periodic(const Duration(seconds: 5), (timer) async {
      if (_syncQueue.isEmpty) {
        timer.cancel();
        return;
      }

      final operation = _syncQueue.first;

      // Skip if already synced or cancelled
      if (operation.status == OperationStatus.synced || operation.status == OperationStatus.cancelled) {
        _syncQueue.removeFirst();
        await _persistSyncQueue();
        return;
      }

      // Check if it's time to retry
      if (operation.nextRetry != null && DateTime.now().isBefore(operation.nextRetry!)) {
        return; // Wait for the next retry time
      }

      try {
        operation.status = OperationStatus.syncing;
        await _executeRemoteOperation(operation);

        operation.status = OperationStatus.synced;
        _syncQueue.removeFirst(); // Remove successfully synced operation

      } catch (e) {
        await _handleSyncError(operation, e);
      }

      await _persistSyncQueue(); // Persist changes after each operation attempt
    });
  }

  // Execute the operation locally
  Future<void> _executeLocalOperation(OfflineOperation operation) async {
    try {
      switch (operation.operationType) {
        case 'create':
          await _handleLocalCreate(operation);
          break;
        case 'update':
          await _handleLocalUpdate(operation);
          break;
        case 'delete':
          await _handleLocalDelete(operation);
          break;
      }
    } catch (e) {
      debugPrint('Local operation execution failed: $e');
    }
  }

  // Execute remote sync
  Future<void> _executeRemoteOperation(OfflineOperation operation) async {
    final response = await _apiClient.request(
      operation.endpoint,
      options: Options(
        method: operation.method,
        headers: operation.headers,
      ),
      data: operation.data,
    );

    // Update local cache after successful sync
    if (response.statusCode != null && (response.statusCode == 200 || response.statusCode == 201)) {
      await _updateLocalCacheAfterSync(operation, response.data);
    } else {
      throw Exception('Remote operation failed with status: ${response.statusCode}');
    }
  }

  // Handle sync errors
  Future<void> _handleSyncError(OfflineOperation operation, dynamic error) async {
    operation.retryCount++;

    if (operation.retryCount < _maxRetries) {
      // Calculate next retry time using exponential backoff
      final delay = Duration(seconds: math.pow(2, operation.retryCount).toInt());
      operation.nextRetry = DateTime.now().add(delay);
      operation.status = OperationStatus.pending; // Reset status to pending for retry
    } else {
      operation.status = OperationStatus.failed;
      operation.errorMessage = error.toString();
    }
  }

  // Local create operation handling
  Future<void> _handleLocalCreate(OfflineOperation operation) async {
    // For create operations, we might store the data locally with a temporary ID
    // and then update it once synced with a server-generated ID.
    final localId = 'temp_${operation.id}'; // Use a temporary ID
    await _cacheManager.put(localId, operation.data);
  }

  // Local update operation handling
  Future<void> _handleLocalUpdate(OfflineOperation operation) async {
    // For updates, directly modify the cached data if it exists.
    final existingData = await _cacheManager.get(operation.endpoint);
    if (existingData != null) {
      // Merge or replace logic depends on the data structure
      final updatedData = {...existingData as Map<String, dynamic>, ...?operation.data};
      await _cacheManager.put(operation.endpoint, updatedData);
    } else {
      // If data doesn't exist locally, treat it as a create operation maybe?
      // Or handle as an error depending on requirements.
      await _handleLocalCreate(operation); // Re-attempt as create if not found
    }
  }

  // Local delete operation handling
  Future<void> _handleLocalDelete(OfflineOperation operation) async {
    // For delete operations, mark the item as deleted locally or remove it.
    await _cacheManager.delete(operation.endpoint);
  }

  // Handle connectivity changes
  void _onConnectivityChanged(bool isConnected) {
    if (isConnected && _syncQueue.isNotEmpty) {
      _processSyncQueue(); // Attempt to process the queue when connection is restored
    }
  }

  // Load sync queue from cache
  Future<void> _loadSyncQueue() async {
    final queueData = await _cacheManager.get<List<dynamic>>(_queueKey);
    if (queueData != null) {
      for (final json in queueData) {
        try {
          _syncQueue.add(OfflineOperation.fromJson(json as Map<String, dynamic>));
        } catch (e) {
          debugPrint('Failed to load operation from cache: $e');
        }
      }
    }
  }

  // Persist sync queue to cache
  Future<void> _persistSyncQueue() async {
    final queueData = _syncQueue.map((op) => op.toJson()).toList();
    await _cacheManager.put(_queueKey, queueData);
  }

  // Update local cache after successful sync
  Future<void> _updateLocalCacheAfterSync(
    OfflineOperation operation,
    dynamic responseData,
  ) async {
    switch (operation.operationType) {
      case 'create':
        // If the create operation was successful, we might need to update the local cache
        // with the server-generated ID and remove the temporary entry.
        final tempId = 'temp_${operation.id}';
        await _cacheManager.delete(tempId); // Remove temporary entry
        // Store the newly created item with its server ID
        if (responseData != null) {
          await _cacheManager.put(operation.endpoint, responseData);
        }
        break;
      case 'update':
        // If the update was successful, update the cached data.
        if (responseData != null) {
          await _cacheManager.put(operation.endpoint, responseData);
        }
        break;
      case 'delete':
        // If the delete was successful, ensure the item is removed from the cache.
        await _cacheManager.delete(operation.endpoint);
        break;
    }
  }
}
```

### 9.2 è¡çªè§£æ±ºæ©Ÿåˆ¶

#### 9.2.1 è¡çªæª¢æ¸¬å™¨
```dart
// lib/core/sync/conflict_detector.dart
class ConflictDetector {
  static ConflictResult detectConflict(
    Map<String, dynamic> localData,
    Map<String, dynamic> remoteData,
  ) {
    final conflicts = <String, ConflictInfo>[];

    // Check for timestamp conflicts
    final localTimestamp = DateTime.tryParse(localData['updated_at'] ?? '');
    final remoteTimestamp = DateTime.tryParse(remoteData['updated_at'] ?? '');

    if (localTimestamp != null && remoteTimestamp != null) {
      if (localTimestamp.isAfter(remoteTimestamp)) {
        return ConflictResult(
          hasConflict: true,
          conflictType: ConflictType.localNewer,
          localData: localData,
          remoteData: remoteData,
        );
      } else if (remoteTimestamp.isAfter(localTimestamp)) {
        return ConflictResult(
          hasConflict: true,
          conflictType: ConflictType.remoteNewer,
          localData: localData,
          remoteData: remoteData,
        );
      }
    }

    // Check for field-level conflicts
    final allKeys = {...localData.keys, ...remoteData.keys};

    for (final key in allKeys) {
      if (key == 'updated_at' || key == 'created_at') continue; // Skip timestamp fields

      final localValue = localData[key];
      final remoteValue = remoteData[key];

      if (localValue != remoteValue) {
        conflicts.add(ConflictInfo(
          field: key,
          localValue: localValue,
          remoteValue: remoteValue,
        ));
      }
    }

    if (conflicts.isNotEmpty) {
      return ConflictResult(
        hasConflict: true,
        conflictType: ConflictType.fieldLevel,
        conflicts: conflicts,
        localData: localData,
        remoteData: remoteData,
      );
    }

    return ConflictResult(hasConflict: false);
  }
}

class ConflictResult {
  final bool hasConflict;
  final ConflictType? conflictType;
  final List<ConflictInfo>? conflicts;
  final Map<String, dynamic>? localData;
  final Map<String, dynamic>? remoteData;

  ConflictResult({
    required this.hasConflict,
    this.conflictType,
    this.conflicts,
    this.localData,
    this.remoteData,
  });
}

enum ConflictType {
  localNewer,   // Local data is newer
  remoteNewer,  // Remote data is newer
  fieldLevel,   // Field-level conflicts detected
  concurrent,   // Concurrent modification detected (can be a subtype of others)
}

class ConflictInfo {
  final String field;
  final dynamic localValue;
  final dynamic remoteValue;

  ConflictInfo({
    required this.field,
    required this.localValue,
    required this.remoteValue,
  });
}
```

#### 9.2.2 è¡çªè§£æ±ºå™¨
```dart
// lib/core/sync/conflict_resolver.dart
class ConflictResolver {
  // Automatically resolve conflicts
  static Map<String, dynamic> autoResolve(ConflictResult conflict) {
    if (!conflict.hasConflict) {
      return conflict.remoteData ?? {}; // Return remote data if no conflict
    }

    switch (conflict.conflictType) {
      case ConflictType.localNewer:
        return conflict.localData!; // Prioritize local data

      case ConflictType.remoteNewer:
        return conflict.remoteData!; // Prioritize remote data

      case ConflictType.fieldLevel:
        return _mergeFieldLevel(conflict); // Merge field-level conflicts

      case ConflictType.concurrent:
        return _handleConcurrentConflict(conflict); // Handle concurrent modifications

      default:
        return conflict.remoteData!; // Default to remote data
    }
  }

  // Merge field-level conflicts
  static Map<String, dynamic> _mergeFieldLevel(ConflictResult conflict) {
    final merged = <String, dynamic>{...conflict.remoteData!}; // Start with remote data

    // Define fields that should prioritize local data
    final localPriorityFields = ['amount', 'description', 'subject_code'];

    for (final conflictInfo in conflict.conflicts!) {
      if (localPriorityFields.contains(conflictInfo.field)) {
        // If the field is prioritized locally, use the local value
        merged[conflictInfo.field] = conflictInfo.localValue;
      }
      // Other fields not in localPriorityFields will retain their remote values
    }

    return merged;
  }

  // Handle concurrent conflicts
  static Map<String, dynamic> _handleConcurrentConflict(ConflictResult conflict) {
    // For concurrent conflicts, use the "last write wins" strategy based on timestamps
    final localTime = DateTime.tryParse(conflict.localData!['updated_at'] ?? '');
    final remoteTime = DateTime.tryParse(conflict.remoteData!['updated_at'] ?? '');

    if (localTime != null && remoteTime != null) {
      // Return the data with the later timestamp
      return localTime.isAfter(remoteTime)
          ? conflict.localData!
          : conflict.remoteData!;
    }

    // Fallback if timestamps are missing or invalid
    return conflict.remoteData!;
  }

  // Manually resolve conflicts (user-driven)
  static Map<String, dynamic> manualResolve(
    ConflictResult conflict,
    ConflictResolution resolution,
  ) {
    switch (resolution.strategy) {
      case ResolutionStrategy.useLocal:
        return conflict.localData!; // Use the local version

      case ResolutionStrategy.useRemote:
        return conflict.remoteData!; // Use the remote version

      case ResolutionStrategy.merge:
        return _customMerge(conflict, resolution.fieldChoices); // Custom merge logic

      case ResolutionStrategy.cancel:
        throw ConflictCancelledException('User cancelled conflict resolution'); // Throw exception to indicate cancellation
    }
  }

  // Custom merge strategy
  static Map<String, dynamic> _customMerge(
    ConflictResult conflict,
    Map<String, dynamic>? fieldChoices, // Map of field names to boolean (true for local, false for remote)
  ) {
    final merged = <String, dynamic>{...conflict.remoteData!}; // Start with remote data

    if (fieldChoices != null) {
      for (final entry in fieldChoices.entries) {
        final field = entry.key;
        final useLocal = entry.value as bool; // Determine which version to use for the field

        // Apply the user's choice for the field
        if (useLocal && conflict.localData!.containsKey(field)) {
          merged[field] = conflict.localData![field]; // Use local value
        } else if (!useLocal && conflict.remoteData!.containsKey(field)) {
          merged[field] = conflict.remoteData![field]; // Use remote value
        }
      }
    }

    return merged;
  }
}

class ConflictResolution {
  final ResolutionStrategy strategy;
  final Map<String, dynamic>? fieldChoices; // For merge strategy

  ConflictResolution({
    required this.strategy,
    this.fieldChoices,
  });
}

enum ResolutionStrategy {
  useLocal,   // Use the local version
  useRemote,  // Use the remote version
  merge,      // Apply custom merge logic
  cancel,     // Cancel the operation
}

class ConflictCancelledException implements Exception {
  final String message;
  ConflictCancelledException(this.message);
}
```

---

## 13.0 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥ï¼ˆPerformance Optimizationï¼‰

### 10.1 APIè«‹æ±‚å„ªåŒ–

#### 10.1.1 è«‹æ±‚å»é‡èˆ‡æ‰¹é‡è™•ç†
```dart
// lib/core/optimization/request_optimizer.dart
import 'dart:async';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart'; // For debugPrint

class RequestOptimizer {
  final Map<String, Completer<Response>> _pendingRequests = {};
  final Map<String, Timer> _debounceTimers = {};

  static const Duration _debounceDelay = Duration(milliseconds: 300);
  static const int _batchSize = 10; // Number of requests to batch together

  // Deduplicate identical requests that are pending
  Future<Response> deduplicate(RequestOptions options, Future<Response> Function() request) async {
    final key = _generateRequestKey(options); // Create a unique key for the request

    if (_pendingRequests.containsKey(key)) {
      // If a request with the same key is already pending, return its future
      return _pendingRequests[key]!.future;
    }

    // Create a new Completer for this request
    final completer = Completer<Response>();
    _pendingRequests[key] = completer; // Store the completer

    try {
      final response = await request(); // Execute the actual request
      completer.complete(response); // Complete the future with the response
      return response;
    } catch (error) {
      completer.completeError(error); // Complete with error if request fails
      rethrow; // Rethrow the error
    } finally {
      _pendingRequests.remove(key); // Remove the completer once done
    }
  }

  // Debounce requests to avoid rapid firing of the same action
  Future<Response> debounce(
    String key, // Unique key for the debounced action
    RequestOptions options,
    Future<Response> Function() request,
  ) async {
    final completer = Completer<Response>();

    // Cancel any previous timer for this key
    _debounceTimers[key]?.cancel();

    // Start a new timer
    _debounceTimers[key] = Timer(_debounceDelay, () async {
      try {
        final response = await request(); // Execute the request after the delay
        completer.complete(response);
      } catch (error) {
        completer.completeError(error); // Complete with error if request fails
      } finally {
        _debounceTimers.remove(key); // Remove the timer once executed
      }
    });

    return completer.future; // Return the future that will be completed by the timer
  }

  // Batch multiple requests into a single API call if the API supports it,
  // or send them in parallel chunks.
  Future<List<Response>> batchRequests(
    List<RequestOptions> requestsList,
    Future<Response> Function(RequestOptions) requestFunction, // Function to perform a single request
  ) async {
    final responses = <Response>[];

    // Process requests in batches
    for (int i = 0; i < requestsList.length; i += _batchSize) {
      final batch = requestsList.skip(i).take(_batchSize); // Get the current batch
      final futures = batch.map(requestFunction); // Map each request option to its future execution

      // Wait for all requests in the current batch to complete
      final batchResponses = await Future.wait(futures);
      responses.addAll(batchResponses); // Add responses to the overall list

      // Add a small delay between batches to avoid overwhelming the server
      if (i + _batchSize < requestsList.length) {
        await Future.delayed(const Duration(milliseconds: 100));
      }
    }

    return responses;
  }

  // Generate a unique key for a request based on method, URI, and data hash
  String _generateRequestKey(RequestOptions options) {
    final uri = options.uri.toString();
    final method = options.method;
    // Using hashCode of data can be unreliable for complex objects, consider a more robust hashing if needed
    final dataHash = options.data?.hashCode ?? 0;

    return '$method:$uri:$dataHash';
  }
}
```

#### 10.1.2 ä½µç™¼æ§åˆ¶èˆ‡é™æµ
```dart
// lib/core/optimization/concurrency_manager.dart
import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart'; // For debugPrint

class ConcurrencyManager {
  final int _maxConcurrent; // Maximum number of concurrent requests allowed
  final Queue<_RequestTask> _waitingQueue = Queue(); // Queue for tasks waiting to be executed
  int _currentConcurrent = 0; // Counter for currently executing requests

  ConcurrencyManager({int maxConcurrent = 5}) : _maxConcurrent = maxConcurrent;

  // Execute a task, managing concurrency
  Future<T> execute<T>(Future<T> Function() task) async {
    final completer = Completer<T>(); // Completer to signal task completion
    final requestTask = _RequestTask(task, completer); // Create a task wrapper

    if (_currentConcurrent < _maxConcurrent) {
      // If below the concurrency limit, execute the task immediately
      _executeTask(requestTask);
    } else {
      // Otherwise, add the task to the waiting queue
      _waitingQueue.add(requestTask);
    }

    return completer.future; // Return the future for the task's result
  }

  // Execute a single task and manage concurrency counts
  void _executeTask<T>(_RequestTask<T> task) async {
    _currentConcurrent++; // Increment concurrent request counter

    try {
      final result = await task.task(); // Execute the actual task
      task.completer.complete(result); // Complete the task's future with the result
    } catch (error) {
      task.completer.completeError(error); // Complete with error if task fails
    } finally {
      _currentConcurrent--; // Decrement concurrent request counter
      _processWaitingQueue(); // Check if there are tasks waiting in the queue
    }
  }

  // Process the waiting queue if concurrency limit allows
  void _processWaitingQueue() {
    if (_waitingQueue.isNotEmpty && _currentConcurrent < _maxConcurrent) {
      // If there are waiting tasks and we are below the concurrency limit
      final nextTask = _waitingQueue.removeFirst(); // Get the next task from the queue
      _executeTask(nextTask); // Execute it
    }
  }
}

// Helper class to wrap the task and its completer
class _RequestTask<T> {
  final Future<T> Function() task;
  final Completer<T> completer;

  _RequestTask(this.task, this.completer);
}
```

### 10.2 è³‡æ–™è¼‰å…¥å„ªåŒ–

#### 10.2.1 é è¼‰å…¥ç­–ç•¥
```dart
// lib/core/optimization/preloader.dart
import 'dart:async';
import 'package:flutter/foundation.dart'; // For debugPrint
import '../cache/cache_manager.dart';
import '../../data/datasources/remote/auth_remote_datasource.dart';
import '../../data/datasources/remote/project_ledger_remote_datasource.dart';
import '../../data/datasources/remote/entry_remote_datasource.dart';
import '../../data/models/project_model.dart';
import '../../data/models/user_model.dart';
import '../../domain/entities/entry.dart';
import '../../domain/entities/project.dart';
import '../../domain/entities/user.dart';
import '../../data/models/params/entry_params.dart';
import '../../data/models/entry_model.dart';
import '../../data/models/pagination_model.dart'; // Assuming this exists
import '../../domain/usecases/entry/get_entries.dart'; // Assuming GetEntries exists
import '../../core/di/service_locator.dart'; // Assuming service locator is set up


class DataPreloader {
  final Map<String, Future<dynamic>> _preloadTasks = {};
  final CacheManager _cacheManager;

  DataPreloader(this._cacheManager);

  // Preload data based on user activity or anticipated needs
  Future<void> preloadBasedOnUsage(String userId) async {
    // Preload user data
    await _preloadUserData(userId);

    // Preload recently used ledgers
    await _preloadRecentLedgers(userId);

    // Preload frequent subjects
    await _preloadFrequentSubjects(userId);

    // Preload current month's entries
    await _preloadCurrentMonthEntries(userId);
  }

  // Preload user data
  Future<void> _preloadUserData(String userId) async {
    const key = 'preload_user_data';
    if (_preloadTasks.containsKey(key)) return; // Avoid preloading if already in progress

    _preloadTasks[key] = _executePreload(() async {
      // Assume AuthService is registered in the service locator
      final userService = sl<AuthService>();
      final User user = await userService.getUserProfile();
      // Cache user profile with a 1-hour expiry
      await _cacheManager.put('user_profile', user, expiry: Duration(hours: 1));
    });
  }

  // Preload recent ledgers
  Future<void> _preloadRecentLedgers(String userId) async {
    const key = 'preload_recent_ledgers';
    if (_preloadTasks.containsKey(key)) return;

    _preloadTasks[key] = _executePreload(() async {
      // Assume ProjectLedgerService is registered
      final projectService = sl<ProjectLedgerService>();
      final List<ProjectModel> projects = await projectService.getProjects();
      // Cache projects with a 30-minute expiry
      await _cacheManager.put('recent_projects', projects, expiry: Duration(minutes: 30));
    });
  }

  // Preload frequent subjects
  Future<void> _preloadFrequentSubjects(String userId) async {
    const key = 'preload_frequent_subjects';
    if (_preloadTasks.containsKey(key)) return;

    _preloadTasks[key] = _executePreload(() async {
      // Assume EntryService has a method to get frequent subjects (this might need an API endpoint)
      // final subjects = await sl<EntryService>().getFrequentSubjects();
      // await _cacheManager.put('frequent_subjects', subjects, expiry: Duration(days: 1));
      // Placeholder: Replace with actual implementation if available
    });
  }

  // Preload current month's entries
  Future<void> _preloadCurrentMonthEntries(String userId) async {
    const key = 'preload_current_month';
    if (_preloadTasks.containsKey(key)) return;

    _preloadTasks[key] = _executePreload(() async {
      final now = DateTime.now();
      final startOfMonth = DateTime(now.year, now.month, 1);
      final endOfMonth = DateTime(now.year, now.month + 1, 0); // Day before the next month starts

      // Construct query parameters for entries within the current month
      final params = EntryQueryParams(
        filters: EntryFiltersModel(
          dateRange: DateRangeModel(
            startDate: startOfMonth,
            endDate: endOfMonth,
          ),
        ),
        pagination: PaginationParamsModel(page: 1, limit: 50), // Fetch first 50 entries
      );

      // Assume GetEntries use case and EntryService are registered
      final result = await sl<GetEntries>().call(params);
      result.fold(
        (failure) {
          debugPrint('Failed to preload current month entries: ${failure.message}');
        },
        (entries) async {
          // Cache the entries with a 2-hour expiry
          await _cacheManager.put('current_month_entries', entries, expiry: Duration(hours: 2));
        },
      );
    });
  }

  // Helper to execute a preload task and handle errors gracefully
  Future<void> _executePreload(Future<void> Function() preloadFunction) async {
    try {
      await preloadFunction();
    } catch (e) {
      // Preloading failures should not block the main application flow
      debugPrint('Preload task failed: $e');
    }
  }

  // Clear all pending preload tasks
  void clearPreloadTasks() {
    _preloadTasks.clear();
  }
}

// Dummy classes for compilation, replace with actual definitions
class AuthService {}
class ProjectLedgerService {}
class EntryService {}
class GetEntries {} // Assuming this is a UseCase
class EntryFiltersModel {
  final DateRangeModel? dateRange;
  EntryFiltersModel({this.dateRange});
}
class DateRangeModel {
  final DateTime startDate;
  final DateTime endDate;
  DateRangeModel({required this.startDate, required this.endDate});
}
class PaginationParamsModel {
  final int page;
  final int limit;
  PaginationParamsModel({required this.page, required this.limit});
}
class PaginatedEntries {} // Assuming this is a data model
```

#### 10.2.2 åˆ†é èˆ‡è™›æ“¬æ»¾å‹•å„ªåŒ–
```dart
// lib/core/optimization/pagination_manager.dart
import 'dart:async';
import 'package:flutter/foundation.dart'; // For debugPrint

// Generic class to manage pagination for lists
class PaginationManager<T> {
  // Function to load data for a specific page and limit
  final Future<PaginatedResult<T>> Function(int page, int limit) _loadFunction;
  final int _pageSize; // Number of items per page

  final List<T?> _items = []; // List to hold items, allows null for placeholders
  final Set<int> _loadedPages = {}; // Set to track which pages have been loaded
  bool _hasMore = true; // Flag indicating if there are more pages
  bool _isLoading = false; // Flag indicating if a load operation is in progress

  PaginationManager({
    required Future<PaginatedResult<T>> Function(int page, int limit) loadFunction,
    int pageSize = 20, // Default page size
  }) : _loadFunction = loadFunction,
       _pageSize = pageSize;

  // Getters for the current state
  List<T?> get items => _items;
  bool get hasMore => _hasMore;
  bool get isLoading => _isLoading;

  // Load data for a specific page
  Future<void> loadPage(int page) async {
    // Prevent loading if page already loaded or if currently loading
    if (_loadedPages.contains(page) || _isLoading) return;

    _isLoading = true; // Set loading state

    try {
      final result = await _loadFunction(page, _pageSize); // Call the data loading function

      // Insert the loaded items into the _items list at the correct index
      final startIndex = (page - 1) * _pageSize;
      _insertItemsAtIndex(startIndex, result.items);

      _loadedPages.add(page); // Mark the page as loaded
      _hasMore = result.hasMore; // Update the hasMore flag

    } catch (e) {
      // Log any errors during page loading
      debugPrint('Failed to load page $page: $e');
    } finally {
      _isLoading = false; // Reset loading state
    }
  }

  // Load the next available page
  Future<void> loadMore() async {
    // Only proceed if there are more items and not currently loading
    if (!_hasMore || _isLoading) return;

    // Determine the next page number to load
    final nextPage = (_loadedPages.isEmpty) ? 1 : _loadedPages.length + 1;
    await loadPage(nextPage);
  }

  // Refresh the data by clearing current items and reloading the first page
  Future<void> refresh() async {
    _items.clear(); // Clear existing items
    _loadedPages.clear(); // Clear loaded page tracking
    _hasMore = true; // Reset hasMore flag

    await loadPage(1); // Load the first page
  }

  // Preload adjacent pages to improve scrolling experience
  Future<void> preloadAdjacent(int currentIndex) async {
    // Calculate the current page based on the item index
    final currentPage = (currentIndex / _pageSize).ceil();

    // Identify adjacent pages to preload (previous and next)
    final pagesToPreload = [currentPage - 1, currentPage + 1]
        .where((page) => page > 0 && !_loadedPages.contains(page)); // Ensure pages are valid and not already loaded

    // Initiate loading for adjacent pages (run in background)
    for (final page in pagesToPreload) {
      // Only preload if there might be more data or if the page is within loaded range
      if (_hasMore || page <= _loadedPages.length) {
        loadPage(page); // loadPage handles its own loading state, so this is safe
      }
    }
  }

  // Insert new items into the _items list at a specific index
  void _insertItemsAtIndex(int startIndex, List<T> newItems) {
    // Ensure the list is large enough to accommodate the startIndex
    while (_items.length < startIndex) {
      _items.add(null as T); // Add null placeholders if needed
    }

    // Insert the new items
    for (int i = 0; i < newItems.length; i++) {
      final index = startIndex + i;
      if (index < _items.length) {
        // If the index is within the current list bounds, replace the item
        _items[index] = newItems[i];
      } else {
        // Otherwise, add the new item to the end of the list
        _items.add(newItems[i]);
      }
    }
  }
}

// Model for paginated results returned by the load function
class PaginatedResult<T> {
  final List<T> items; // List of items for the current page
  final bool hasMore; // Flag indicating if there are more pages
  final int currentPage; // The current page number
  final int totalPages; // Total number of pages

  PaginatedResult({
    required this.items,
    required this.hasMore,
    required this.currentPage,
    required this.totalPages,
  });
}
```

---

## 14.0 æ¸¬è©¦ç­–ç•¥ï¼ˆTesting Strategyï¼‰

### 11.1 å–®å…ƒæ¸¬è©¦

#### 11.1.1 APIæœå‹™æ¸¬è©¦
```dart
// test/data/datasources/remote/auth_remote_datasource_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:dio/dio.dart';

// Assuming the following are defined and available:
// - AuthRemoteDataSourceImpl
// - ApiClient
// - ApiEndpoints
// - RegisterUserParams
// - UserModel
// - ServerException

// Mock ApiClient
class MockApiClient extends Mock implements ApiClient {}

// Mock RegisterUserParams (if needed)
class MockRegisterUserParams extends Mock implements RegisterUserParams {}

// Mock UserModel (if needed)
class MockUserModel extends Mock implements UserModel {}

void main() {
  late AuthRemoteDataSourceImpl dataSource;
  late MockApiClient mockApiClient;

  setUp(() {
    mockApiClient = MockApiClient();
    dataSource = AuthRemoteDataSourceImpl(apiClient: mockApiClient);
  });

  group('AuthRemoteDataSource', () {
    group('registerUser', () {
      // Define test data
      final tRegisterParams = RegisterUserParams(
        platform: 'mobile_app',
        displayName: 'Test User',
        timezone: 'Asia/Taipei',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(deviceType: 'ios', appVersion: '1.0.0'),
      );

      final tUserModelJson = {
        'uid': 'test_uid',
        'displayName': 'Test User',
        'email': 'test@example.com',
        'userType': 'S',
        'createdAt': '2025-01-24T10:00:00Z',
        'lastLogin': '2025-01-24T10:00:00Z',
      };

      test('should perform POST request to correct endpoint with params', () async {
        // Arrange: Mock the API client's post method
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenAnswer((_) async => Response(
                  requestOptions: RequestOptions(path: ''),
                  data: tUserModelJson,
                  statusCode: 200,
                ));

        // Act: Call the method under test
        await dataSource.registerUser(tRegisterParams);

        // Assert: Verify that the post method was called correctly
        verify(mockApiClient.post(
          ApiEndpoints.registerUser,
          data: tRegisterParams.toJson(),
        )).called(1);
      });

      test('should return UserModel when API call is successful', () async {
        // Arrange: Mock the API client's post method to return a successful response
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenAnswer((_) async => Response(
                  requestOptions: RequestOptions(path: ''),
                  data: tUserModelJson,
                  statusCode: 200,
                ));

        // Act: Call the method under test
        final result = await dataSource.registerUser(tRegisterParams);

        // Assert: Check if the returned UserModel matches the expected data
        expect(result, isA<UserModel>());
        expect(result.uid, 'test_uid');
        expect(result.displayName, 'Test User');
        expect(result.email, 'test@example.com');
      });

      test('should throw ServerException if API call fails with non-200 status', () async {
        // Arrange: Mock the API client's post method to return an error response
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenThrow(DioException(
              requestOptions: RequestOptions(path: ''),
              response: Response(
                requestOptions: RequestOptions(path: ''),
                statusCode: 500, // Simulate a server error
                data: {'message': 'Internal Server Error'},
              ),
            ));

        // Act & Assert: Expect the method to throw a ServerException
        expect(
          () => dataSource.registerUser(tRegisterParams),
          throwsA(isA<ServerException>()),
        );
      });
    });

    // Add more tests for other methods (loginUser, getUserProfile, etc.)
  });
}

// Dummy definitions needed for compilation
class RegisterUserParams {
  final String platform;
  final String? lineUid;
  final DeviceInfoModel deviceInfo;
  final String displayName;
  final String timezone;
  final String authProvider;
  RegisterUserParams({required this.platform, this.lineUid, required this.deviceInfo, required this.displayName, required this.timezone, required this.authProvider});
  Map<String, dynamic> toJson() => {};
}
class DeviceInfoModel {
  final String deviceType;
  final String appVersion;
  DeviceInfoModel({required this.deviceType, required this.appVersion});
}
class UserModel extends User {
  final String uid;
  final String displayName;
  final String email;
  final String userType;
  final DateTime createdAt;
  final DateTime lastLogin;
  UserModel({required this.uid, required this.displayName, required this.email, required this.userType, required this.createdAt, required this.lastLogin});
  factory UserModel.fromJson(Map<String, dynamic> json) => UserModel(uid: json['uid'], displayName: json['displayName'], email: json['email'], userType: json['userType'], createdAt: DateTime.parse(json['createdAt']), lastLogin: DateTime.parse(json['lastLogin']));
  Map<String, dynamic> toJson() => {};
}
class User {}
class ServerException implements Exception {
  final String message;
  const ServerException({this.message = ''});
}
class ApiClient {
  Future<Response> post(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async => throw UnimplementedError();
}
class ApiEndpoints {
  static const String registerUser = '/auth/register';
}
```

#### 11.1.2 Repositoryæ¸¬è©¦
```dart
// test/data/repositories/auth_repository_impl_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:dartz/dartz.dart'; // For Either

// Assuming the following are defined and available:
// - AuthRepositoryImpl
// - AuthRemoteDataSource
// - AuthLocalDataSource
// - NetworkInfo
// - RegisterUserParams
// - User
// - ServerException
// - NetworkFailure
// - ServerFailure

// Mock data sources and network info
class MockAuthRemoteDataSource extends Mock implements AuthRemoteDataSource {}
class MockAuthLocalDataSource extends Mock implements AuthLocalDataSource {}
class MockNetworkInfo extends Mock implements NetworkInfo {}

// Mock RegisterUserParams (if needed)
class MockRegisterUserParams extends Mock implements RegisterUserParams {}

// Mock User (if needed)
class MockUser extends Mock implements User {}

void main() {
  late AuthRepositoryImpl repository;
  late MockAuthRemoteDataSource mockRemoteDataSource;
  late MockAuthLocalDataSource mockLocalDataSource;
  late MockNetworkInfo mockNetworkInfo;

  setUp(() {
    mockRemoteDataSource = MockAuthRemoteDataSource();
    mockLocalDataSource = MockAuthLocalDataSource();
    mockNetworkInfo = MockNetworkInfo();
    repository = AuthRepositoryImpl(
      remoteDataSource: mockRemoteDataSource,
      localDataSource: mockLocalDataSource,
      networkInfo: mockNetworkInfo,
    );
  });

  group('AuthRepository', () {
    group('registerUser', () {
      // Define test data
      final tRegisterParams = RegisterUserParams(
        platform: 'mobile_app',
        displayName: 'Test User',
        timezone: 'Asia/Taipei',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(deviceType: 'ios', appVersion: '1.0.0'),
      );

      final tUser = MockUser(); // Use a mock User object

      test('should return User when device is online and remote call is successful', () async {
        // Arrange: Mock network status and remote data source behavior
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);
        when(mockRemoteDataSource.registerUser(any)).thenAnswer((_) async => tUser);
        // Mock local data source caching behavior
        when(mockLocalDataSource.cacheUser(any)).thenAnswer((_) async => {});

        // Act: Call the repository method
        final result = await repository.registerUser(tRegisterParams);

        // Assert: Verify interactions and check the returned result
        verify(mockRemoteDataSource.registerUser(tRegisterParams)).called(1);
        verify(mockLocalDataSource.cacheUser(tUser)).called(1);
        // Expect a Right containing the User object
        expect(result, equals(Right(tUser)));
      });

      test('should return NetworkFailure when device is offline', () async {
        // Arrange: Mock network status to be offline
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => false);

        // Act: Call the repository method
        final result = await repository.registerUser(tRegisterParams);

        // Assert: Verify that no remote or local data source methods were called
        verifyZeroInteractions(mockRemoteDataSource);
        verifyZeroInteractions(mockLocalDataSource);
        // Expect a Left containing a NetworkFailure
        expect(result, equals(const Left(NetworkFailure('ç¶²è·¯é€£ç·šç•°å¸¸'))));
      });

      test('should return ServerFailure when remote call throws ServerException', () async {
        // Arrange: Mock network status and remote data source to throw an exception
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);
        when(mockRemoteDataSource.registerUser(any)).thenThrow(const ServerException(message: 'ä¼ºæœå™¨éŒ¯èª¤'));

        // Act: Call the repository method
        final result = await repository.registerUser(tRegisterParams);

        // Assert: Verify remote data source interaction and check the returned failure
        verify(mockRemoteDataSource.registerUser(tRegisterParams)).called(1);
        // Expect a Left containing a ServerFailure
        expect(result, equals(const Left(ServerFailure('ä¼ºæœå™¨éŒ¯èª¤'))));
      });

      // Add more tests for CacheException, etc.
    });

    // Add tests for other repository methods (loginUser, getUserProfile, etc.)
  });
}

// Dummy definitions needed for compilation
abstract class AuthRemoteDataSource {
  Future<User> registerUser(RegisterUserParams params);
}
abstract class AuthLocalDataSource {
  Future<void> cacheUser(User user);
}
abstract class NetworkInfo {
  Future<bool> get isConnected;
}
class RegisterUserParams {
  final String platform;
  final String? lineUid;
  final DeviceInfoModel deviceInfo;
  final String displayName;
  final String timezone;
  final String authProvider;
  RegisterUserParams({required this.platform, this.lineUid, required this.deviceInfo, required this.displayName, required this.timezone, required this.authProvider});
  Map<String, dynamic> toJson() => {};
}
class DeviceInfoModel {
  final String deviceType;
  final String appVersion;
  DeviceInfoModel({required this.deviceType, required this.appVersion});
}
class User {}
class ServerException implements Exception {
  final String message;
  const ServerException({this.message = ''});
}
class NetworkFailure extends Failure {
  const NetworkFailure(String message, {String? code, dynamic details}) : super(message: message, code: code, details: details);
}
class ServerFailure extends Failure {
  const ServerFailure(String message, {String? code, dynamic details}) : super(message: message, code: code, details: details);
}
class Failure extends Equatable {
  final String message;
  final String? code;
  final dynamic details;
  const Failure({required this.message, this.code, this.details});
  @override List<Object?> get props => [message, code, details];
  @override bool operator==(Object other) => identical(this, other) || other is Failure && runtimeType == other.runtimeType && message == other.message && code == other.code && details == other.details;
  @override int get hashCode => message.hashCode;
}
class Either<L, R> {}
class Right<L, R> extends Either<L, R> {
  final R value;
  const Right(this.value);
  @override bool operator==(Object other) => identical(this, other) || other is Right && runtimeType == other.runtimeType && value == other.value;
  @override int get hashCode => value.hashCode;
}
class Left<L, R> extends Either<L, R> {
  final L value;
  const Left(this.value);
  @override bool operator==(Object other) => identical(this, other) || other is Left && runtimeType == other.runtimeType && value == other.value;
  @override int get hashCode => value.hashCode;
}
```

### 11.2 æ•´åˆæ¸¬è©¦

#### 11.2.1 APIæ•´åˆæ¸¬è©¦
```dart
// test/integration/api_integration_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:dio/dio.dart';

// Assuming the following are defined and available:
// - ApiClient
// - AuthRemoteDataSourceImpl
// - EntryRemoteDataSourceImpl
// - ApiEndpoints
// - RegisterUserParams
// - LoginUserParams
// - CreateEntryParams
// - EntryQueryParams
// - UpdateEntryParams
// - DeviceInfoModel
// - UserModel
// - LoginResponseModel
// - EntryModel
// - PaginatedEntriesModel

void main() {
  late ApiClient apiClient;
  late AuthRemoteDataSourceImpl authDataSource;
  // Add other data sources as needed
  late EntryRemoteDataSourceImpl entryDataSource;

  setUpAll(() {
    // Configure ApiClient for integration tests (e.g., use a test server URL)
    apiClient = ApiClient(); // Assuming ApiClient can be configured or defaults to test env
    authDataSource = AuthRemoteDataSourceImpl(apiClient: apiClient);
    entryDataSource = EntryRemoteDataSourceImpl(apiClient: apiClient); // Initialize other data sources
  });

  group('API Integration Tests', () {
    group('Authentication Flow', () {
      // Define test login parameters
      final testLoginParams = LoginUserParams(
        platform: 'mobile_app',
        email: 'testuser@example.com', // Use a test email
        password: 'test_password',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(deviceType: 'ios', appVersion: '1.0.0'),
      );

      test('complete authentication flow should work', () async {
        // 1. Register a new user (if registration is part of the test setup)
        //    This might require a separate setup or mocking if registration is complex.
        //    For simplicity, assuming a user already exists or is mocked.

        // 2. Log in the user
        final loginResponse = await authDataSource.loginUser(testLoginParams);
        expect(loginResponse.success, isTrue);
        expect(loginResponse.accessToken, isNotEmpty);

        // Set the obtained token for subsequent requests
        apiClient.setAuthToken(loginResponse.accessToken);

        // 3. Get user profile using the token
        final userProfile = await authDataSource.getUserProfile();
        expect(userProfile.uid, isNotEmpty);
        expect(userProfile.email, testLoginParams.email);

        // 4. Log out the user
        await authDataSource.logoutUser();

        // Optional: Verify logout by trying to get profile again (should fail or return unauthorized)
        try {
          await authDataSource.getUserProfile();
          fail('Should not be able to get profile after logout');
        } catch (e) {
          // Expect an error, e.g., Unauthorized
          expect(e, isA<DioException>());
          expect((e as DioException).response?.statusCode, 401);
        }
      });
    });

    group('Entry Management Flow', () {
      late String authToken; // To store the auth token for entry operations

      setUp(() async {
        // Log in to get an auth token before entry operations
        final loginResponse = await authDataSource.loginUser(testLoginParams);
        authToken = loginResponse.accessToken;
        apiClient.setAuthToken(authToken); // Set token for the ApiClient
      });

      test('complete entry CRUD flow should work', () async {
        // 1. Create an entry
        final createParams = CreateEntryParams(
          entryType: 'expense',
          amount: 100.0,
          subjectCode: '2003',
          subjectName: 'é¤é£²è²»',
          ledgerId: 'default', // Assuming a default ledger ID
          entryDate: DateTime.now(),
          description: 'åˆé¤',
        );

        final createdEntry = await entryDataSource.createEntry(createParams);
        expect(createdEntry.amount, 100.0);
        expect(createdEntry.description, 'åˆé¤');
        expect(createdEntry.entryId, isNotEmpty); // Expect an ID to be generated

        // 2. Query entries (e.g., get all expenses)
        final queryParams = EntryQueryParams(
          filters: EntryFiltersModel(entryTypes: ['expense']),
          pagination: PaginationParamsModel(page: 1, limit: 10),
        );

        final paginatedEntries = await entryDataSource.queryEntries(queryParams);
        expect(paginatedEntries.entries, isNotEmpty); // Expect at least one entry

        // Find the created entry in the list
        final foundEntry = paginatedEntries.entries.firstWhere(
          (entry) => entry.entryId == createdEntry.entryId,
          orElse: () => throw Exception('Created entry not found in query results'),
        );
        expect(foundEntry.amount, 100.0);
        expect(foundEntry.description, 'åˆé¤');

        // 3. Update the entry
        final updateParams = UpdateEntryParams(
          amount: 120.0,
          description: 'åˆé¤ - å·²æ›´æ–°',
        );

        final updatedEntry = await entryDataSource.updateEntry(
          createdEntry.entryId,
          updateParams,
        );
        expect(updatedEntry.amount, 120.0);
        expect(updatedEntry.description, 'åˆé¤ - å·²æ›´æ–°');

        // 4. Delete the entry
        await entryDataSource.deleteEntry(createdEntry.entryId);

        // 5. Verify deletion by querying again and checking if it's gone
        final queryAfterDelete = await entryDataSource.queryEntries(queryParams);
        final isDeleted = queryAfterDelete.entries.any(
          (entry) => entry.entryId == createdEntry.entryId,
        );
        expect(isDeleted, isFalse);
      });
    });

    // Add integration tests for other flows (projects, budgets, etc.)
  });
}

// Dummy definitions for compilation
class ApiClient {
  Future<Response> post(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async => throw UnimplementedError();
  Future<Response> get(String path, {Map<String, dynamic>? queryParameters}) async => throw UnimplementedError();
  Future<Response> put(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async => throw UnimplementedError();
  Future<Response> delete(String path, {dynamic data, Map<String, dynamic>? queryParameters}) async => throw UnimplementedError();
  void setAuthToken(String token) {}
}
class AuthRemoteDataSourceImpl {
  final ApiClient apiClient;
  AuthRemoteDataSourceImpl({required this.apiClient});
  Future<LoginResponseModel> loginUser(LoginUserParams params) async => throw UnimplementedError();
  Future<UserModel> getUserProfile() async => throw UnimplementedError();
  Future<void> logoutUser() async => throw UnimplementedError();
}
class EntryRemoteDataSourceImpl {
  final ApiClient apiClient;
  EntryRemoteDataSourceImpl({required this.apiClient});
  Future<EntryModel> createEntry(CreateEntryParams params) async => throw UnimplementedError();
  Future<PaginatedEntriesModel> queryEntries(EntryQueryParams params) async => throw UnimplementedError();
  Future<EntryModel> updateEntry(String id, UpdateEntryParams params) async => throw UnimplementedError();
  Future<void> deleteEntry(String id) async => throw UnimplementedError();
}
class ApiEndpoints {
  static const String registerUser = '/auth/register';
  static const String loginUser = '/auth/login';
  static const String getUserProfile = '/auth/user';
  static const String createEntry = '/entries';
  static const String queryEntries = '/entries';
  static const String updateEntry = '/entries/{id}';
  static const String deleteEntry = '/entries/{id}';
}
class LoginUserParams {
  final String platform;
  final String? lineUid;
  final DeviceInfoModel deviceInfo;
  final String? email;
  final String? password;
  final String authProvider;
  LoginUserParams({required this.platform, this.lineUid, required this.deviceInfo, this.email, this.password, required this.authProvider});
  Map<String, dynamic> toJson() => {};
}
class DeviceInfoModel {
  final String deviceType;
  final String appVersion;
  DeviceInfoModel({required this.deviceType, required this.appVersion});
}
class UserModel extends User {
  final String uid;
  final String email;
  UserModel({required this.uid, required this.email});
}
class User {}
class LoginResponseModel {
  final bool success;
  final String accessToken;
  LoginResponseModel({required this.success, required this.accessToken});
}
class EntryModel extends Entry {
  final String entryId;
  final double amount;
  final String? description;
  EntryModel({required this.entryId, required this.amount, this.description});
}
class Entry {}
class CreateEntryParams {
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;
  CreateEntryParams({required this.entryType, required this.amount, required this.subjectCode, required this.subjectName, required this.ledgerId, required this.entryDate, this.description, this.tags, this.location});
  Map<String, dynamic> toJson() => {};
}
class LocationModel {}
class EntryQueryParams {
  final EntryFiltersModel? filters;
  final PaginationParamsModel? pagination;
  EntryQueryParams({this.filters, this.pagination});
  Map<String, dynamic> toJson() => {};
}
class EntryFiltersModel {
  final List<String>? entryTypes;
  EntryFiltersModel({this.entryTypes});
}
class PaginationParamsModel {
  final int page;
  final int limit;
  PaginationParamsModel({required this.page, required this.limit});
}
class UpdateEntryParams {
  final double? amount;
  final String? description;
  UpdateEntryParams({this.amount, this.description});
  Map<String, dynamic> toJson() => {};
}
class PaginatedEntriesModel {
  final bool success;
  final List<EntryModel> entries;
  PaginatedEntriesModel({required this.success, required this.entries});
}
```

### 11.3 Widgetæ¸¬è©¦

#### 11.3.1 Provider Widgetæ¸¬è©¦
```dart
// test/presentation/providers/entry_provider_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:dartz/dartz.dart'; // For Either

// Assuming the following are defined and available:
// - EntryProvider
// - CreateEntry (UseCase)
// - GetEntries (UseCase)
// - UpdateEntry (UseCase)
// - DeleteEntry (UseCase)
// - Entry
// - CreateEntryParams
// - EntryQueryParams
// - PaginatedEntries
// - PaginationModel
// - ServerFailure
// - ValidationFailure

// Mock UseCases
class MockCreateEntry extends Mock implements CreateEntry {}
class MockGetEntries extends Mock implements GetEntries {}
class MockUpdateEntry extends Mock implements UpdateEntry {}
class MockDeleteEntry extends Mock implements DeleteEntry {}

// Mock data models (if necessary)
class MockEntry extends Mock implements Entry {}

void main() {
  late EntryProvider entryProvider;
  late MockCreateEntry mockCreateEntry;
  late MockGetEntries mockGetEntries;
  late MockUpdateEntry mockUpdateEntry;
  late MockDeleteEntry mockDeleteEntry;

  setUp(() {
    // Initialize mocks
    mockCreateEntry = MockCreateEntry();
    mockGetEntries = MockGetEntries();
    mockUpdateEntry = MockUpdateEntry();
    mockDeleteEntry = MockDeleteEntry();

    // Instantiate the provider with mocked dependencies
    entryProvider = EntryProvider(
      createEntry: mockCreateEntry,
      getEntries: mockGetEntries,
      updateEntry: mockUpdateEntry,
      deleteEntry: mockDeleteEntry,
    );
  });

  group('EntryProvider', () {
    // Define sample data for testing
    final tEntry = MockEntry(); // Use a mock entry object
    final tCreateParams = CreateEntryParams(
      entryType: 'expense',
      amount: 100.0,
      subjectCode: '2003',
      subjectName: 'é¤é£²è²»',
      ledgerId: 'default',
      entryDate: DateTime.parse('2025-01-24T10:00:00Z'),
      description: 'æ¸¬è©¦è¨˜éŒ„',
    );

    test('should create entry successfully and add to list', () async {
      // Arrange: Mock the createEntry use case to return a successful result
      when(mockCreateEntry(any)).thenAnswer((_) async => Right(tEntry));

      // Act: Call the createEntry method on the provider
      await entryProvider.createEntry(tCreateParams);

      // Assert: Check the provider's state after creation
      expect(entryProvider.entries, contains(tEntry)); // Entry should be in the list
      expect(entryProvider.isLoading, false); // Loading should be false
      expect(entryProvider.error, null); // Error should be null
      verify(mockCreateEntry(tCreateParams)).called(1); // Verify the use case was called
    });

    test('should handle create entry failure and set error message', () async {
      // Arrange: Mock the createEntry use case to return a failure result
      const tFailure = ServerFailure('å»ºç«‹å¤±æ•—');
      when(mockCreateEntry(any)).thenAnswer((_) async => Left(tFailure));

      // Act: Call the createEntry method
      await entryProvider.createEntry(tCreateParams);

      // Assert: Check the provider's state after failure
      expect(entryProvider.entries, isEmpty); // List should remain empty
      expect(entryProvider.isLoading, false); // Loading should be false
      expect(entryProvider.error, 'å»ºç«‹å¤±æ•—'); // Error message should be set
    });

    test('should set isLoading to true during create entry operation', () async {
      // Arrange: Create a Completer to control the async operation
      final completer = Completer<Either<Failure, Entry>>();
      when(mockCreateEntry(any)).thenAnswer((_) => completer.future);

      // Act: Call createEntry, but don't complete the future yet
      final future = entryProvider.createEntry(tCreateParams);

      // Assert: Check that isLoading is true immediately after calling
      expect(entryProvider.isLoading, true);

      // Complete the operation successfully
      completer.complete(Right(MockEntry()));
      await future; // Wait for the operation to finish

      // Assert: Check that isLoading is false after completion
      expect(entryProvider.isLoading, false);
    });

    // Add tests for getEntries, loadMore, updateEntry, deleteEntry, etc.
  });
}

// Dummy definitions needed for compilation
class CreateEntry implements UseCase<Entry, CreateEntryParams> {
  @override
  Future<Either<Failure, Entry>> call(CreateEntryParams params) => throw UnimplementedError();
}
class GetEntries implements UseCase<PaginatedEntries, EntryQueryParams> {
  @override
  Future<Either<Failure, PaginatedEntries>> call(EntryQueryParams params) => throw UnimplementedError();
}
class UpdateEntry implements UseCase<Entry, UpdateEntryParams> {
  @override
  Future<Either<Failure, Entry>> call(UpdateEntryParams params) => throw UnimplementedError();
}
class DeleteEntry implements UseCase<void, String> {
  @override
  Future<Either<Failure, void>> call(String params) => throw UnimplementedError();
}
class Entry {}
class CreateEntryParams {
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;
  CreateEntryParams({required this.entryType, required this.amount, required this.subjectCode, required this.subjectName, required this.ledgerId, required this.entryDate, this.description, this.tags, this.location});
  Map<String, dynamic> toJson() => {};
}
class LocationModel {}
class EntryQueryParams {
  final EntryFiltersModel? filters;
  final PaginationParamsModel? pagination;
  EntryQueryParams({this.filters, this.pagination});
  Map<String, dynamic> toJson() => {};
}
class EntryFiltersModel {
  final List<String>? entryTypes;
  final DateRangeModel? dateRange;
  EntryFiltersModel({this.entryTypes, this.dateRange});
}
class DateRangeModel {
  final DateTime startDate;
  final DateTime endDate;
  DateRangeModel({required this.startDate, required this.endDate});
}
class PaginationParamsModel {
  final int page;
  final int limit;
  PaginationParamsModel({required this.page, required this.limit});
}
class PaginatedEntries {
  final List<Entry> entries;
  final PaginationModel pagination;
  PaginatedEntries({required this.entries, required this.pagination});
}
class PaginationModel {
  final bool hasNext;
  final int currentPage;
  final int limit;
  PaginationModel({required this.hasNext, required this.currentPage, required this.limit});
}
class UpdateEntryParams {
  final double? amount;
  final String? description;
  UpdateEntryParams({this.amount, this.description});
  Map<String, dynamic> toJson() => {};
}
class Failure extends Equatable {
  final String message;
  const Failure(this.message);
  @override List<Object?> get props => [message];
}
class ServerFailure extends Failure {
  const ServerFailure(String message) : super(message);
}
class ValidationFailure extends Failure {
  const ValidationFailure(String message) : super(message);
}
class Either<L, R> {}
class Right<L, R> extends Either<L, R> {
  final R value;
  const Right(this.value);
}
class Left<L, R> extends Either<L, R> {
  final L value;
  const Left(this.value);
}
abstract class UseCase<Type, Params> {
  Future<Either<Failure, Type>> call(Params params);
}
```

---

## 15.0 ç‰ˆæœ¬å‡ç´šè¨ˆç•«ï¼ˆVersion Upgradeï¼‰

### 15.1 æ¨¡çµ„ç‰ˆæœ¬è¦åŠƒ

| æ¨¡çµ„åç¨± | ç•¶å‰ç‰ˆæœ¬ | ç›®æ¨™ç‰ˆæœ¬ | å‡ç´šå…§å®¹ | ç›¸ä¾æ€§ |
|----------|----------|----------|----------|--------|
| **Flutter_AP_Layer** | v2.0.0 | v2.1.0 | æ¶æ§‹é—œä¿‚æ˜ç¢ºåŒ–ï¼ŒåŠŸèƒ½ç„¡è®Šæ›´ | æ‰€æœ‰ç›¸é—œæ¨¡çµ„ |
| **AuthService** | - | v2.1.0 | F001-F005 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **EntryService** | - | v2.1.0 | F006-F009 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **ProjectLedgerService** | - | v2.1.0 | F010-F015 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **BudgetService** | - | v2.1.0 | F016-F018 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **CollaborationService** | - | v2.1.0 | F019-F021 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **ReportService** | - | v2.1.0 | F022-F024 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **SystemService** | - | v2.1.0 | F025-F032 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |

### 15.2 å‡½æ•¸ç‰ˆæœ¬å‡ç´š

#### 15.2.1 æ ¸å¿ƒAPIå‡½æ•¸ç‰ˆæœ¬
| APIç«¯é» | å‡½æ•¸åç¨± | ç‰ˆæœ¬ | å‡ç´šå…§å®¹ |
|---------|----------|------|----------|
| F001-F005 | AuthServiceå„æ–¹æ³• | v2.1.0 | å®Œæ•´èªè­‰æµç¨‹å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F006-F009 | EntryServiceå„æ–¹æ³• | v2.1.0 | è¨˜å¸³CRUDæ“ä½œå¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F010-F015 | ProjectLedgerServiceå„æ–¹æ³• | v2.1.0 | å¤šå¸³æœ¬ç®¡ç†å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F016-F018 | BudgetServiceå„æ–¹æ³• | v2.1.0 | é ç®—ç®¡ç†å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F019-F021 | CollaborationServiceå„æ–¹æ³• | v2.1.0 | å”ä½œåŠŸèƒ½å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F022-F024 | ReportServiceå„æ–¹æ³• | v2.1.0 | å ±è¡¨åŠŸèƒ½å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F025-F032 | SystemServiceå„æ–¹æ³• | v2.1.0 | ç³»çµ±ç®¡ç†å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |

### 15.3 é–‹ç™¼é‡Œç¨‹ç¢‘

#### 12.3.1 Phase 1: åŸºç¤æ¶æ§‹å»ºç«‹ (Week 1-2)
- âœ… Clean Architectureæ¶æ§‹è¨­è¨ˆ
- âœ… ä¾è³´æ³¨å…¥è¨­å®š
- âœ… çµ±ä¸€APIå®¢æˆ¶ç«¯å¯¦ä½œ
- âœ… éŒ¯èª¤è™•ç†æ©Ÿåˆ¶å»ºç«‹
- âœ… è³‡æ–™æ¨¡å‹å®šç¾©

#### 12.3.2 Phase 2: æ ¸å¿ƒAPIæœå‹™å¯¦ä½œ (Week 3-4)
- ğŸ”„ AuthServiceå¯¦ä½œ (F001-F005)
- ğŸ”„ EntryServiceå¯¦ä½œ (F006-F009)
- ğŸ”„ Repository Patternå¯¦ä½œ
- ğŸ”„ Use Caseså¯¦ä½œ
- ğŸ”„ å–®å…ƒæ¸¬è©¦ç·¨å¯«

#### 12.3.3 Phase 3: é€²éšåŠŸèƒ½å¯¦ä½œ (Week 5-6)
- â³ ProjectLedgerServiceå¯¦ä½œ (F010-F015)
- â³ BudgetServiceå¯¦ä½œ (F016-F018)
- â³ CollaborationServiceå¯¦ä½œ (F019-F021)
- â³ WebSocketå³æ™‚åŒæ­¥å¯¦ä½œ

#### 12.3.4 Phase 4: ç³»çµ±åŠŸèƒ½èˆ‡å„ªåŒ– (Week 7-8)
- â³ ReportServiceå¯¦ä½œ (F022-F024)
- â³ SystemServiceå¯¦ä½œ (F025-F032)
- â³ å¿«å–ç­–ç•¥å¯¦ä½œ
- â³ é›¢ç·šåŒæ­¥æ©Ÿåˆ¶å¯¦ä½œ
- â³ æ•ˆèƒ½å„ªåŒ–å¯¦æ–½

#### 12.3.5 Phase 5: æ¸¬è©¦èˆ‡éƒ¨ç½² (Week 9-10)
- â³ æ•´åˆæ¸¬è©¦åŸ·è¡Œ
- â³ æ•ˆèƒ½æ¸¬è©¦åŸ·è¡Œ
- â³ æ–‡ä»¶å®Œå–„
- â³ éƒ¨ç½²æº–å‚™

### 15.4 å‘å¾Œç›¸å®¹æ€§ä¿è­‰

#### 12.4.1 APIç‰ˆæœ¬ç›¸å®¹æ€§
```dart
// lib/core/api/api_versioning.dart
class ApiVersionManager {
  static const String currentVersion = 'v2.0.0';
  static const List<String> supportedVersions = ['v1.0.0', 'v2.0.0'];

  static String getApiPath(String endpoint, {String? version}) {
    final apiVersion = version ?? currentVersion;
    return '/api/$apiVersion$endpoint';
  }

  static bool isVersionSupported(String version) {
    return supportedVersions.contains(version);
  }

  // Version migration logic
  static Map<String, dynamic> migrateRequest(
    String fromVersion,
    String toVersion,
    Map<String, dynamic> requestData,
  ) {
    if (fromVersion == toVersion) return requestData; // No migration needed

    // Example migration: v1.0.0 -> v2.0.0
    if (fromVersion == 'v1.0.0' && toVersion == 'v2.0.0') {
      return _migrateV1ToV2(requestData);
    }

    // Add other migration logic as needed
    return requestData; // Return original data if no applicable migration found
  }

  // Specific migration logic from v1.0.0 to v2.0.0
  static Map<String, dynamic> _migrateV1ToV2(Map<String, dynamic> data) {
    final migratedData = Map<String, dynamic>.from(data);

    // Example: Rename 'date' field to 'entry_date'
    if (migratedData.containsKey('date')) {
      migratedData['entry_date'] = migratedData.remove('date');
    }

    // Add other data transformations required for migration

    return migratedData;
  }
}
```

---

## æ–‡ä»¶ç¶­è­·è¨˜éŒ„

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹è€… | ä¿®æ”¹å…§å®¹ |
|------|------|--------|----------|
| **v2.0.0** | **2025-01-24** | **LCAS PM Team** | **åˆç‰ˆå»ºç«‹ï¼šå®Œæ•´Flutter AP LayeræŠ€è¡“è¦æ ¼ï¼Œæ•´åˆ32å€‹RESTful APIç«¯é»ï¼Œå¯¦ä½œClean Architectureã€Repository Patternã€å¿«å–ç­–ç•¥ã€é›¢ç·šåŒæ­¥æ©Ÿåˆ¶ã€éŒ¯èª¤è™•ç†ã€æ•ˆèƒ½å„ªåŒ–ç­‰å®Œæ•´AP LayeråŠŸèƒ½** |
| **v2.1.0** | **2025-01-26** | **LCAS SA Team** | **æ¶æ§‹é‡çµ„å„ªåŒ–ï¼šåˆ†é›¢ç³»çµ±ã€æ¨¡çµ„ã€ç¨‹å¼ç¢¼ä¸‰å±¤æ¶æ§‹æè¿°ï¼Œæ–°å¢æ¶æ§‹é—œä¿‚å°æ‡‰ç« ç¯€ï¼Œæ˜ç¢º7å¤§æœå‹™ç¾¤çµ„åœ¨Clean Architectureä¸­çš„ä½ç½®ï¼Œè§£æ±ºæ¶æ§‹å±¤æ¬¡æ··æ·†å•é¡Œ** |

---

## å‚™è¨»

- **ç‰ˆæœ¬2.1.0é‡å¤§æ”¹é€²**: è§£æ±ºæ¶æ§‹å±¤æ¬¡æ··æ·†å•é¡Œï¼Œæ˜ç¢ºç³»çµ±ã€æ¨¡çµ„ã€ç¨‹å¼ç¢¼ä¸‰å±¤æ¶æ§‹é—œä¿‚
- **æ¶æ§‹é—œä¿‚é‡æ¸…**: æ–°å¢ç¬¬5ç« å°ˆé–€èªªæ˜7å¤§æœå‹™ç¾¤çµ„åœ¨Clean Architectureä¸­çš„å…·é«”ä½ç½®
- **å®Œæ•´APIæ•´åˆ**: 32å€‹RESTful APIç«¯é»(F001-F032)å®Œæ•´å°æ‡‰åˆ°ç¨‹å¼ç¢¼å¯¦ä½œ
- **Clean Architecture**: æ¡ç”¨åˆ†å±¤æ¶æ§‹ï¼Œç¢ºä¿ç¨‹å¼ç¢¼å¯ç¶­è­·æ€§å’Œå¯æ¸¬è©¦æ€§
- **Repository Pattern**: å¯¦ä½œè³‡æ–™å­˜å–æŠ½è±¡å±¤ï¼Œæ”¯æ´æœ¬åœ°å¿«å–å’Œé ç«¯API
- **å¿«å–ç­–ç•¥**: å¤šå±¤æ¬¡å¿«å–æ©Ÿåˆ¶ï¼Œæå‡æ‡‰ç”¨æ•ˆèƒ½å’Œä½¿ç”¨è€…é«”é©—
- **é›¢ç·šåŒæ­¥**: å®Œæ•´é›¢ç·šæ“ä½œæ”¯æ´å’Œæ™ºæ…§è¡çªè§£æ±ºæ©Ÿåˆ¶
- **éŒ¯èª¤è™•ç†**: çµ±ä¸€éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼Œæä¾›ä½¿ç”¨è€…å‹å–„çš„éŒ¯èª¤è¨Šæ¯
- **æ•ˆèƒ½å„ªåŒ–**: è«‹æ±‚å»é‡ã€æ‰¹é‡è™•ç†ã€ä½µç™¼æ§åˆ¶ç­‰æ•ˆèƒ½å„ªåŒ–ç­–ç•¥
- **æ¸¬è©¦ç­–ç•¥**: å®Œæ•´çš„å–®å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦å’ŒWidgetæ¸¬è©¦è¨ˆç•«
- **æŠ€è¡“å‚µå‹™**: è«‹åƒè€ƒ91è³‡æ–™å¤¾ä¸­çš„å…·é«”ç¨‹å¼ç¢¼å¯¦ä½œ
- **APIæ–‡ä»¶åƒè€ƒ**: è«‹åƒè€ƒ9205. Flutter_API list_AP layer.mdæ–‡ä»¶
- **UIæ•´åˆ**: é…åˆ9005. Flutter_Presentation layer.mdé€²è¡Œå‰ç«¯æ•´åˆ
- **æ¶æ§‹å•é¡Œè§£æ±º**: å›ç­”ã€Œ7å¤§æœå‹™ç¾¤çµ„åœ¨åˆ†å±¤æ¶æ§‹è¨­è¨ˆçš„å“ªè£¡ï¼Ÿã€â†’ ç­”æ¡ˆåœ¨ç¬¬5.3ç¯€