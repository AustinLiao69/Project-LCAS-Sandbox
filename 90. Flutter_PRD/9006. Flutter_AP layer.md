
# PRD_Flutter_AP Layer

**文件編號**: 9006  
**版本**: 2.0.0  
**建立日期**: 2025-08-01  
**建立者**: LCAS PM Team  
**最後更新**: 2025-08-01 12:00:00 UTC+8

---

## 目次

1. [模組概述](#10-模組概述module-overview)
2. [架構設計](#20-架構設計architecture-design)
3. [API服務層設計](#30-api服務層設計api-services-layer)
4. [32個API端點整合](#40-32個api端點整合api-endpoints-integration)
5. [資料模型定義](#50-資料模型定義data-models)
6. [狀態管理策略](#60-狀態管理策略state-management)
7. [錯誤處理機制](#70-錯誤處理機制error-handling)
8. [快取策略設計](#80-快取策略設計caching-strategy)
9. [離線同步機制](#90-離線同步機制offline-sync)
10. [效能優化策略](#100-效能優化策略performance-optimization)
11. [測試策略](#110-測試策略testing-strategy)
12. [版本升級計畫](#120-版本升級計畫version-upgrade)

---

## 1.0 模組概述（Module Overview）

### 1.1 產品定位
Flutter AP Layer（應用邏輯層）是LCAS 2.0系統的核心中介層，負責連接Presentation Layer與Business Layer，整合32個RESTful API端點，提供統一的資料存取介面和業務邏輯封裝。

### 1.2 核心職責
- **API整合管理**: 封裝32個RESTful API端點，提供類型安全的調用介面
- **資料轉換處理**: 處理API數據與UI數據間的格式轉換
- **狀態管理協調**: 管理應用狀態，確保數據一致性
- **錯誤處理統一**: 提供統一的錯誤處理和用戶友善的錯誤訊息
- **快取策略執行**: 實施智慧快取，提升應用效能
- **離線功能支援**: 支援離線操作和數據同步

### 1.3 技術架構概覽
```
Flutter AP Layer Architecture
├── API Services Layer (7大服務群組)
│   ├── AuthService (F001-F005) → 認證管理
│   ├── EntryService (F006-F009) → 基礎記帳
│   ├── ProjectLedgerService (F010-F015) → 多帳本管理
│   ├── BudgetService (F016-F018) → 預算管理
│   ├── CollaborationService (F019-F021) → 協作功能
│   ├── ReportService (F022-F024) → 報表功能
│   └── SystemService (F025-F032) → 系統管理
├── Data Layer (資料存取層)
│   ├── HTTP Client → API請求處理
│   ├── Local Storage → 本地資料儲存
│   └── Cache Manager → 快取管理
├── State Management (狀態管理層)
│   ├── Provider/Riverpod → 狀態管理
│   ├── Repository Pattern → 資料存取抽象
│   └── Use Cases → 業務邏輯封裝
└── Infrastructure (基礎設施層)
    ├── Network Handler → 網路處理
    ├── Security Handler → 安全處理
    └── Sync Manager → 同步管理
```

---

## 2.0 架構設計（Architecture Design）

### 2.1 Clean Architecture 實施

#### 2.1.1 分層架構設計
```dart
// lib/core/architecture/
lib/
├── core/
│   ├── api/
│   │   ├── api_client.dart → 統一API客戶端
│   │   ├── api_interceptors.dart → 請求攔截器
│   │   └── api_endpoints.dart → API端點定義
│   ├── cache/
│   │   ├── cache_manager.dart → 快取管理器
│   │   └── cache_strategies.dart → 快取策略
│   ├── error/
│   │   ├── app_exceptions.dart → 應用異常定義
│   │   └── error_handler.dart → 錯誤處理器
│   └── network/
│       ├── network_info.dart → 網路狀態檢測
│       └── connectivity_service.dart → 連線服務
├── data/
│   ├── datasources/
│   │   ├── remote/ → 遠端資料源（API）
│   │   └── local/ → 本地資料源（Cache）
│   ├── models/ → 資料模型
│   └── repositories/ → Repository實作
├── domain/
│   ├── entities/ → 業務實體
│   ├── repositories/ → Repository介面
│   └── usecases/ → 使用案例
└── presentation/
    ├── providers/ → 狀態管理
    └── widgets/ → UI元件
```

#### 2.1.2 依賴注入設計
```dart
// lib/core/di/service_locator.dart
import 'package:get_it/get_it.dart';

final GetIt sl = GetIt.instance;

Future<void> init() async {
  // API Services註冊
  sl.registerLazySingleton<ApiClient>(() => ApiClient(sl()));
  sl.registerLazySingleton<AuthService>(() => AuthService(sl()));
  sl.registerLazySingleton<EntryService>(() => EntryService(sl()));
  sl.registerLazySingleton<ProjectLedgerService>(() => ProjectLedgerService(sl()));
  sl.registerLazySingleton<BudgetService>(() => BudgetService(sl()));
  sl.registerLazySingleton<CollaborationService>(() => CollaborationService(sl()));
  sl.registerLazySingleton<ReportService>(() => ReportService(sl()));
  sl.registerLazySingleton<SystemService>(() => SystemService(sl()));
  
  // Repository註冊
  sl.registerLazySingleton<AuthRepository>(() => AuthRepositoryImpl(sl(), sl()));
  sl.registerLazySingleton<EntryRepository>(() => EntryRepositoryImpl(sl(), sl()));
  
  // Use Cases註冊
  sl.registerLazySingleton(() => LoginUser(sl()));
  sl.registerLazySingleton(() => CreateEntry(sl()));
  
  // 基礎設施註冊
  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(sl()));
  sl.registerLazySingleton<CacheManager>(() => CacheManagerImpl());
}
```

### 2.2 Repository Pattern 實作

#### 2.2.1 Repository介面定義
```dart
// lib/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Future<Either<Failure, User>> registerUser(RegisterUserParams params);
  Future<Either<Failure, LoginResponse>> loginUser(LoginUserParams params);
  Future<Either<Failure, User>> getUserProfile();
  Future<Either<Failure, User>> updateUserProfile(UpdateUserParams params);
  Future<Either<Failure, void>> logoutUser();
}
```

#### 2.2.2 Repository實作
```dart
// lib/data/repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;
  final NetworkInfo networkInfo;

  AuthRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
    required this.networkInfo,
  });

  @override
  Future<Either<Failure, User>> registerUser(RegisterUserParams params) async {
    try {
      if (await networkInfo.isConnected) {
        final result = await remoteDataSource.registerUser(params);
        await localDataSource.cacheUser(result);
        return Right(result);
      } else {
        return Left(NetworkFailure('網路連線異常'));
      }
    } on ServerException {
      return Left(ServerFailure('伺服器錯誤'));
    } on CacheException {
      return Left(CacheFailure('本地儲存錯誤'));
    }
  }
}
```

---

## 3.0 API服務層設計（API Services Layer）

### 3.1 統一API客戶端設計

#### 3.1.1 API客戶端核心實作
```dart
// lib/core/api/api_client.dart
class ApiClient {
  static const String baseUrl = 'https://lcas-api.replit.app/api/v1';
  late final Dio _dio;
  
  ApiClient() {
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ));
    
    _setupInterceptors();
  }
  
  void _setupInterceptors() {
    _dio.interceptors.addAll([
      AuthInterceptor(), // JWT Token自動管理
      LoggingInterceptor(), // 請求/回應日誌
      CacheInterceptor(), // 快取處理
      ErrorInterceptor(), // 錯誤處理
    ]);
  }
}
```

#### 3.1.2 JWT Token自動管理
```dart
// lib/core/api/auth_interceptor.dart
class AuthInterceptor extends Interceptor {
  final TokenRepository _tokenRepository;
  
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    final token = _tokenRepository.getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }
  
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode == 401) {
      // Token過期，嘗試刷新
      final refreshed = await _refreshToken();
      if (refreshed) {
        // 重試原始請求
        final response = await _retry(err.requestOptions);
        handler.resolve(response);
        return;
      }
      // 刷新失敗，清除Token並導向登入
      await _tokenRepository.clearTokens();
      NavigationService.pushAndClearStack('/login');
    }
    handler.next(err);
  }
}
```

### 3.2 API端點定義

#### 3.2.1 API端點常數定義
```dart
// lib/core/api/api_endpoints.dart
class ApiEndpoints {
  // 認證管理群組 (F001-F005)
  static const String registerUser = '/auth/register';
  static const String loginUser = '/auth/login';
  static const String getUserProfile = '/auth/user';
  static const String updateUserProfile = '/auth/user';
  static const String logoutUser = '/auth/logout';
  
  // 基礎記帳群組 (F006-F009)
  static const String createEntry = '/entries';
  static const String quickEntry = '/entries/quick';
  static const String getEntries = '/entries';
  static const String updateEntry = '/entries/{id}';
  static const String deleteEntry = '/entries/{id}';
  
  // 多帳本管理群組 (F010-F015)
  static const String createProject = '/projects';
  static const String getProjects = '/projects';
  static const String updateProject = '/projects/{id}';
  static const String deleteProject = '/projects/{id}';
  static const String getProjectMembers = '/projects/{id}/members';
  static const String switchLedger = '/ledgers/switch';
  
  // 預算管理群組 (F016-F018)
  static const String createBudget = '/budgets';
  static const String getBudgetProgress = '/budgets/{id}/progress';
  static const String setBudgetAlerts = '/budgets/{id}/alerts';
  
  // 協作功能群組 (F019-F021)
  static const String createSharedLedger = '/shared/ledgers';
  static const String setMemberPermissions = '/shared/ledgers/{id}/permissions';
  static const String realtimeSync = '/sync/realtime'; // WebSocket
  
  // 報表功能群組 (F022-F024)
  static const String generateReport = '/reports/generate';
  static const String createCustomReport = '/reports/custom';
  static const String exportReport = '/reports/{id}/export';
  
  // 系統管理群組 (F025-F032)
  static const String scheduleBackup = '/system/backup/schedule';
  static const String manualBackup = '/backups/manual';
  static const String listBackups = '/backups';
  static const String checkSyncStatus = '/system/sync/status';
  static const String systemHealth = '/system/health';
  static const String errorLogs = '/system/logs/errors';
  static const String createReminder = '/reminders';
  static const String executeReminder = '/reminders/execute';
}
```

---

## 4.0 32個API端點整合（API Endpoints Integration）

### 4.1 認證管理服務 (F001-F005)

#### 4.1.1 AuthService實作
```dart
// lib/data/datasources/remote/auth_remote_datasource.dart
abstract class AuthRemoteDataSource {
  Future<UserModel> registerUser(RegisterUserParams params);
  Future<LoginResponseModel> loginUser(LoginUserParams params);
  Future<UserModel> getUserProfile();
  Future<UserModel> updateUserProfile(UpdateUserParams params);
  Future<void> logoutUser();
}

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final ApiClient apiClient;
  
  AuthRemoteDataSourceImpl({required this.apiClient});
  
  @override
  Future<UserModel> registerUser(RegisterUserParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.registerUser,
      data: params.toJson(),
    );
    return UserModel.fromJson(response.data);
  }
  
  @override
  Future<LoginResponseModel> loginUser(LoginUserParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.loginUser,
      data: params.toJson(),
    );
    return LoginResponseModel.fromJson(response.data);
  }
  
  @override
  Future<UserModel> getUserProfile() async {
    final response = await apiClient.get(ApiEndpoints.getUserProfile);
    return UserModel.fromJson(response.data);
  }
  
  @override
  Future<UserModel> updateUserProfile(UpdateUserParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateUserProfile,
      data: params.toJson(),
    );
    return UserModel.fromJson(response.data);
  }
  
  @override
  Future<void> logoutUser() async {
    await apiClient.post(ApiEndpoints.logoutUser);
  }
}
```

### 4.2 基礎記帳服務 (F006-F009)

#### 4.2.1 EntryService實作
```dart
// lib/data/datasources/remote/entry_remote_datasource.dart
class EntryRemoteDataSourceImpl implements EntryRemoteDataSource {
  final ApiClient apiClient;
  
  EntryRemoteDataSourceImpl({required this.apiClient});
  
  @override
  Future<EntryModel> createEntry(CreateEntryParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createEntry,
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }
  
  @override
  Future<EntryModel> quickEntry(QuickEntryParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.quickEntry,
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }
  
  @override
  Future<PaginatedEntriesModel> getEntries(EntryQueryParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.getEntries,
      queryParameters: params.toJson(),
    );
    return PaginatedEntriesModel.fromJson(response.data);
  }
  
  @override
  Future<EntryModel> updateEntry(String id, UpdateEntryParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateEntry.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }
  
  @override
  Future<void> deleteEntry(String id) async {
    await apiClient.delete(ApiEndpoints.deleteEntry.replaceAll('{id}', id));
  }
}
```

### 4.3 多帳本管理服務 (F010-F015)

#### 4.3.1 ProjectLedgerService實作
```dart
// lib/data/datasources/remote/project_ledger_remote_datasource.dart
class ProjectLedgerRemoteDataSourceImpl implements ProjectLedgerRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<ProjectModel> createProject(CreateProjectParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createProject,
      data: params.toJson(),
    );
    return ProjectModel.fromJson(response.data);
  }
  
  @override
  Future<List<ProjectModel>> getProjects() async {
    final response = await apiClient.get(ApiEndpoints.getProjects);
    return (response.data['projects'] as List)
        .map((json) => ProjectModel.fromJson(json))
        .toList();
  }
  
  @override
  Future<ProjectModel> updateProject(String id, UpdateProjectParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateProject.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return ProjectModel.fromJson(response.data);
  }
  
  @override
  Future<void> deleteProject(String id) async {
    await apiClient.delete(ApiEndpoints.deleteProject.replaceAll('{id}', id));
  }
  
  @override
  Future<List<MemberModel>> getProjectMembers(String id) async {
    final response = await apiClient.get(
      ApiEndpoints.getProjectMembers.replaceAll('{id}', id)
    );
    return (response.data['members'] as List)
        .map((json) => MemberModel.fromJson(json))
        .toList();
  }
  
  @override
  Future<LedgerSwitchResponseModel> switchLedger(SwitchLedgerParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.switchLedger,
      queryParameters: params.toJson(),
    );
    return LedgerSwitchResponseModel.fromJson(response.data);
  }
}
```

### 4.4 預算管理服務 (F016-F018)

#### 4.4.1 BudgetService實作
```dart
// lib/data/datasources/remote/budget_remote_datasource.dart
class BudgetRemoteDataSourceImpl implements BudgetRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<BudgetModel> createBudget(CreateBudgetParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createBudget,
      data: params.toJson(),
    );
    return BudgetModel.fromJson(response.data);
  }
  
  @override
  Future<BudgetProgressModel> getBudgetProgress(String id) async {
    final response = await apiClient.get(
      ApiEndpoints.getBudgetProgress.replaceAll('{id}', id)
    );
    return BudgetProgressModel.fromJson(response.data);
  }
  
  @override
  Future<BudgetAlertResponseModel> setBudgetAlerts(
    String id, 
    SetBudgetAlertsParams params
  ) async {
    final response = await apiClient.put(
      ApiEndpoints.setBudgetAlerts.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return BudgetAlertResponseModel.fromJson(response.data);
  }
}
```

### 4.5 協作功能服務 (F019-F021)

#### 4.5.1 CollaborationService實作
```dart
// lib/data/datasources/remote/collaboration_remote_datasource.dart
class CollaborationRemoteDataSourceImpl implements CollaborationRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<SharedLedgerModel> createSharedLedger(CreateSharedLedgerParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createSharedLedger,
      data: params.toJson(),
    );
    return SharedLedgerModel.fromJson(response.data);
  }
  
  @override
  Future<PermissionResponseModel> setMemberPermissions(
    String id, 
    SetPermissionsParams params
  ) async {
    final response = await apiClient.put(
      ApiEndpoints.setMemberPermissions.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return PermissionResponseModel.fromJson(response.data);
  }
  
  // WebSocket連線處理
  @override
  Stream<RealtimeSyncEvent> connectRealtimeSync(String ledgerId) {
    final channel = IOWebSocketChannel.connect(
      '${ApiEndpoints.realtimeSync}?ledger_id=$ledgerId'
    );
    
    return channel.stream.map((data) {
      final json = jsonDecode(data);
      return RealtimeSyncEvent.fromJson(json);
    });
  }
}
```

### 4.6 報表功能服務 (F022-F024)

#### 4.6.1 ReportService實作
```dart
// lib/data/datasources/remote/report_remote_datasource.dart
class ReportRemoteDataSourceImpl implements ReportRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<ReportModel> generateReport(GenerateReportParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.generateReport,
      data: params.toJson(),
    );
    return ReportModel.fromJson(response.data);
  }
  
  @override
  Future<CustomReportModel> createCustomReport(CreateCustomReportParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createCustomReport,
      data: params.toJson(),
    );
    return CustomReportModel.fromJson(response.data);
  }
  
  @override
  Future<ExportResponseModel> exportReport(String id, ExportReportParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.exportReport.replaceAll('{id}', id),
      queryParameters: params.toJson(),
    );
    return ExportResponseModel.fromJson(response.data);
  }
}
```

### 4.7 系統管理服務 (F025-F032)

#### 4.7.1 SystemService實作
```dart
// lib/data/datasources/remote/system_remote_datasource.dart
class SystemRemoteDataSourceImpl implements SystemRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<BackupScheduleModel> scheduleBackup(ScheduleBackupParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.scheduleBackup,
      data: params.toJson(),
    );
    return BackupScheduleModel.fromJson(response.data);
  }
  
  @override
  Future<BackupResponseModel> manualBackup(ManualBackupParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.manualBackup,
      data: params.toJson(),
    );
    return BackupResponseModel.fromJson(response.data);
  }
  
  @override
  Future<BackupListModel> listBackups(ListBackupsParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.listBackups,
      queryParameters: params.toJson(),
    );
    return BackupListModel.fromJson(response.data);
  }
  
  @override
  Future<SyncStatusModel> checkSyncStatus(CheckSyncParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.checkSyncStatus,
      queryParameters: params.toJson(),
    );
    return SyncStatusModel.fromJson(response.data);
  }
  
  @override
  Future<SystemHealthModel> getSystemHealth() async {
    final response = await apiClient.get(ApiEndpoints.systemHealth);
    return SystemHealthModel.fromJson(response.data);
  }
  
  @override
  Future<ErrorLogsModel> getErrorLogs(ErrorLogsParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.errorLogs,
      queryParameters: params.toJson(),
    );
    return ErrorLogsModel.fromJson(response.data);
  }
  
  @override
  Future<ReminderModel> createReminder(CreateReminderParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createReminder,
      data: params.toJson(),
    );
    return ReminderModel.fromJson(response.data);
  }
  
  @override
  Future<ReminderExecutionModel> executeReminder(ExecuteReminderParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.executeReminder,
      data: params.toJson(),
    );
    return ReminderExecutionModel.fromJson(response.data);
  }
}
```

---

## 5.0 資料模型定義（Data Models）

### 5.1 核心資料模型

#### 5.1.1 使用者相關模型
```dart
// lib/data/models/user_model.dart
@JsonSerializable()
class UserModel extends User {
  final String uid;
  final String displayName;
  final String email;
  final String userType;
  final DateTime createdAt;
  final DateTime lastLogin;
  
  const UserModel({
    required this.uid,
    required this.displayName,
    required this.email,
    required this.userType,
    required this.createdAt,
    required this.lastLogin,
  }) : super(
    uid: uid,
    displayName: displayName,
    email: email,
    userType: userType,
    createdAt: createdAt,
    lastLogin: lastLogin,
  );
  
  factory UserModel.fromJson(Map<String, dynamic> json) => _$UserModelFromJson(json);
  Map<String, dynamic> toJson() => _$UserModelToJson(this);
}

@JsonSerializable()
class LoginResponseModel {
  final bool success;
  final String accessToken;
  final String refreshToken;
  final UserModel userInfo;
  final int expiresIn;
  
  const LoginResponseModel({
    required this.success,
    required this.accessToken,
    required this.refreshToken,
    required this.userInfo,
    required this.expiresIn,
  });
  
  factory LoginResponseModel.fromJson(Map<String, dynamic> json) => 
      _$LoginResponseModelFromJson(json);
  Map<String, dynamic> toJson() => _$LoginResponseModelToJson(this);
}
```

#### 5.1.2 記帳相關模型
```dart
// lib/data/models/entry_model.dart
@JsonSerializable()
class EntryModel extends Entry {
  final String entryId;
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;
  
  const EntryModel({
    required this.entryId,
    required this.entryType,
    required this.amount,
    required this.subjectCode,
    required this.subjectName,
    required this.ledgerId,
    required this.entryDate,
    this.description,
    this.tags,
    this.location,
  }) : super(
    entryId: entryId,
    entryType: entryType,
    amount: amount,
    subjectCode: subjectCode,
    subjectName: subjectName,
    ledgerId: ledgerId,
    entryDate: entryDate,
    description: description,
    tags: tags,
    location: location,
  );
  
  factory EntryModel.fromJson(Map<String, dynamic> json) => _$EntryModelFromJson(json);
  Map<String, dynamic> toJson() => _$EntryModelToJson(this);
}

@JsonSerializable()
class PaginatedEntriesModel {
  final bool success;
  final List<EntryModel> entries;
  final EntrySummaryModel summary;
  final PaginationModel pagination;
  
  const PaginatedEntriesModel({
    required this.success,
    required this.entries,
    required this.summary,
    required this.pagination,
  });
  
  factory PaginatedEntriesModel.fromJson(Map<String, dynamic> json) => 
      _$PaginatedEntriesModelFromJson(json);
  Map<String, dynamic> toJson() => _$PaginatedEntriesModelToJson(this);
}
```

#### 5.1.3 專案帳本模型
```dart
// lib/data/models/project_model.dart
@JsonSerializable()
class ProjectModel extends Project {
  final String projectId;
  final String projectName;
  final String description;
  final DateTime startDate;
  final DateTime endDate;
  final String currency;
  final String projectType;
  final String status;
  final String ownerUid;
  final BudgetSettingsModel? budgetSettings;
  final AccessSettingsModel accessSettings;
  
  const ProjectModel({
    required this.projectId,
    required this.projectName,
    required this.description,
    required this.startDate,
    required this.endDate,
    required this.currency,
    required this.projectType,
    required this.status,
    required this.ownerUid,
    this.budgetSettings,
    required this.accessSettings,
  }) : super(
    projectId: projectId,
    projectName: projectName,
    description: description,
    startDate: startDate,
    endDate: endDate,
    currency: currency,
    projectType: projectType,
    status: status,
    ownerUid: ownerUid,
  );
  
  factory ProjectModel.fromJson(Map<String, dynamic> json) => 
      _$ProjectModelFromJson(json);
  Map<String, dynamic> toJson() => _$ProjectModelToJson(this);
}
```

### 5.2 API參數模型

#### 5.2.1 請求參數模型
```dart
// lib/data/models/params/auth_params.dart
@JsonSerializable()
class RegisterUserParams {
  final String platform;
  final String? lineUid;
  final DeviceInfoModel deviceInfo;
  final String displayName;
  final String timezone;
  final String authProvider;
  
  const RegisterUserParams({
    required this.platform,
    this.lineUid,
    required this.deviceInfo,
    required this.displayName,
    required this.timezone,
    required this.authProvider,
  });
  
  factory RegisterUserParams.fromJson(Map<String, dynamic> json) => 
      _$RegisterUserParamsFromJson(json);
  Map<String, dynamic> toJson() => _$RegisterUserParamsToJson(this);
}

@JsonSerializable()
class LoginUserParams {
  final String platform;
  final String? lineUid;
  final String? email;
  final String? password;
  final String authProvider;
  final DeviceInfoModel deviceInfo;
  
  const LoginUserParams({
    required this.platform,
    this.lineUid,
    this.email,
    this.password,
    required this.authProvider,
    required this.deviceInfo,
  });
  
  factory LoginUserParams.fromJson(Map<String, dynamic> json) => 
      _$LoginUserParamsFromJson(json);
  Map<String, dynamic> toJson() => _$LoginUserParamsToJson(this);
}
```

#### 5.2.2 記帳參數模型
```dart
// lib/data/models/params/entry_params.dart
@JsonSerializable()
class CreateEntryParams {
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;
  
  const CreateEntryParams({
    required this.entryType,
    required this.amount,
    required this.subjectCode,
    required this.subjectName,
    required this.ledgerId,
    required this.entryDate,
    this.description,
    this.tags,
    this.location,
  });
  
  factory CreateEntryParams.fromJson(Map<String, dynamic> json) => 
      _$CreateEntryParamsFromJson(json);
  Map<String, dynamic> toJson() => _$CreateEntryParamsToJson(this);
}

@JsonSerializable()
class EntryQueryParams {
  final EntryFiltersModel? filters;
  final PaginationParamsModel? pagination;
  final SortOptionsModel? sort;
  
  const EntryQueryParams({
    this.filters,
    this.pagination,
    this.sort,
  });
  
  factory EntryQueryParams.fromJson(Map<String, dynamic> json) => 
      _$EntryQueryParamsFromJson(json);
  Map<String, dynamic> toJson() => _$EntryQueryParamsToJson(this);
}
```

---

## 6.0 狀態管理策略（State Management）

### 6.1 Provider狀態管理實作

#### 6.1.1 全域狀態管理
```dart
// lib/presentation/providers/app_state_provider.dart
class AppStateProvider extends ChangeNotifier {
  // 認證狀態
  User? _currentUser;
  bool _isAuthenticated = false;
  
  // 帳本狀態
  String? _currentLedgerId;
  List<ProjectModel> _projects = [];
  
  // 網路狀態
  bool _isOnline = true;
  
  // Getters
  User? get currentUser => _currentUser;
  bool get isAuthenticated => _isAuthenticated;
  String? get currentLedgerId => _currentLedgerId;
  List<ProjectModel> get projects => _projects;
  bool get isOnline => _isOnline;
  
  // 認證相關方法
  Future<void> login(LoginUserParams params) async {
    try {
      final result = await sl<LoginUser>().call(params);
      result.fold(
        (failure) => throw Exception(failure.message),
        (loginResponse) {
          _currentUser = loginResponse.userInfo;
          _isAuthenticated = true;
          notifyListeners();
        },
      );
    } catch (e) {
      throw Exception('登入失敗: $e');
    }
  }
  
  Future<void> logout() async {
    try {
      await sl<LogoutUser>().call();
      _currentUser = null;
      _isAuthenticated = false;
      _currentLedgerId = null;
      _projects.clear();
      notifyListeners();
    } catch (e) {
      throw Exception('登出失敗: $e');
    }
  }
  
  // 帳本相關方法
  Future<void> switchLedger(String ledgerId) async {
    try {
      final result = await sl<SwitchLedger>().call(
        SwitchLedgerParams(targetLedgerId: ledgerId)
      );
      result.fold(
        (failure) => throw Exception(failure.message),
        (switchResponse) {
          _currentLedgerId = ledgerId;
          notifyListeners();
        },
      );
    } catch (e) {
      throw Exception('帳本切換失敗: $e');
    }
  }
  
  // 網路狀態管理
  void updateNetworkStatus(bool isOnline) {
    _isOnline = isOnline;
    notifyListeners();
  }
}
```

#### 6.1.2 功能專屬狀態管理
```dart
// lib/presentation/providers/entry_provider.dart
class EntryProvider extends ChangeNotifier {
  final CreateEntry _createEntry;
  final GetEntries _getEntries;
  final UpdateEntry _updateEntry;
  final DeleteEntry _deleteEntry;
  
  EntryProvider({
    required CreateEntry createEntry,
    required GetEntries getEntries,
    required UpdateEntry updateEntry,
    required DeleteEntry deleteEntry,
  }) : _createEntry = createEntry,
       _getEntries = getEntries,
       _updateEntry = updateEntry,
       _deleteEntry = deleteEntry;
  
  // 狀態變數
  List<Entry> _entries = [];
  bool _isLoading = false;
  String? _error;
  PaginationModel? _pagination;
  
  // Getters
  List<Entry> get entries => _entries;
  bool get isLoading => _isLoading;
  String? get error => _error;
  PaginationModel? get pagination => _pagination;
  
  // 新增記帳記錄
  Future<void> createEntry(CreateEntryParams params) async {
    _setLoading(true);
    _clearError();
    
    final result = await _createEntry(params);
    result.fold(
      (failure) => _setError(failure.message),
      (entry) {
        _entries.insert(0, entry);
        notifyListeners();
      },
    );
    
    _setLoading(false);
  }
  
  // 查詢記帳記錄
  Future<void> getEntries(EntryQueryParams params) async {
    _setLoading(true);
    _clearError();
    
    final result = await _getEntries(params);
    result.fold(
      (failure) => _setError(failure.message),
      (paginatedEntries) {
        _entries = paginatedEntries.entries;
        _pagination = paginatedEntries.pagination;
        notifyListeners();
      },
    );
    
    _setLoading(false);
  }
  
  // 載入更多記錄
  Future<void> loadMore() async {
    if (_pagination?.hasNext != true || _isLoading) return;
    
    final nextPage = (_pagination?.currentPage ?? 0) + 1;
    final params = EntryQueryParams(
      pagination: PaginationParamsModel(
        page: nextPage,
        limit: _pagination?.limit ?? 20,
      ),
    );
    
    final result = await _getEntries(params);
    result.fold(
      (failure) => _setError(failure.message),
      (paginatedEntries) {
        _entries.addAll(paginatedEntries.entries);
        _pagination = paginatedEntries.pagination;
        notifyListeners();
      },
    );
  }
  
  // 私有方法
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  void _setError(String error) {
    _error = error;
    notifyListeners();
  }
  
  void _clearError() {
    _error = null;
  }
}
```

### 6.2 Use Cases實作

#### 6.2.1 認證相關Use Cases
```dart
// lib/domain/usecases/auth/login_user.dart
class LoginUser implements UseCase<LoginResponse, LoginUserParams> {
  final AuthRepository repository;
  
  LoginUser(this.repository);
  
  @override
  Future<Either<Failure, LoginResponse>> call(LoginUserParams params) async {
    return await repository.loginUser(params);
  }
}

// lib/domain/usecases/auth/register_user.dart
class RegisterUser implements UseCase<User, RegisterUserParams> {
  final AuthRepository repository;
  
  RegisterUser(this.repository);
  
  @override
  Future<Either<Failure, User>> call(RegisterUserParams params) async {
    return await repository.registerUser(params);
  }
}
```

#### 6.2.2 記帳相關Use Cases
```dart
// lib/domain/usecases/entry/create_entry.dart
class CreateEntry implements UseCase<Entry, CreateEntryParams> {
  final EntryRepository repository;
  
  CreateEntry(this.repository);
  
  @override
  Future<Either<Failure, Entry>> call(CreateEntryParams params) async {
    // 業務邏輯驗證
    if (params.amount <= 0) {
      return Left(ValidationFailure('金額必須大於0'));
    }
    
    if (params.subjectCode.isEmpty) {
      return Left(ValidationFailure('科目代碼不能為空'));
    }
    
    return await repository.createEntry(params);
  }
}

// lib/domain/usecases/entry/get_entries.dart
class GetEntries implements UseCase<PaginatedEntries, EntryQueryParams> {
  final EntryRepository repository;
  
  GetEntries(this.repository);
  
  @override
  Future<Either<Failure, PaginatedEntries>> call(EntryQueryParams params) async {
    return await repository.getEntries(params);
  }
}
```

---

## 7.0 錯誤處理機制（Error Handling）

### 7.1 統一錯誤定義

#### 7.1.1 錯誤類型定義
```dart
// lib/core/error/failures.dart
abstract class Failure extends Equatable {
  final String message;
  final String? code;
  final dynamic details;
  
  const Failure({
    required this.message,
    this.code,
    this.details,
  });
  
  @override
  List<Object?> get props => [message, code, details];
}

class ServerFailure extends Failure {
  const ServerFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class NetworkFailure extends Failure {
  const NetworkFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class CacheFailure extends Failure {
  const CacheFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class ValidationFailure extends Failure {
  const ValidationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class AuthenticationFailure extends Failure {
  const AuthenticationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class AuthorizationFailure extends Failure {
  const AuthorizationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}
```

#### 7.1.2 異常定義
```dart
// lib/core/error/exceptions.dart
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic details;
  
  const AppException({
    required this.message,
    this.code,
    this.details,
  });
}

class ServerException extends AppException {
  const ServerException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}

class NetworkException extends AppException {
  const NetworkException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}

class CacheException extends AppException {
  const CacheException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}
```

### 7.2 錯誤處理器實作

#### 7.2.1 API錯誤處理器
```dart
// lib/core/error/api_error_handler.dart
class ApiErrorHandler {
  static Failure handleError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return NetworkFailure(
          '網路連線逾時，請檢查網路狀態',
          code: 'NETWORK_TIMEOUT',
        );
      
      case DioExceptionType.badResponse:
        return _handleHttpError(error.response!);
      
      case DioExceptionType.connectionError:
        return NetworkFailure(
          '無法連線到伺服器，請檢查網路設定',
          code: 'NETWORK_ERROR',
        );
      
      case DioExceptionType.cancel:
        return NetworkFailure(
          '請求已取消',
          code: 'REQUEST_CANCELLED',
        );
      
      default:
        return ServerFailure(
          '未知錯誤，請稍後再試',
          code: 'UNKNOWN_ERROR',
          details: error.message,
        );
    }
  }
  
  static Failure _handleHttpError(Response response) {
    final statusCode = response.statusCode;
    final data = response.data;
    
    String message = '發生錯誤，請稍後再試';
    String? errorCode;
    
    if (data is Map<String, dynamic>) {
      message = data['message'] ?? message;
      errorCode = data['error_code'];
    }
    
    switch (statusCode) {
      case 400:
        return ValidationFailure(
          message.isNotEmpty ? message : '請求格式錯誤',
          code: errorCode ?? 'BAD_REQUEST',
          details: data,
        );
      
      case 401:
        return AuthenticationFailure(
          message.isNotEmpty ? message : '認證失敗，請重新登入',
          code: errorCode ?? 'UNAUTHORIZED',
          details: data,
        );
      
      case 403:
        return AuthorizationFailure(
          message.isNotEmpty ? message : '權限不足，無法執行此操作',
          code: errorCode ?? 'FORBIDDEN',
          details: data,
        );
      
      case 404:
        return ServerFailure(
          message.isNotEmpty ? message : '找不到請求的資源',
          code: errorCode ?? 'NOT_FOUND',
          details: data,
        );
      
      case 422:
        return ValidationFailure(
          message.isNotEmpty ? message : '資料驗證失敗',
          code: errorCode ?? 'VALIDATION_ERROR',
          details: data,
        );
      
      case 500:
        return ServerFailure(
          message.isNotEmpty ? message : '伺服器內部錯誤',
          code: errorCode ?? 'INTERNAL_SERVER_ERROR',
          details: data,
        );
      
      default:
        return ServerFailure(
          message.isNotEmpty ? message : 'HTTP錯誤 $statusCode',
          code: errorCode ?? 'HTTP_$statusCode',
          details: data,
        );
    }
  }
}
```

#### 7.2.2 錯誤攔截器
```dart
// lib/core/api/error_interceptor.dart
class ErrorInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // 記錄錯誤日誌
    _logError(err);
    
    // 處理特定錯誤類型
    if (err.response?.statusCode == 401) {
      // Token過期，觸發重新登入
      _handleTokenExpired();
    } else if (err.response?.statusCode == 503) {
      // 服務不可用，顯示維護頁面
      _handleServiceUnavailable();
    }
    
    // 轉換為應用錯誤
    final failure = ApiErrorHandler.handleError(err);
    
    // 顯示用戶友善的錯誤訊息
    _showUserFriendlyError(failure);
    
    handler.next(err);
  }
  
  void _logError(DioException error) {
    debugPrint('API Error: ${error.type}');
    debugPrint('URL: ${error.requestOptions.uri}');
    debugPrint('Method: ${error.requestOptions.method}');
    debugPrint('Status Code: ${error.response?.statusCode}');
    debugPrint('Response: ${error.response?.data}');
  }
  
  void _handleTokenExpired() {
    // 清除本地Token
    sl<TokenRepository>().clearTokens();
    
    // 導向登入頁面
    NavigationService.pushAndClearStack('/login');
    
    // 顯示提示訊息
    ToastService.showError('登入已過期，請重新登入');
  }
  
  void _handleServiceUnavailable() {
    NavigationService.pushNamed('/maintenance');
  }
  
  void _showUserFriendlyError(Failure failure) {
    String message;
    
    switch (failure.runtimeType) {
      case NetworkFailure:
        message = '網路連線問題，請檢查網路設定';
        break;
      case ServerFailure:
        message = '伺服器暫時無法回應，請稍後再試';
        break;
      case ValidationFailure:
        message = failure.message;
        break;
      case AuthenticationFailure:
        message = '登入驗證失敗，請重新登入';
        break;
      case AuthorizationFailure:
        message = '您沒有權限執行此操作';
        break;
      default:
        message = '發生未知錯誤，請稍後再試';
    }
    
    ToastService.showError(message);
  }
}
```

---

## 8.0 快取策略設計（Caching Strategy）

### 8.1 多層次快取架構

#### 8.1.1 快取管理器實作
```dart
// lib/core/cache/cache_manager.dart
abstract class CacheManager {
  Future<void> put<T>(String key, T data, {Duration? expiry});
  Future<T?> get<T>(String key);
  Future<bool> exists(String key);
  Future<bool> isExpired(String key);
  Future<void> delete(String key);
  Future<void> clear();
  Future<void> clearExpired();
}

class CacheManagerImpl implements CacheManager {
  final Box _box;
  static const String _expiryPrefix = '_expiry_';
  
  CacheManagerImpl(this._box);
  
  @override
  Future<void> put<T>(String key, T data, {Duration? expiry}) async {
    await _box.put(key, data);
    
    if (expiry != null) {
      final expiryTime = DateTime.now().add(expiry);
      await _box.put('$_expiryPrefix$key', expiryTime.millisecondsSinceEpoch);
    }
  }
  
  @override
  Future<T?> get<T>(String key) async {
    if (await isExpired(key)) {
      await delete(key);
      return null;
    }
    
    return _box.get(key) as T?;
  }
  
  @override
  Future<bool> exists(String key) async {
    return _box.containsKey(key) && !await isExpired(key);
  }
  
  @override
  Future<bool> isExpired(String key) async {
    final expiryKey = '$_expiryPrefix$key';
    if (!_box.containsKey(expiryKey)) {
      return false;
    }
    
    final expiryTime = _box.get(expiryKey) as int;
    return DateTime.now().millisecondsSinceEpoch > expiryTime;
  }
  
  @override
  Future<void> delete(String key) async {
    await _box.delete(key);
    await _box.delete('$_expiryPrefix$key');
  }
  
  @override
  Future<void> clear() async {
    await _box.clear();
  }
  
  @override
  Future<void> clearExpired() async {
    final keys = _box.keys.where((key) => key.toString().startsWith(_expiryPrefix));
    
    for (final expiryKey in keys) {
      final dataKey = expiryKey.toString().substring(_expiryPrefix.length);
      if (await isExpired(dataKey)) {
        await delete(dataKey);
      }
    }
  }
}
```

#### 8.1.2 快取策略定義
```dart
// lib/core/cache/cache_strategies.dart
enum CacheStrategy {
  cacheFirst,    // 優先使用快取
  networkFirst,  // 優先網路請求
  cacheOnly,     // 僅使用快取
  networkOnly,   // 僅網路請求
  staleWhileRevalidate, // 使用快取同時更新
}

class CacheConfig {
  final CacheStrategy strategy;
  final Duration? expiry;
  final bool storeOnFailure;
  final int maxRetries;
  
  const CacheConfig({
    required this.strategy,
    this.expiry,
    this.storeOnFailure = false,
    this.maxRetries = 3,
  });
}

class ApiCacheManager {
  static const Map<String, CacheConfig> _cacheConfigs = {
    // 使用者資料 - 中等頻率快取
    'GET:/auth/user': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 30),
    ),
    
    // 記帳歷史 - 短期快取
    'GET:/entries': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 5),
    ),
    
    // 專案列表 - 中期快取
    'GET:/projects': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 15),
    ),
    
    // 預算進度 - 短期快取
    'GET:/budgets/{id}/progress': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 2),
    ),
    
    // 報表數據 - 長期快取
    'GET:/reports': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(hours: 1),
    ),
    
    // 系統健康 - 極短期快取
    'GET:/system/health': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(seconds: 30),
    ),
    
    // 備份列表 - 中期快取
    'GET:/backups': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 10),
    ),
    
    // 即時數據 - 不快取
    'POST:/entries': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
    
    'POST:/entries/quick': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
    
    'PUT:/entries/{id}': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
    
    'DELETE:/entries/{id}': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
  };
  
  static CacheConfig getConfig(String method, String path) {
    final key = '$method:$path';
    return _cacheConfigs[key] ?? const CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 5),
    );
  }
}
```

#### 8.1.3 快取攔截器實作
```dart
// lib/core/api/cache_interceptor.dart
class CacheInterceptor extends Interceptor {
  final CacheManager _cacheManager;
  
  CacheInterceptor(this._cacheManager);
  
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(options);
    final config = ApiCacheManager.getConfig(options.method, options.path);
    
    switch (config.strategy) {
      case CacheStrategy.cacheFirst:
        final cachedData = await _cacheManager.get(cacheKey);
        if (cachedData != null) {
          final response = Response(
            requestOptions: options,
            data: cachedData,
            statusCode: 200,
            headers: Headers.fromMap({'x-cache': ['HIT']}),
          );
          handler.resolve(response);
          return;
        }
        break;
        
      case CacheStrategy.cacheOnly:
        final cachedData = await _cacheManager.get(cacheKey);
        if (cachedData != null) {
          final response = Response(
            requestOptions: options,
            data: cachedData,
            statusCode: 200,
            headers: Headers.fromMap({'x-cache': ['HIT']}),
          );
          handler.resolve(response);
        } else {
          handler.reject(DioException(
            requestOptions: options,
            error: '快取中無此資料，且僅允許快取存取',
          ));
        }
        return;
        
      case CacheStrategy.networkOnly:
        // 不使用快取，直接網路請求
        break;
        
      case CacheStrategy.networkFirst:
      case CacheStrategy.staleWhileRevalidate:
        // 先嘗試網路請求，失敗時使用快取
        break;
    }
    
    handler.next(options);
  }
  
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(response.requestOptions);
    final config = ApiCacheManager.getConfig(
      response.requestOptions.method,
      response.requestOptions.path,
    );
    
    // 根據策略決定是否快取
    if (_shouldCache(config, response)) {
      await _cacheManager.put(
        cacheKey,
        response.data,
        expiry: config.expiry,
      );
    }
    
    handler.next(response);
  }
  
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(err.requestOptions);
    final config = ApiCacheManager.getConfig(
      err.requestOptions.method,
      err.requestOptions.path,
    );
    
    // 網路請求失敗時，嘗試使用快取
    if (config.strategy == CacheStrategy.networkFirst ||
        config.strategy == CacheStrategy.staleWhileRevalidate) {
      final cachedData = await _cacheManager.get(cacheKey);
      if (cachedData != null) {
        final response = Response(
          requestOptions: err.requestOptions,
          data: cachedData,
          statusCode: 200,
          headers: Headers.fromMap({'x-cache': ['STALE']}),
        );
        handler.resolve(response);
        return;
      }
    }
    
    handler.next(err);
  }
  
  String _generateCacheKey(RequestOptions options) {
    final uri = options.uri.toString();
    final method = options.method;
    final queryParams = options.queryParameters.entries
        .map((e) => '${e.key}=${e.value}')
        .join('&');
    
    return '$method:$uri${queryParams.isNotEmpty ? '?$queryParams' : ''}';
  }
  
  bool _shouldCache(CacheConfig config, Response response) {
    // 只快取成功的回應
    if (response.statusCode != 200) {
      return config.storeOnFailure;
    }
    
    // 不快取空資料
    if (response.data == null) {
      return false;
    }
    
    return config.strategy != CacheStrategy.networkOnly;
  }
}
```

---

## 9.0 離線同步機制（Offline Sync）

### 9.1 離線操作佇列

#### 9.1.1 離線操作模型
```dart
// lib/core/sync/offline_operation.dart
@JsonSerializable()
class OfflineOperation {
  final String id;
  final String operationType; // create, update, delete
  final String endpoint;
  final String method;
  final Map<String, dynamic>? data;
  final Map<String, String>? headers;
  final DateTime timestamp;
  final int retryCount;
  final DateTime? nextRetry;
  final OperationStatus status;
  final String? errorMessage;
  
  OfflineOperation({
    required this.id,
    required this.operationType,
    required this.endpoint,
    required this.method,
    this.data,
    this.headers,
    required this.timestamp,
    this.retryCount = 0,
    this.nextRetry,
    this.status = OperationStatus.pending,
    this.errorMessage,
  });
  
  factory OfflineOperation.fromJson(Map<String, dynamic> json) => 
      _$OfflineOperationFromJson(json);
  Map<String, dynamic> toJson() => _$OfflineOperationToJson(this);
}

enum OperationStatus {
  pending,    // 等待同步
  syncing,    // 同步中
  synced,     // 已同步
  failed,     // 同步失敗
  cancelled,  // 已取消
}
```

#### 9.1.2 離線同步管理器
```dart
// lib/core/sync/offline_sync_manager.dart
class OfflineSyncManager {
  final CacheManager _cacheManager;
  final ApiClient _apiClient;
  final ConnectivityService _connectivity;
  final Queue<OfflineOperation> _syncQueue = Queue();
  
  static const String _queueKey = 'offline_sync_queue';
  static const int _maxRetries = 3;
  
  OfflineSyncManager({
    required CacheManager cacheManager,
    required ApiClient apiClient,
    required ConnectivityService connectivity,
  }) : _cacheManager = cacheManager,
       _apiClient = apiClient,
       _connectivity = connectivity;
  
  // 初始化同步管理器
  Future<void> initialize() async {
    await _loadSyncQueue();
    _connectivity.onConnectivityChanged.listen(_onConnectivityChanged);
  }
  
  // 新增離線操作到佇列
  Future<void> queueOperation(OfflineOperation operation) async {
    // 本地執行操作
    await _executeLocalOperation(operation);
    
    // 加入同步佇列
    _syncQueue.add(operation);
    await _persistSyncQueue();
    
    // 如果線上，立即嘗試同步
    if (await _connectivity.isConnected) {
      _processSyncQueue();
    }
  }
  
  // 處理同步佇列
  Future<void> _processSyncQueue() async {
    while (_syncQueue.isNotEmpty && await _connectivity.isConnected) {
      final operation = _syncQueue.first;
      
      if (operation.status == OperationStatus.synced) {
        _syncQueue.removeFirst();
        continue;
      }
      
      if (operation.nextRetry != null && 
          DateTime.now().isBefore(operation.nextRetry!)) {
        break; // 等待重試時間
      }
      
      try {
        operation.status = OperationStatus.syncing;
        await _executeRemoteOperation(operation);
        
        operation.status = OperationStatus.synced;
        _syncQueue.removeFirst();
        
      } catch (e) {
        await _handleSyncError(operation, e);
      }
      
      await _persistSyncQueue();
    }
  }
  
  // 執行本地操作
  Future<void> _executeLocalOperation(OfflineOperation operation) async {
    try {
      switch (operation.operationType) {
        case 'create':
          await _handleLocalCreate(operation);
          break;
        case 'update':
          await _handleLocalUpdate(operation);
          break;
        case 'delete':
          await _handleLocalDelete(operation);
          break;
      }
    } catch (e) {
      debugPrint('本地操作執行失敗: $e');
    }
  }
  
  // 執行遠端同步
  Future<void> _executeRemoteOperation(OfflineOperation operation) async {
    final response = await _apiClient.request(
      operation.endpoint,
      options: Options(
        method: operation.method,
        headers: operation.headers,
      ),
      data: operation.data,
    );
    
    // 更新本地快取
    if (response.statusCode == 200 || response.statusCode == 201) {
      await _updateLocalCacheAfterSync(operation, response.data);
    }
  }
  
  // 處理同步錯誤
  Future<void> _handleSyncError(OfflineOperation operation, dynamic error) async {
    operation.retryCount++;
    
    if (operation.retryCount < _maxRetries) {
      // 計算下次重試時間 (指數退避)
      final delay = Duration(seconds: math.pow(2, operation.retryCount).toInt());
      operation.nextRetry = DateTime.now().add(delay);
      operation.status = OperationStatus.pending;
    } else {
      operation.status = OperationStatus.failed;
      operation.errorMessage = error.toString();
    }
  }
  
  // 本地建立操作處理
  Future<void> _handleLocalCreate(OfflineOperation operation) async {
    final localId = 'local_${operation.id}';
    await _cacheManager.put('temp_entry_$localId', operation.data);
  }
  
  // 本地更新操作處理
  Future<void> _handleLocalUpdate(OfflineOperation operation) async {
    final existingData = await _cacheManager.get(operation.endpoint);
    if (existingData != null) {
      final updatedData = {...existingData as Map<String, dynamic>, ...?operation.data};
      await _cacheManager.put(operation.endpoint, updatedData);
    }
  }
  
  // 本地刪除操作處理
  Future<void> _handleLocalDelete(OfflineOperation operation) async {
    await _cacheManager.delete(operation.endpoint);
  }
  
  // 網路狀態變化處理
  void _onConnectivityChanged(bool isConnected) {
    if (isConnected && _syncQueue.isNotEmpty) {
      _processSyncQueue();
    }
  }
  
  // 載入同步佇列
  Future<void> _loadSyncQueue() async {
    final queueData = await _cacheManager.get<List>(_queueKey);
    if (queueData != null) {
      _syncQueue.addAll(
        queueData.map((json) => OfflineOperation.fromJson(json))
      );
    }
  }
  
  // 持久化同步佇列
  Future<void> _persistSyncQueue() async {
    final queueData = _syncQueue.map((op) => op.toJson()).toList();
    await _cacheManager.put(_queueKey, queueData);
  }
  
  // 同步完成後更新本地快取
  Future<void> _updateLocalCacheAfterSync(
    OfflineOperation operation, 
    dynamic responseData
  ) async {
    switch (operation.operationType) {
      case 'create':
        // 更新本地ID映射
        final localId = 'local_${operation.id}';
        await _cacheManager.delete('temp_entry_$localId');
        if (responseData != null) {
          await _cacheManager.put(operation.endpoint, responseData);
        }
        break;
      case 'update':
        if (responseData != null) {
          await _cacheManager.put(operation.endpoint, responseData);
        }
        break;
      case 'delete':
        // 確保本地資料已刪除
        await _cacheManager.delete(operation.endpoint);
        break;
    }
  }
}
```

### 9.2 衝突解決機制

#### 9.2.1 衝突檢測器
```dart
// lib/core/sync/conflict_detector.dart
class ConflictDetector {
  static ConflictResult detectConflict(
    Map<String, dynamic> localData,
    Map<String, dynamic> remoteData,
  ) {
    final conflicts = <String, ConflictInfo>[];
    
    // 檢測時間戳衝突
    final localTimestamp = DateTime.tryParse(localData['updated_at'] ?? '');
    final remoteTimestamp = DateTime.tryParse(remoteData['updated_at'] ?? '');
    
    if (localTimestamp != null && remoteTimestamp != null) {
      if (localTimestamp.isAfter(remoteTimestamp)) {
        return ConflictResult(
          hasConflict: true,
          conflictType: ConflictType.localNewer,
          localData: localData,
          remoteData: remoteData,
        );
      } else if (remoteTimestamp.isAfter(localTimestamp)) {
        return ConflictResult(
          hasConflict: true,
          conflictType: ConflictType.remoteNewer,
          localData: localData,
          remoteData: remoteData,
        );
      }
    }
    
    // 檢測欄位級別衝突
    final allKeys = {...localData.keys, ...remoteData.keys};
    
    for (final key in allKeys) {
      if (key == 'updated_at' || key == 'created_at') continue;
      
      final localValue = localData[key];
      final remoteValue = remoteData[key];
      
      if (localValue != remoteValue) {
        conflicts.add(ConflictInfo(
          field: key,
          localValue: localValue,
          remoteValue: remoteValue,
        ));
      }
    }
    
    if (conflicts.isNotEmpty) {
      return ConflictResult(
        hasConflict: true,
        conflictType: ConflictType.fieldLevel,
        conflicts: conflicts,
        localData: localData,
        remoteData: remoteData,
      );
    }
    
    return ConflictResult(hasConflict: false);
  }
}

class ConflictResult {
  final bool hasConflict;
  final ConflictType? conflictType;
  final List<ConflictInfo>? conflicts;
  final Map<String, dynamic>? localData;
  final Map<String, dynamic>? remoteData;
  
  ConflictResult({
    required this.hasConflict,
    this.conflictType,
    this.conflicts,
    this.localData,
    this.remoteData,
  });
}

enum ConflictType {
  localNewer,   // 本地資料較新
  remoteNewer,  // 遠端資料較新
  fieldLevel,   // 欄位級衝突
  concurrent,   // 併發修改
}

class ConflictInfo {
  final String field;
  final dynamic localValue;
  final dynamic remoteValue;
  
  ConflictInfo({
    required this.field,
    required this.localValue,
    required this.remoteValue,
  });
}
```

#### 9.2.2 衝突解決器
```dart
// lib/core/sync/conflict_resolver.dart
class ConflictResolver {
  // 自動解決衝突
  static Map<String, dynamic> autoResolve(ConflictResult conflict) {
    if (!conflict.hasConflict) {
      return conflict.remoteData ?? {};
    }
    
    switch (conflict.conflictType) {
      case ConflictType.localNewer:
        return conflict.localData!;
      
      case ConflictType.remoteNewer:
        return conflict.remoteData!;
      
      case ConflictType.fieldLevel:
        return _mergeFieldLevel(conflict);
      
      case ConflictType.concurrent:
        return _handleConcurrentConflict(conflict);
      
      default:
        return conflict.remoteData!;
    }
  }
  
  // 欄位級衝突合併
  static Map<String, dynamic> _mergeFieldLevel(ConflictResult conflict) {
    final merged = <String, dynamic>{...conflict.remoteData!};
    
    // 對於特定欄位，採用本地優先策略
    final localPriorityFields = ['amount', 'description', 'subject_code'];
    
    for (final conflictInfo in conflict.conflicts!) {
      if (localPriorityFields.contains(conflictInfo.field)) {
        merged[conflictInfo.field] = conflictInfo.localValue;
      }
    }
    
    return merged;
  }
  
  // 處理併發衝突
  static Map<String, dynamic> _handleConcurrentConflict(ConflictResult conflict) {
    // 對於併發衝突，採用最後寫入勝利策略
    final localTime = DateTime.tryParse(conflict.localData!['updated_at'] ?? '');
    final remoteTime = DateTime.tryParse(conflict.remoteData!['updated_at'] ?? '');
    
    if (localTime != null && remoteTime != null) {
      return localTime.isAfter(remoteTime) 
          ? conflict.localData! 
          : conflict.remoteData!;
    }
    
    return conflict.remoteData!;
  }
  
  // 手動解決衝突 (由使用者選擇)
  static Map<String, dynamic> manualResolve(
    ConflictResult conflict,
    ConflictResolution resolution,
  ) {
    switch (resolution.strategy) {
      case ResolutionStrategy.useLocal:
        return conflict.localData!;
      
      case ResolutionStrategy.useRemote:
        return conflict.remoteData!;
      
      case ResolutionStrategy.merge:
        return _customMerge(conflict, resolution.fieldChoices);
      
      case ResolutionStrategy.cancel:
        throw ConflictCancelledException('使用者取消衝突解決');
    }
  }
  
  // 自訂合併策略
  static Map<String, dynamic> _customMerge(
    ConflictResult conflict,
    Map<String, dynamic>? fieldChoices,
  ) {
    final merged = <String, dynamic>{...conflict.remoteData!};
    
    if (fieldChoices != null) {
      for (final entry in fieldChoices.entries) {
        final field = entry.key;
        final useLocal = entry.value as bool;
        
        if (useLocal && conflict.localData!.containsKey(field)) {
          merged[field] = conflict.localData![field];
        }
      }
    }
    
    return merged;
  }
}

class ConflictResolution {
  final ResolutionStrategy strategy;
  final Map<String, dynamic>? fieldChoices;
  
  ConflictResolution({
    required this.strategy,
    this.fieldChoices,
  });
}

enum ResolutionStrategy {
  useLocal,   // 使用本地版本
  useRemote,  // 使用遠端版本
  merge,      // 手動合併
  cancel,     // 取消操作
}

class ConflictCancelledException implements Exception {
  final String message;
  ConflictCancelledException(this.message);
}
```

---

## 10.0 效能優化策略（Performance Optimization）

### 10.1 API請求優化

#### 10.1.1 請求去重與批量處理
```dart
// lib/core/optimization/request_optimizer.dart
class RequestOptimizer {
  final Map<String, Completer<Response>> _pendingRequests = {};
  final Map<String, Timer> _debounceTimers = {};
  
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  static const int _batchSize = 10;
  
  // 請求去重
  Future<Response> deduplicate(RequestOptions options, Future<Response> Function() request) async {
    final key = _generateRequestKey(options);
    
    if (_pendingRequests.containsKey(key)) {
      return _pendingRequests[key]!.future;
    }
    
    final completer = Completer<Response>();
    _pendingRequests[key] = completer;
    
    try {
      final response = await request();
      completer.complete(response);
      return response;
    } catch (error) {
      completer.completeError(error);
      rethrow;
    } finally {
      _pendingRequests.remove(key);
    }
  }
  
  // 請求防抖
  Future<Response> debounce(
    String key,
    RequestOptions options,
    Future<Response> Function() request,
  ) async {
    final completer = Completer<Response>();
    
    // 取消之前的計時器
    _debounceTimers[key]?.cancel();
    
    _debounceTimers[key] = Timer(_debounceDelay, () async {
      try {
        final response = await request();
        completer.complete(response);
      } catch (error) {
        completer.completeError(error);
      } finally {
        _debounceTimers.remove(key);
      }
    });
    
    return completer.future;
  }
  
  // 批量請求處理
  Future<List<Response>> batchRequests(
    List<RequestOptions> requestsList,
    Future<Response> Function(RequestOptions) requestFunction,
  ) async {
    final responses = <Response>[];
    
    for (int i = 0; i < requestsList.length; i += _batchSize) {
      final batch = requestsList.skip(i).take(_batchSize);
      final futures = batch.map(requestFunction);
      
      final batchResponses = await Future.wait(futures);
      responses.addAll(batchResponses);
      
      // 批次間稍作延遲，避免伺服器過載
      if (i + _batchSize < requestsList.length) {
        await Future.delayed(const Duration(milliseconds: 100));
      }
    }
    
    return responses;
  }
  
  String _generateRequestKey(RequestOptions options) {
    final uri = options.uri.toString();
    final method = options.method;
    final dataHash = options.data?.hashCode ?? 0;
    
    return '$method:$uri:$dataHash';
  }
}
```

#### 10.1.2 併發控制與限流
```dart
// lib/core/optimization/concurrency_manager.dart
class ConcurrencyManager {
  final int _maxConcurrent;
  final Queue<_RequestTask> _waitingQueue = Queue();
  int _currentConcurrent = 0;
  
  ConcurrencyManager({int maxConcurrent = 5}) : _maxConcurrent = maxConcurrent;
  
  Future<T> execute<T>(Future<T> Function() task) async {
    final completer = Completer<T>();
    final requestTask = _RequestTask(task, completer);
    
    if (_currentConcurrent < _maxConcurrent) {
      _executeTask(requestTask);
    } else {
      _waitingQueue.add(requestTask);
    }
    
    return completer.future;
  }
  
  void _executeTask<T>(_RequestTask<T> task) async {
    _currentConcurrent++;
    
    try {
      final result = await task.task();
      task.completer.complete(result);
    } catch (error) {
      task.completer.completeError(error);
    } finally {
      _currentConcurrent--;
      _processWaitingQueue();
    }
  }
  
  void _processWaitingQueue() {
    if (_waitingQueue.isNotEmpty && _currentConcurrent < _maxConcurrent) {
      final nextTask = _waitingQueue.removeFirst();
      _executeTask(nextTask);
    }
  }
}

class _RequestTask<T> {
  final Future<T> Function() task;
  final Completer<T> completer;
  
  _RequestTask(this.task, this.completer);
}
```

### 10.2 資料載入優化

#### 10.2.1 預載入策略
```dart
// lib/core/optimization/preloader.dart
class DataPreloader {
  final Map<String, Future<dynamic>> _preloadTasks = {};
  final CacheManager _cacheManager;
  
  DataPreloader(this._cacheManager);
  
  // 根據使用者行為預載入資料
  Future<void> preloadBasedOnUsage(String userId) async {
    // 預載入使用者資料
    _preloadUserData(userId);
    
    // 預載入最近使用的帳本
    _preloadRecentLedgers(userId);
    
    // 預載入常用科目
    _preloadFrequentSubjects(userId);
    
    // 預載入本月記帳記錄
    _preloadCurrentMonthEntries(userId);
  }
  
  Future<void> _preloadUserData(String userId) async {
    const key = 'preload_user_data';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      final userService = sl<AuthService>();
      final user = await userService.getUserProfile();
      await _cacheManager.put('user_profile', user, expiry: Duration(hours: 1));
    });
  }
  
  Future<void> _preloadRecentLedgers(String userId) async {
    const key = 'preload_recent_ledgers';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      final projectService = sl<ProjectLedgerService>();
      final projects = await projectService.getProjects();
      await _cacheManager.put('recent_projects', projects, expiry: Duration(minutes: 30));
    });
  }
  
  Future<void> _preloadFrequentSubjects(String userId) async {
    const key = 'preload_frequent_subjects';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      // 假設有API可以取得常用科目
      final subjects = await sl<EntryService>().getFrequentSubjects();
      await _cacheManager.put('frequent_subjects', subjects, expiry: Duration(days: 1));
    });
  }
  
  Future<void> _preloadCurrentMonthEntries(String userId) async {
    const key = 'preload_current_month';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      final now = DateTime.now();
      final startOfMonth = DateTime(now.year, now.month, 1);
      final endOfMonth = DateTime(now.year, now.month + 1, 0);
      
      final params = EntryQueryParams(
        filters: EntryFiltersModel(
          dateRange: DateRangeModel(
            startDate: startOfMonth,
            endDate: endOfMonth,
          ),
        ),
        pagination: PaginationParamsModel(page: 1, limit: 50),
      );
      
      final entries = await sl<EntryService>().getEntries(params);
      await _cacheManager.put('current_month_entries', entries, expiry: Duration(hours: 2));
    });
  }
  
  Future<void> _executePreload(Future<void> Function() preloadFunction) async {
    try {
      await preloadFunction();
    } catch (e) {
      // 預載入失敗不影響主要功能
      debugPrint('預載入失敗: $e');
    }
  }
  
  // 清理預載入任務
  void clearPreloadTasks() {
    _preloadTasks.clear();
  }
}
```

#### 10.2.2 分頁與虛擬滾動優化
```dart
// lib/core/optimization/pagination_manager.dart
class PaginationManager<T> {
  final Future<PaginatedResult<T>> Function(int page, int limit) _loadFunction;
  final int _pageSize;
  
  final List<T> _items = [];
  final Set<int> _loadedPages = {};
  bool _hasMore = true;
  bool _isLoading = false;
  
  PaginationManager({
    required Future<PaginatedResult<T>> Function(int page, int limit) loadFunction,
    int pageSize = 20,
  }) : _loadFunction = loadFunction,
       _pageSize = pageSize;
  
  List<T> get items => _items;
  bool get hasMore => _hasMore;
  bool get isLoading => _isLoading;
  
  // 載入指定頁面
  Future<void> loadPage(int page) async {
    if (_loadedPages.contains(page) || _isLoading) return;
    
    _isLoading = true;
    
    try {
      final result = await _loadFunction(page, _pageSize);
      
      // 插入資料到正確位置
      final startIndex = (page - 1) * _pageSize;
      _insertItemsAtIndex(startIndex, result.items);
      
      _loadedPages.add(page);
      _hasMore = result.hasMore;
      
    } catch (e) {
      debugPrint('載入頁面失敗: $e');
    } finally {
      _isLoading = false;
    }
  }
  
  // 載入下一頁
  Future<void> loadMore() async {
    if (!_hasMore || _isLoading) return;
    
    final nextPage = (_loadedPages.isEmpty) ? 1 : _loadedPages.length + 1;
    await loadPage(nextPage);
  }
  
  // 刷新資料
  Future<void> refresh() async {
    _items.clear();
    _loadedPages.clear();
    _hasMore = true;
    
    await loadPage(1);
  }
  
  // 預載入鄰近頁面
  Future<void> preloadAdjacent(int currentIndex) async {
    final currentPage = (currentIndex / _pageSize).ceil();
    
    // 預載入前一頁和後一頁
    final pagesToPreload = [currentPage - 1, currentPage + 1]
        .where((page) => page > 0 && !_loadedPages.contains(page));
    
    for (final page in pagesToPreload) {
      if (_hasMore || page <= _loadedPages.length) {
        loadPage(page); // 不等待完成，背景載入
      }
    }
  }
  
  void _insertItemsAtIndex(int startIndex, List<T> newItems) {
    // 確保列表有足夠長度
    while (_items.length < startIndex) {
      _items.add(null as T); // 佔位符
    }
    
    // 插入新資料
    for (int i = 0; i < newItems.length; i++) {
      final index = startIndex + i;
      if (index < _items.length) {
        _items[index] = newItems[i];
      } else {
        _items.add(newItems[i]);
      }
    }
  }
}

class PaginatedResult<T> {
  final List<T> items;
  final bool hasMore;
  final int currentPage;
  final int totalPages;
  
  PaginatedResult({
    required this.items,
    required this.hasMore,
    required this.currentPage,
    required this.totalPages,
  });
}
```

---

## 11.0 測試策略（Testing Strategy）

### 11.1 單元測試

#### 11.1.1 API服務測試
```dart
// test/data/datasources/remote/auth_remote_datasource_test.dart
@GenerateMocks([ApiClient])
void main() {
  late AuthRemoteDataSourceImpl dataSource;
  late MockApiClient mockApiClient;
  
  setUp(() {
    mockApiClient = MockApiClient();
    dataSource = AuthRemoteDataSourceImpl(apiClient: mockApiClient);
  });
  
  group('AuthRemoteDataSource', () {
    group('registerUser', () {
      const tRegisterParams = RegisterUserParams(
        platform: 'mobile_app',
        displayName: 'Test User',
        timezone: 'Asia/Taipei',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(
          deviceType: 'ios',
          appVersion: '1.0.0',
        ),
      );
      
      const tUserModel = UserModel(
        uid: 'test_uid',
        displayName: 'Test User',
        email: 'test@example.com',
        userType: 'S',
        createdAt: '2025-01-24T10:00:00Z',
        lastLogin: '2025-01-24T10:00:00Z',
      );
      
      test('should perform POST request to correct endpoint', () async {
        // arrange
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenAnswer((_) async => Response(
                  requestOptions: RequestOptions(path: ''),
                  data: tUserModel.toJson(),
                  statusCode: 200,
                ));
        
        // act
        await dataSource.registerUser(tRegisterParams);
        
        // assert
        verify(mockApiClient.post(
          ApiEndpoints.registerUser,
          data: tRegisterParams.toJson(),
        ));
      });
      
      test('should return UserModel when response is successful', () async {
        // arrange
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenAnswer((_) async => Response(
                  requestOptions: RequestOptions(path: ''),
                  data: tUserModel.toJson(),
                  statusCode: 200,
                ));
        
        // act
        final result = await dataSource.registerUser(tRegisterParams);
        
        // assert
        expect(result, equals(tUserModel));
      });
      
      test('should throw ServerException when response code is not 200', () async {
        // arrange
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenThrow(DioException(
              requestOptions: RequestOptions(path: ''),
              response: Response(
                requestOptions: RequestOptions(path: ''),
                statusCode: 500,
              ),
            ));
        
        // act & assert
        expect(
          () => dataSource.registerUser(tRegisterParams),
          throwsA(isA<ServerException>()),
        );
      });
    });
    
    group('loginUser', () {
      // 類似的測試結構...
    });
  });
}
```

#### 11.1.2 Repository測試
```dart
// test/data/repositories/auth_repository_impl_test.dart
@GenerateMocks([
  AuthRemoteDataSource,
  AuthLocalDataSource,
  NetworkInfo,
])
void main() {
  late AuthRepositoryImpl repository;
  late MockAuthRemoteDataSource mockRemoteDataSource;
  late MockAuthLocalDataSource mockLocalDataSource;
  late MockNetworkInfo mockNetworkInfo;
  
  setUp(() {
    mockRemoteDataSource = MockAuthRemoteDataSource();
    mockLocalDataSource = MockAuthLocalDataSource();
    mockNetworkInfo = MockNetworkInfo();
    repository = AuthRepositoryImpl(
      remoteDataSource: mockRemoteDataSource,
      localDataSource: mockLocalDataSource,
      networkInfo: mockNetworkInfo,
    );
  });
  
  group('AuthRepository', () {
    group('registerUser', () {
      const tRegisterParams = RegisterUserParams(
        platform: 'mobile_app',
        displayName: 'Test User',
        timezone: 'Asia/Taipei',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(
          deviceType: 'ios',
          appVersion: '1.0.0',
        ),
      );
      
      const tUser = UserModel(
        uid: 'test_uid',
        displayName: 'Test User',
        email: 'test@example.com',
        userType: 'S',
        createdAt: '2025-01-24T10:00:00Z',
        lastLogin: '2025-01-24T10:00:00Z',
      );
      
      test('should return User when device is online and call is successful', () async {
        // arrange
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);
        when(mockRemoteDataSource.registerUser(any))
            .thenAnswer((_) async => tUser);
        when(mockLocalDataSource.cacheUser(any))
            .thenAnswer((_) async => {});
        
        // act
        final result = await repository.registerUser(tRegisterParams);
        
        // assert
        verify(mockRemoteDataSource.registerUser(tRegisterParams));
        verify(mockLocalDataSource.cacheUser(tUser));
        expect(result, equals(const Right(tUser)));
      });
      
      test('should return NetworkFailure when device is offline', () async {
        // arrange
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => false);
        
        // act
        final result = await repository.registerUser(tRegisterParams);
        
        // assert
        verifyZeroInteractions(mockRemoteDataSource);
        expect(result, equals(const Left(NetworkFailure('網路連線異常'))));
      });
      
      test('should return ServerFailure when remote call throws ServerException', () async {
        // arrange
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);
        when(mockRemoteDataSource.registerUser(any))
            .thenThrow(const ServerException(message: '伺服器錯誤'));
        
        // act
        final result = await repository.registerUser(tRegisterParams);
        
        // assert
        expect(result, equals(const Left(ServerFailure('伺服器錯誤'))));
      });
    });
  });
}
```

### 11.2 整合測試

#### 11.2.1 API整合測試
```dart
// test/integration/api_integration_test.dart
void main() {
  late ApiClient apiClient;
  late AuthRemoteDataSourceImpl authDataSource;
  
  setUpAll(() {
    // 使用測試環境的API端點
    apiClient = ApiClient(baseUrl: 'https://lcas-api-test.replit.app/api/v1');
    authDataSource = AuthRemoteDataSourceImpl(apiClient: apiClient);
  });
  
  group('API Integration Tests', () {
    group('Authentication Flow', () {
      test('complete authentication flow should work', () async {
        // 1. 註冊新用戶
        final registerParams = RegisterUserParams(
          platform: 'mobile_app',
          displayName: 'Integration Test User',
          timezone: 'Asia/Taipei',
          authProvider: 'email',
          deviceInfo: DeviceInfoModel(
            deviceType: 'ios',
            appVersion: '1.0.0',
          ),
        );
        
        final registeredUser = await authDataSource.registerUser(registerParams);
        expect(registeredUser.displayName, 'Integration Test User');
        
        // 2. 使用註冊資訊登入
        final loginParams = LoginUserParams(
          platform: 'mobile_app',
          email: registeredUser.email,
          password: 'test_password',
          authProvider: 'email',
          deviceInfo: DeviceInfoModel(
            deviceType: 'ios',
            appVersion: '1.0.0',
          ),
        );
        
        final loginResponse = await authDataSource.loginUser(loginParams);
        expect(loginResponse.success, true);
        expect(loginResponse.accessToken, isNotEmpty);
        
        // 3. 使用Token取得用戶資料
        // 設定Authorization header
        apiClient.setAuthToken(loginResponse.accessToken);
        
        final userProfile = await authDataSource.getUserProfile();
        expect(userProfile.uid, registeredUser.uid);
        
        // 4. 登出
        await authDataSource.logoutUser();
      });
    });
    
    group('Entry Management Flow', () {
      late EntryRemoteDataSourceImpl entryDataSource;
      late String authToken;
      
      setUp(() async {
        entryDataSource = EntryRemoteDataSourceImpl(apiClient: apiClient);
        
        // 登入取得Token
        final loginResponse = await authDataSource.loginUser(testLoginParams);
        authToken = loginResponse.accessToken;
        apiClient.setAuthToken(authToken);
      });
      
      test('complete entry CRUD flow should work', () async {
        // 1. 建立記帳記錄
        final createParams = CreateEntryParams(
          entryType: 'expense',
          amount: 100.0,
          subjectCode: '2003',
          subjectName: '餐飲費',
          ledgerId: 'default',
          entryDate: DateTime.now(),
          description: '午餐',
        );
        
        final createdEntry = await entryDataSource.createEntry(createParams);
        expect(createdEntry.amount, 100.0);
        expect(createdEntry.description, '午餐');
        
        // 2. 查詢記帳記錄
        final queryParams = EntryQueryParams(
          filters: EntryFiltersModel(
            entryTypes: ['expense'],
          ),
          pagination: PaginationParamsModel(page: 1, limit: 10),
        );
        
        final paginatedEntries = await entryDataSource.getEntries(queryParams);
        expect(paginatedEntries.entries, isNotEmpty);
        
        final foundEntry = paginatedEntries.entries
            .firstWhere((entry) => entry.entryId == createdEntry.entryId);
        expect(foundEntry.amount, 100.0);
        
        // 3. 更新記帳記錄
        final updateParams = UpdateEntryParams(
          amount: 120.0,
          description: '午餐 - 已更新',
        );
        
        final updatedEntry = await entryDataSource.updateEntry(
          createdEntry.entryId,
          updateParams,
        );
        expect(updatedEntry.amount, 120.0);
        expect(updatedEntry.description, '午餐 - 已更新');
        
        // 4. 刪除記帳記錄
        await entryDataSource.deleteEntry(createdEntry.entryId);
        
        // 驗證已刪除
        final queryAfterDelete = await entryDataSource.getEntries(queryParams);
        final deletedEntry = queryAfterDelete.entries
            .where((entry) => entry.entryId == createdEntry.entryId);
        expect(deletedEntry, isEmpty);
      });
    });
  });
}
```

### 11.3 Widget測試

#### 11.3.1 Provider Widget測試
```dart
// test/presentation/providers/entry_provider_test.dart
@GenerateMocks([CreateEntry, GetEntries, UpdateEntry, DeleteEntry])
void main() {
  late EntryProvider entryProvider;
  late MockCreateEntry mockCreateEntry;
  late MockGetEntries mockGetEntries;
  late MockUpdateEntry mockUpdateEntry;
  late MockDeleteEntry mockDeleteEntry;
  
  setUp(() {
    mockCreateEntry = MockCreateEntry();
    mockGetEntries = MockGetEntries();
    mockUpdateEntry = MockUpdateEntry();
    mockDeleteEntry = MockDeleteEntry();
    
    entryProvider = EntryProvider(
      createEntry: mockCreateEntry,
      getEntries: mockGetEntries,
      updateEntry: mockUpdateEntry,
      deleteEntry: mockDeleteEntry,
    );
  });
  
  group('EntryProvider', () {
    const tEntry = Entry(
      entryId: 'test_id',
      entryType: 'expense',
      amount: 100.0,
      subjectCode: '2003',
      subjectName: '餐飲費',
      ledgerId: 'default',
      entryDate: '2025-01-24T10:00:00Z',
      description: '測試記錄',
    );
    
    const tCreateParams = CreateEntryParams(
      entryType: 'expense',
      amount: 100.0,
      subjectCode: '2003',
      subjectName: '餐飲費',
      ledgerId: 'default',
      entryDate: '2025-01-24T10:00:00Z',
      description: '測試記錄',
    );
    
    test('should create entry successfully', () async {
      // arrange
      when(mockCreateEntry(any))
          .thenAnswer((_) async => const Right(tEntry));
      
      // act
      await entryProvider.createEntry(tCreateParams);
      
      // assert
      expect(entryProvider.entries, contains(tEntry));
      expect(entryProvider.isLoading, false);
      expect(entryProvider.error, null);
      verify(mockCreateEntry(tCreateParams));
    });
    
    test('should handle create entry failure', () async {
      // arrange
      const tFailure = ServerFailure('建立失敗');
      when(mockCreateEntry(any))
          .thenAnswer((_) async => const Left(tFailure));
      
      // act
      await entryProvider.createEntry(tCreateParams);
      
      // assert
      expect(entryProvider.entries, isEmpty);
      expect(entryProvider.isLoading, false);
      expect(entryProvider.error, '建立失敗');
    });
    
    test('should set loading state during create entry', () async {
      // arrange
      final completer = Completer<Either<Failure, Entry>>();
      when(mockCreateEntry(any)).thenAnswer((_) => completer.future);
      
      // act
      final future = entryProvider.createEntry(tCreateParams);
      
      // assert loading state
      expect(entryProvider.isLoading, true);
      
      // complete the operation
      completer.complete(const Right(tEntry));
      await future;
      
      expect(entryProvider.isLoading, false);
    });
  });
}
```

---

## 12.0 版本升級計畫（Version Upgrade）

### 12.1 模組版本規劃

| 模組名稱 | 當前版本 | 目標版本 | 升級內容 | 相依性 |
|----------|----------|----------|----------|--------|
| **Flutter_AP_Layer** | 新建 | v2.0.0 | 完整32個API端點整合 | 所有相關模組 |
| **AuthService** | - | v2.0.0 | F001-F005 API服務實作 | ApiClient v2.0.0 |
| **EntryService** | - | v2.0.0 | F006-F009 API服務實作 | ApiClient v2.0.0 |
| **ProjectLedgerService** | - | v2.0.0 | F010-F015 API服務實作 | ApiClient v2.0.0 |
| **BudgetService** | - | v2.0.0 | F016-F018 API服務實作 | ApiClient v2.0.0 |
| **CollaborationService** | - | v2.0.0 | F019-F021 API服務實作 | ApiClient v2.0.0 |
| **ReportService** | - | v2.0.0 | F022-F024 API服務實作 | ApiClient v2.0.0 |
| **SystemService** | - | v2.0.0 | F025-F032 API服務實作 | ApiClient v2.0.0 |

### 12.2 函數版本升級

#### 12.2.1 核心API函數版本
| API端點 | 函數名稱 | 版本 | 升級內容 |
|---------|----------|------|----------|
| F001-F005 | AuthService各方法 | v2.0.0 | 完整認證流程實作 |
| F006-F009 | EntryService各方法 | v2.0.0 | 記帳CRUD操作實作 |
| F010-F015 | ProjectLedgerService各方法 | v2.0.0 | 多帳本管理實作 |
| F016-F018 | BudgetService各方法 | v2.0.0 | 預算管理實作 |
| F019-F021 | CollaborationService各方法 | v2.0.0 | 協作功能實作 |
| F022-F024 | ReportService各方法 | v2.0.0 | 報表功能實作 |
| F025-F032 | SystemService各方法 | v2.0.0 | 系統管理實作 |

### 12.3 開發里程碑

#### 12.3.1 Phase 1: 基礎架構建立 (Week 1-2)
- ✅ Clean Architecture架構設計
- ✅ 依賴注入設定
- ✅ 統一API客戶端實作
- ✅ 錯誤處理機制建立
- ✅ 資料模型定義

#### 12.3.2 Phase 2: 核心API服務實作 (Week 3-4)
- 🔄 AuthService實作 (F001-F005)
- 🔄 EntryService實作 (F006-F009)
- 🔄 Repository Pattern實作
- 🔄 Use Cases實作
- 🔄 單元測試編寫

#### 12.3.3 Phase 3: 進階功能實作 (Week 5-6)
- ⏳ ProjectLedgerService實作 (F010-F015)
- ⏳ BudgetService實作 (F016-F018)
- ⏳ CollaborationService實作 (F019-F021)
- ⏳ WebSocket即時同步實作

#### 12.3.4 Phase 4: 系統功能與優化 (Week 7-8)
- ⏳ ReportService實作 (F022-F024)
- ⏳ SystemService實作 (F025-F032)
- ⏳ 快取策略實作
- ⏳ 離線同步機制實作
- ⏳ 效能優化實施

#### 12.3.5 Phase 5: 測試與部署 (Week 9-10)
- ⏳ 整合測試執行
- ⏳ 效能測試執行
- ⏳ 文件完善
- ⏳ 部署準備

### 12.4 向後相容性保證

#### 12.4.1 API版本相容性
```dart
// lib/core/api/api_versioning.dart
class ApiVersionManager {
  static const String currentVersion = 'v2.0.0';
  static const List<String> supportedVersions = ['v1.0.0', 'v2.0.0'];
  
  static String getApiPath(String endpoint, {String? version}) {
    final apiVersion = version ?? currentVersion;
    return '/api/$apiVersion$endpoint';
  }
  
  static bool isVersionSupported(String version) {
    return supportedVersions.contains(version);
  }
  
  // 版本遷移邏輯
  static Map<String, dynamic> migrateRequest(
    String fromVersion,
    String toVersion,
    Map<String, dynamic> requestData,
  ) {
    if (fromVersion == toVersion) return requestData;
    
    // v1.0.0 -> v2.0.0 遷移邏輯
    if (fromVersion == 'v1.0.0' && toVersion == 'v2.0.0') {
      return _migrateV1ToV2(requestData);
    }
    
    return requestData;
  }
  
  static Map<String, dynamic> _migrateV1ToV2(Map<String, dynamic> data) {
    // 實施具體的資料格式轉換邏輯
    final migratedData = Map<String, dynamic>.from(data);
    
    // 例如：時間格式轉換
    if (migratedData.containsKey('date')) {
      migratedData['entry_date'] = migratedData.remove('date');
    }
    
    return migratedData;
  }
}
```

---

## 文件維護記錄

| 版本 | 日期 | 修改者 | 修改內容 |
|------|------|--------|----------|
| **v2.0.0** | **2025-01-24** | **LCAS PM Team** | **初版建立：完整Flutter AP Layer技術規格，整合32個RESTful API端點，實作Clean Architecture、Repository Pattern、快取策略、離線同步機制、錯誤處理、效能優化等完整AP Layer功能** |

---

## 備註

- **版本2.0.0重大特色**: 完整實作32個RESTful API端點的Flutter AP Layer
- **Clean Architecture**: 採用分層架構，確保程式碼可維護性和可測試性
- **Repository Pattern**: 實作資料存取抽象層，支援本地快取和遠端API
- **快取策略**: 多層次快取機制，提升應用效能和使用者體驗
- **離線同步**: 完整離線操作支援和智慧衝突解決機制
- **錯誤處理**: 統一錯誤處理機制，提供使用者友善的錯誤訊息
- **效能優化**: 請求去重、批量處理、併發控制等效能優化策略
- **測試策略**: 完整的單元測試、整合測試和Widget測試計畫
- **技術債務**: 請參考91資料夾中的具體程式碼實作
- **API文件參考**: 請參考9205. Flutter_API list_AP layer.md文件
- **UI整合**: 配合9005. Flutter_Presentation layer.md進行前端整合
