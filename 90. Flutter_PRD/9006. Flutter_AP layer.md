
# PRD_Flutter_AP Layer

**æ–‡ä»¶ç·¨è™Ÿ**: 9006  
**ç‰ˆæœ¬**: 2.1.0  
**å»ºç«‹æ—¥æœŸ**: 2025-08-01  
**å»ºç«‹è€…**: LCAS PM Team  
**æœ€å¾Œæ›´æ–°**: 2025-08-02 07:30:00 UTC+8

---

## ç›®æ¬¡

1. [æ¨¡çµ„æ¦‚è¿°](#10-æ¨¡çµ„æ¦‚è¿°module-overview)
2. [ç³»çµ±å±¤ç´šæ¶æ§‹](#20-ç³»çµ±å±¤ç´šæ¶æ§‹system-level-architecture)
3. [AP Layeræ¨¡çµ„æ¶æ§‹](#30-ap-layeræ¨¡çµ„æ¶æ§‹ap-layer-module-architecture)
4. [ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹](#40-ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹code-organization-architecture)
5. [æ¶æ§‹é—œä¿‚å°æ‡‰](#50-æ¶æ§‹é—œä¿‚å°æ‡‰architecture-relationship-mapping)
6. [APIæœå‹™å±¤è¨­è¨ˆ](#60-apiæœå‹™å±¤è¨­è¨ˆapi-services-layer)
7. [32å€‹APIç«¯é»æ•´åˆ](#70-32å€‹apiç«¯é»æ•´åˆapi-endpoints-integration)
8. [è³‡æ–™æ¨¡å‹å®šç¾©](#80-è³‡æ–™æ¨¡å‹å®šç¾©data-models)
9. [ç‹€æ…‹ç®¡ç†ç­–ç•¥](#90-ç‹€æ…‹ç®¡ç†ç­–ç•¥state-management)
10. [éŒ¯èª¤è™•ç†æ©Ÿåˆ¶](#100-éŒ¯èª¤è™•ç†æ©Ÿåˆ¶error-handling)
11. [å¿«å–ç­–ç•¥è¨­è¨ˆ](#110-å¿«å–ç­–ç•¥è¨­è¨ˆcaching-strategy)
12. [é›¢ç·šåŒæ­¥æ©Ÿåˆ¶](#120-é›¢ç·šåŒæ­¥æ©Ÿåˆ¶offline-sync)
13. [æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](#130-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥performance-optimization)
14. [æ¸¬è©¦ç­–ç•¥](#140-æ¸¬è©¦ç­–ç•¥testing-strategy)
15. [ç‰ˆæœ¬å‡ç´šè¨ˆç•«](#150-ç‰ˆæœ¬å‡ç´šè¨ˆç•«version-upgrade)

---

## 1.0 æ¨¡çµ„æ¦‚è¿°ï¼ˆModule Overviewï¼‰

### 1.1 ç”¢å“å®šä½
Flutter AP Layerï¼ˆæ‡‰ç”¨é‚è¼¯å±¤ï¼‰æ˜¯LCAS 2.0ç³»çµ±çš„æ ¸å¿ƒä¸­ä»‹å±¤ï¼Œè² è²¬é€£æ¥Presentation Layerèˆ‡Business Layerï¼Œæ•´åˆ32å€‹RESTful APIç«¯é»ï¼Œæä¾›çµ±ä¸€çš„è³‡æ–™å­˜å–ä»‹é¢å’Œæ¥­å‹™é‚è¼¯å°è£ã€‚

### 1.2 æ ¸å¿ƒè·è²¬
- **APIæ•´åˆç®¡ç†**: å°è£32å€‹RESTful APIç«¯é»ï¼Œæä¾›é¡å‹å®‰å…¨çš„èª¿ç”¨ä»‹é¢
- **è³‡æ–™è½‰æ›è™•ç†**: è™•ç†APIæ•¸æ“šèˆ‡UIæ•¸æ“šé–“çš„æ ¼å¼è½‰æ›
- **ç‹€æ…‹ç®¡ç†å”èª¿**: ç®¡ç†æ‡‰ç”¨ç‹€æ…‹ï¼Œç¢ºä¿æ•¸æ“šä¸€è‡´æ€§
- **éŒ¯èª¤è™•ç†çµ±ä¸€**: æä¾›çµ±ä¸€çš„éŒ¯èª¤è™•ç†å’Œç”¨æˆ¶å‹å–„çš„éŒ¯èª¤è¨Šæ¯
- **å¿«å–ç­–ç•¥åŸ·è¡Œ**: å¯¦æ–½æ™ºæ…§å¿«å–ï¼Œæå‡æ‡‰ç”¨æ•ˆèƒ½
- **é›¢ç·šåŠŸèƒ½æ”¯æ´**: æ”¯æ´é›¢ç·šæ“ä½œå’Œæ•¸æ“šåŒæ­¥

### 1.3 åœ¨LCAS 2.0ç³»çµ±ä¸­çš„å®šä½
```
LCAS 2.0 ç³»çµ±æ¶æ§‹
â”œâ”€â”€ Flutter Presentation Layer (å±•ç¤ºå±¤)
â”‚   â”œâ”€â”€ UI Components â†’ ä½¿ç”¨è€…ä»‹é¢å…ƒä»¶
â”‚   â”œâ”€â”€ Screens & Views â†’ ç•«é¢èˆ‡è¦–åœ–
â”‚   â””â”€â”€ User Interactions â†’ ä½¿ç”¨è€…äº’å‹•
â”œâ”€â”€ Flutter AP Layer (æ‡‰ç”¨é‚è¼¯å±¤) â˜… æœ¬æ–‡ä»¶ç¯„åœ â˜…
â”‚   â”œâ”€â”€ 32å€‹APIç«¯é» â†’ F001-F032
â”‚   â”œâ”€â”€ State Management â†’ ç‹€æ…‹ç®¡ç†
â”‚   â”œâ”€â”€ Data Transformation â†’ è³‡æ–™è½‰æ›
â”‚   â””â”€â”€ Cache Management â†’ å¿«å–ç®¡ç†
â”œâ”€â”€ Business Layer (å•†æ¥­é‚è¼¯å±¤)
â”‚   â”œâ”€â”€ API Integration â†’ APIæ•´åˆæœå‹™
â”‚   â””â”€â”€ Business Logic â†’ å•†æ¥­é‚è¼¯
â””â”€â”€ Firestore Database (è³‡æ–™å±¤)
    â”œâ”€â”€ Collections â†’ è³‡æ–™é›†åˆ
    â”œâ”€â”€ Documents â†’ æ–‡ä»¶è³‡æ–™
    â””â”€â”€ Security Rules â†’ å®‰å…¨è¦å‰‡
```

---

## 2.0 ç³»çµ±å±¤ç´šæ¶æ§‹ï¼ˆSystem Level Architectureï¼‰

### 2.1 LCAS 2.0ç³»çµ±æ¶æ§‹æ¦‚è¦½

Flutter AP Layeråœ¨æ•´å€‹LCAS 2.0ç³»çµ±ä¸­æ‰®æ¼”**æ‡‰ç”¨é‚è¼¯å±¤**çš„è§’è‰²ï¼Œè² è²¬é€£æ¥å‰ç«¯å±•ç¤ºå±¤èˆ‡å¾Œç«¯å•†æ¥­é‚è¼¯å±¤ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Flutter Presentation Layer       â”‚  â† 9005æ–‡ä»¶ç¯„åœ
â”‚    (UI Components, Screens, Views)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ Widget Events & State Updates
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Flutter AP Layer â˜…              â”‚  â† 9006æ–‡ä»¶ç¯„åœ
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚       7å¤§æœå‹™ç¾¤çµ„ (F001-F032)        â”‚ â”‚
â”‚  â”‚ AuthService | EntryService | ...    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Repository & Use Cases Pattern    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     Cache & Offline Management      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ HTTP/HTTPS Requests
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         RESTful API Layer               â”‚  â† 6001æ–‡ä»¶ç¯„åœ
â”‚         (32å€‹APIç«¯é»)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ Database Operations
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Firestore Database             â”‚  â† 6002æ–‡ä»¶ç¯„åœ
â”‚       (Collections & Documents)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 è³‡æ–™æµå‘èˆ‡è·è²¬åˆ†é›¢

#### 2.2.1 å‘ä¸Šè³‡æ–™æµï¼ˆå¾€Presentation Layerï¼‰
- **ç‹€æ…‹æ›´æ–°**: Provider/Riverpodç‹€æ…‹è®Šæ›´
- **äº‹ä»¶å›èª¿**: æ“ä½œçµæœé€šçŸ¥
- **éŒ¯èª¤è™•ç†**: ä½¿ç”¨è€…å‹å–„çš„éŒ¯èª¤è¨Šæ¯

#### 2.2.2 å‘ä¸‹è³‡æ–™æµï¼ˆå¾€Business Layerï¼‰
- **APIè«‹æ±‚**: RESTful HTTPè«‹æ±‚
- **è³‡æ–™é©—è­‰**: è«‹æ±‚åƒæ•¸é©—è­‰
- **èªè­‰ç®¡ç†**: JWT Tokenè‡ªå‹•é™„åŠ 

#### 2.2.3 æ©«å‘è³‡æ–™æµï¼ˆAP Layerå…§éƒ¨ï¼‰
- **æœå‹™å”ä½œ**: 7å¤§æœå‹™ç¾¤çµ„é–“çš„å”èª¿
- **å¿«å–ç®¡ç†**: æœ¬åœ°è³‡æ–™å¿«å–èˆ‡åŒæ­¥
- **ç‹€æ…‹åŒæ­¥**: å…¨åŸŸç‹€æ…‹èˆ‡å€åŸŸç‹€æ…‹åŒæ­¥

---

## 3.0 AP Layeræ¨¡çµ„æ¶æ§‹ï¼ˆAP Layer Module Architectureï¼‰

### 3.1 åŠŸèƒ½æ€§åˆ†å±¤æ¶æ§‹

AP Layerå…§éƒ¨æ¡ç”¨åŠŸèƒ½æ€§åˆ†å±¤ï¼ŒåŒ…å«7å¤§æœå‹™ç¾¤çµ„å°æ‡‰32å€‹APIç«¯é»ï¼š

```
Flutter AP Layer åŠŸèƒ½æ€§æ¶æ§‹
â”œâ”€â”€ ğŸ“ èªè­‰ç®¡ç†ç¾¤çµ„ (F001-F005)
â”‚   â”œâ”€â”€ F001: ä½¿ç”¨è€…è¨»å†Š â†’ AuthService.registerUser()
â”‚   â”œâ”€â”€ F002: ä½¿ç”¨è€…ç™»å…¥ â†’ AuthService.loginUser()
â”‚   â”œâ”€â”€ F003: ä½¿ç”¨è€…ç™»å‡º â†’ AuthService.logoutUser()
â”‚   â”œâ”€â”€ F004: å¸³è™Ÿåˆªé™¤ â†’ AuthService.deleteAccount()
â”‚   â””â”€â”€ F005: å¯†ç¢¼é‡è¨­ â†’ AuthService.resetPassword()
â”œâ”€â”€ ğŸ“ åŸºç¤è¨˜å¸³ç¾¤çµ„ (F006-F009)
â”‚   â”œâ”€â”€ F006: æ–°å¢è¨˜å¸³è¨˜éŒ„ â†’ EntryService.createEntry()
â”‚   â”œâ”€â”€ F007: å¿«é€Ÿè¨˜å¸³ â†’ EntryService.quickEntry()
â”‚   â”œâ”€â”€ F008: æŸ¥è©¢è¨˜å¸³æ­·å² â†’ EntryService.getEntries()
â”‚   â””â”€â”€ F009: è¨˜å¸³è¨˜éŒ„ç®¡ç† â†’ EntryService.updateEntry() / deleteEntry()
â”œâ”€â”€ ğŸ“Š å¤šå¸³æœ¬ç®¡ç†ç¾¤çµ„ (F010-F015)
â”‚   â”œâ”€â”€ F010-F011: å°ˆæ¡ˆç®¡ç† â†’ ProjectLedgerService.createProject()
â”‚   â”œâ”€â”€ F012-F013: å¸³æœ¬åˆ‡æ› â†’ ProjectLedgerService.switchLedger()
â”‚   â””â”€â”€ F014-F015: æˆå“¡ç®¡ç† â†’ ProjectLedgerService.manageMembers()
â”œâ”€â”€ ğŸ’° é ç®—ç®¡ç†ç¾¤çµ„ (F016-F018)
â”‚   â”œâ”€â”€ F016: é ç®—è¨­å®š â†’ BudgetService.createBudget()
â”‚   â”œâ”€â”€ F017: é ç®—é€²åº¦ â†’ BudgetService.getBudgetProgress()
â”‚   â””â”€â”€ F018: é ç®—æé†’ â†’ BudgetService.setBudgetAlerts()
â”œâ”€â”€ ğŸ¤ å”ä½œåŠŸèƒ½ç¾¤çµ„ (F019-F021)
â”‚   â”œâ”€â”€ F019: å…±äº«å¸³æœ¬ â†’ CollaborationService.createSharedLedger()
â”‚   â”œâ”€â”€ F020: æ¬Šé™ç®¡ç† â†’ CollaborationService.setMemberPermissions()
â”‚   â””â”€â”€ F021: å³æ™‚åŒæ­¥ â†’ CollaborationService.realtimeSync()
â”œâ”€â”€ ğŸ“ˆ å ±è¡¨åŠŸèƒ½ç¾¤çµ„ (F022-F024)
â”‚   â”œâ”€â”€ F022: å ±è¡¨ç”Ÿæˆ â†’ ReportService.generateReport()
â”‚   â”œâ”€â”€ F023: è‡ªè¨‚å ±è¡¨ â†’ ReportService.createCustomReport()
â”‚   â””â”€â”€ F024: å ±è¡¨åŒ¯å‡º â†’ ReportService.exportReport()
â””â”€â”€ ğŸ”§ ç³»çµ±ç®¡ç†ç¾¤çµ„ (F025-F032)
    â”œâ”€â”€ F025-F027: å‚™ä»½ç®¡ç† â†’ SystemService.scheduleBackup()
    â”œâ”€â”€ F028-F029: åŒæ­¥ç®¡ç† â†’ SystemService.checkSyncStatus()
    â”œâ”€â”€ F030: ç³»çµ±å¥åº· â†’ SystemService.getSystemHealth()
    â”œâ”€â”€ F031: éŒ¯èª¤æ—¥èªŒ â†’ SystemService.getErrorLogs()
    â””â”€â”€ F032: æé†’åŠŸèƒ½ â†’ SystemService.createReminder()
```

### 3.2 æœå‹™ç¾¤çµ„è·è²¬çŸ©é™£

| æœå‹™ç¾¤çµ„ | ä¸»è¦è·è²¬ | APIç«¯é»æ•¸é‡ | æ ¸å¿ƒåŠŸèƒ½ | ç›¸ä¾æ€§ |
|----------|----------|-------------|----------|--------|
| **AuthService** | èªè­‰æˆæ¬Šç®¡ç† | 5å€‹ (F001-F005) | ç™»å…¥è¨»å†Šã€æ¬Šé™é©—è­‰ | ç¨ç«‹æœå‹™ |
| **EntryService** | è¨˜å¸³æ ¸å¿ƒåŠŸèƒ½ | 4å€‹ (F006-F009) | CRUDè¨˜å¸³è¨˜éŒ„ | ä¾è³´AuthService |
| **ProjectLedgerService** | å¤šå¸³æœ¬ç®¡ç† | 6å€‹ (F010-F015) | å°ˆæ¡ˆå¸³æœ¬ã€æˆå“¡ç®¡ç† | ä¾è³´AuthService |
| **BudgetService** | é ç®—ç®¡ç† | 3å€‹ (F016-F018) | é ç®—è¨­å®šã€é€²åº¦è¿½è¹¤ | ä¾è³´EntryService |
| **CollaborationService** | å”ä½œåŠŸèƒ½ | 3å€‹ (F019-F021) | å…±äº«ã€æ¬Šé™ã€åŒæ­¥ | ä¾è³´ProjectLedgerService |
| **ReportService** | å ±è¡¨åŠŸèƒ½ | 3å€‹ (F022-F024) | å ±è¡¨ç”Ÿæˆã€åˆ†æã€åŒ¯å‡º | ä¾è³´EntryService |
| **SystemService** | ç³»çµ±ç®¡ç† | 8å€‹ (F025-F032) | å‚™ä»½ã€æ—¥èªŒã€æé†’ | ä¾è³´æ‰€æœ‰æœå‹™ |

---

## 4.0 ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹ï¼ˆCode Organization Architectureï¼‰

### 4.1 Clean Architectureå¯¦ä½œçµæ§‹

AP Layeræ¡ç”¨Clean Architectureæ¨¡å¼ï¼Œç¢ºä¿ç¨‹å¼ç¢¼çš„å¯ç¶­è­·æ€§å’Œå¯æ¸¬è©¦æ€§ï¼š

```dart
lib/  â† Flutter AP Layer ç¨‹å¼ç¢¼æ ¹ç›®éŒ„
â”œâ”€â”€ core/  â† ğŸ—ï¸ åŸºç¤è¨­æ–½å±¤ (Infrastructure Layer)
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ api_client.dart          â†’ çµ±ä¸€APIå®¢æˆ¶ç«¯
â”‚   â”‚   â”œâ”€â”€ api_interceptors.dart    â†’ è«‹æ±‚æ””æˆªå™¨
â”‚   â”‚   â””â”€â”€ api_endpoints.dart       â†’ APIç«¯é»å®šç¾© (F001-F032)
â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”œâ”€â”€ cache_manager.dart       â†’ å¿«å–ç®¡ç†å™¨
â”‚   â”‚   â””â”€â”€ cache_strategies.dart    â†’ å¿«å–ç­–ç•¥
â”‚   â”œâ”€â”€ error/
â”‚   â”‚   â”œâ”€â”€ app_exceptions.dart      â†’ æ‡‰ç”¨ç•°å¸¸å®šç¾©
â”‚   â”‚   â””â”€â”€ error_handler.dart       â†’ éŒ¯èª¤è™•ç†å™¨
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â”œâ”€â”€ network_info.dart        â†’ ç¶²è·¯ç‹€æ…‹æª¢æ¸¬
â”‚   â”‚   â””â”€â”€ connectivity_service.dart â†’ é€£ç·šæœå‹™
â”‚   â””â”€â”€ di/
â”‚       â””â”€â”€ service_locator.dart     â†’ ä¾è³´æ³¨å…¥è¨­å®š
â”œâ”€â”€ data/  â† ğŸ“Š è³‡æ–™å±¤ (Data Layer)
â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”œâ”€â”€ remote/  â† ğŸŒ 7å¤§æœå‹™ç¾¤çµ„çš„é ç«¯è³‡æ–™æº
â”‚   â”‚   â”‚   â”œâ”€â”€ auth_remote_datasource.dart          â†’ F001-F005
â”‚   â”‚   â”‚   â”œâ”€â”€ entry_remote_datasource.dart         â†’ F006-F009
â”‚   â”‚   â”‚   â”œâ”€â”€ project_ledger_remote_datasource.dart â†’ F010-F015
â”‚   â”‚   â”‚   â”œâ”€â”€ budget_remote_datasource.dart        â†’ F016-F018
â”‚   â”‚   â”‚   â”œâ”€â”€ collaboration_remote_datasource.dart â†’ F019-F021
â”‚   â”‚   â”‚   â”œâ”€â”€ report_remote_datasource.dart        â†’ F022-F024
â”‚   â”‚   â”‚   â””â”€â”€ system_remote_datasource.dart        â†’ F025-F032
â”‚   â”‚   â””â”€â”€ local/  â† ğŸ’¾ æœ¬åœ°å¿«å–è³‡æ–™æº
â”‚   â”‚       â”œâ”€â”€ auth_local_datasource.dart
â”‚   â”‚       â”œâ”€â”€ entry_local_datasource.dart
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ models/  â† ğŸ“‹ è³‡æ–™å‚³è¼¸ç‰©ä»¶ (DTO)
â”‚   â”‚   â”œâ”€â”€ user_model.dart
â”‚   â”‚   â”œâ”€â”€ entry_model.dart
â”‚   â”‚   â”œâ”€â”€ project_model.dart
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ repositories/  â† ğŸ”„ Repositoryå¯¦ä½œ
â”‚       â”œâ”€â”€ auth_repository_impl.dart
â”‚       â”œâ”€â”€ entry_repository_impl.dart
â”‚       â””â”€â”€ ...
â”œâ”€â”€ domain/  â† ğŸ¯ é ˜åŸŸå±¤ (Domain Layer)
â”‚   â”œâ”€â”€ entities/  â† ğŸ’ æ¥­å‹™å¯¦é«”
â”‚   â”‚   â”œâ”€â”€ user.dart
â”‚   â”‚   â”œâ”€â”€ entry.dart
â”‚   â”‚   â”œâ”€â”€ project.dart
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ repositories/  â† ğŸ“œ RepositoryæŠ½è±¡ä»‹é¢
â”‚   â”‚   â”œâ”€â”€ auth_repository.dart
â”‚   â”‚   â”œâ”€â”€ entry_repository.dart
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ usecases/  â† âš™ï¸ æ¥­å‹™ç”¨ä¾‹ (Use Cases)
â”‚       â”œâ”€â”€ auth/
â”‚       â”‚   â”œâ”€â”€ login_user.dart      â†’ F002 ç™»å…¥ç”¨ä¾‹
â”‚       â”‚   â”œâ”€â”€ register_user.dart   â†’ F001 è¨»å†Šç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â”œâ”€â”€ entry/
â”‚       â”‚   â”œâ”€â”€ create_entry.dart    â†’ F006 æ–°å¢è¨˜å¸³ç”¨ä¾‹
â”‚       â”‚   â”œâ”€â”€ get_entries.dart     â†’ F008 æŸ¥è©¢è¨˜å¸³ç”¨ä¾‹
â”‚       â”‚   â””â”€â”€ ...
â”‚       â””â”€â”€ ...
â””â”€â”€ presentation/  â† ğŸ¨ å±•ç¤ºå±¤æ¥å£ (èˆ‡9005æ–‡ä»¶çš„éŠœæ¥é»)
    â”œâ”€â”€ providers/  â† ğŸ”„ ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ auth_provider.dart       â†’ èªè­‰ç‹€æ…‹ç®¡ç†
    â”‚   â”œâ”€â”€ entry_provider.dart      â†’ è¨˜å¸³ç‹€æ…‹ç®¡ç†
    â”‚   â””â”€â”€ ...
    â””â”€â”€ widgets/  â† ğŸ§© å…±ç”¨UIå…ƒä»¶ (ç”±9005æ–‡ä»¶è©³ç´°å®šç¾©)
        â”œâ”€â”€ common/
        â””â”€â”€ ...
```

### 4.2 ä¾è³´æ–¹å‘èˆ‡åŸå‰‡

Clean Architectureçš„ä¾è³´è¦å‰‡åœ¨AP Layerä¸­çš„å¯¦ä½œï¼š

```
ğŸ¨ Presentation â”€â”€ä¾è³´â”€â”€â–º ğŸ¯ Domain â—„â”€â”€å¯¦ä½œâ”€â”€ ğŸ“Š Data
     â”‚                      â–²                    â”‚
     â””â”€â”€â”€â”€â”€â”€ä¾è³´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
                                                 â–¼
                                            ğŸ—ï¸ Core
                                         (Infrastructure)
```

**ä¾è³´åŸå‰‡**ï¼š
- **Presentation Layer**: ä¾è³´Domainçš„Use Caseså’ŒEntities
- **Data Layer**: å¯¦ä½œDomainçš„Repositoryä»‹é¢
- **Domain Layer**: å®Œå…¨ç¨ç«‹ï¼Œä¸ä¾è³´ä»»ä½•å¤–éƒ¨å±¤
- **Core Layer**: è¢«æ‰€æœ‰å±¤å…±ç”¨ï¼Œæä¾›åŸºç¤è¨­æ–½

---

## 5.0 æ¶æ§‹é—œä¿‚å°æ‡‰ï¼ˆArchitecture Relationship Mappingï¼‰

### 5.1 ä¸‰å±¤æ¶æ§‹å°æ‡‰é—œä¿‚

ä»¥ä¸‹è¡¨æ ¼èªªæ˜**ç³»çµ±å±¤ç´šæ¶æ§‹**ã€**æ¨¡çµ„åŠŸèƒ½æ¶æ§‹**ã€**ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹**ä¹‹é–“çš„å°æ‡‰é—œä¿‚ï¼š

| ç³»çµ±å±¤ç´šæ¶æ§‹ | æ¨¡çµ„åŠŸèƒ½æ¶æ§‹ | ç¨‹å¼ç¢¼çµ„ç¹”æ¶æ§‹ | èªªæ˜ |
|-------------|-------------|---------------|------|
| **Flutter AP Layer** | **7å¤§æœå‹™ç¾¤çµ„** | **lib/** | æ•´å€‹AP Layerçš„ç¯„åœ |
| â†³ Business Logic | â†³ AuthService (F001-F005) | â†³ data/datasources/remote/auth_remote_datasource.dart | èªè­‰æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ EntryService (F006-F009) | â†³ data/datasources/remote/entry_remote_datasource.dart | è¨˜å¸³æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ ProjectLedgerService (F010-F015) | â†³ data/datasources/remote/project_ledger_remote_datasource.dart | å¤šå¸³æœ¬æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ BudgetService (F016-F018) | â†³ data/datasources/remote/budget_remote_datasource.dart | é ç®—æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ CollaborationService (F019-F021) | â†³ data/datasources/remote/collaboration_remote_datasource.dart | å”ä½œæœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ ReportService (F022-F024) | â†³ data/datasources/remote/report_remote_datasource.dart | å ±è¡¨æœå‹™å¯¦ä½œ |
| â†³ Business Logic | â†³ SystemService (F025-F032) | â†³ data/datasources/remote/system_remote_datasource.dart | ç³»çµ±æœå‹™å¯¦ä½œ |
| â†³ API Integration | â†³ HTTP Client | â†³ core/api/api_client.dart | çµ±ä¸€APIå®¢æˆ¶ç«¯ |
| â†³ State Management | â†³ Repository Pattern | â†³ domain/repositories/ + data/repositories/ | è³‡æ–™å­˜å–æŠ½è±¡ |
| â†³ Data Transformation | â†³ Data Models | â†³ data/models/ + domain/entities/ | è³‡æ–™æ¨¡å‹è½‰æ› |
| â†³ Cache Management | â†³ Cache Strategies | â†³ core/cache/ + data/datasources/local/ | å¿«å–ç®¡ç† |

### 5.2 APIç«¯é»åˆ°ç¨‹å¼ç¢¼çš„å°æ‡‰

#### 5.2.1 èªè­‰ç®¡ç†ç¾¤çµ„ (F001-F005) å°æ‡‰
```
F001 ä½¿ç”¨è€…è¨»å†Š â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.registerUser()
                   â”œâ”€â”€ domain/usecases/auth/register_user.dart
                   â”œâ”€â”€ data/repositories/auth_repository_impl.dart
                   â””â”€â”€ presentation/providers/auth_provider.dart

F002 ä½¿ç”¨è€…ç™»å…¥ â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.loginUser()
F003 ä½¿ç”¨è€…ç™»å‡º â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.logoutUser()
F004 å¸³è™Ÿåˆªé™¤   â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.deleteAccount()
F005 å¯†ç¢¼é‡è¨­   â”€â”€å°æ‡‰â”€â”€â–º auth_remote_datasource.dart.resetPassword()
```

#### 5.2.2 åŸºç¤è¨˜å¸³ç¾¤çµ„ (F006-F009) å°æ‡‰
```
F006 æ–°å¢è¨˜å¸³è¨˜éŒ„ â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.createEntry()
F007 å¿«é€Ÿè¨˜å¸³     â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.quickEntry()
F008 æŸ¥è©¢è¨˜å¸³æ­·å² â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.getEntries()
F009 è¨˜å¸³è¨˜éŒ„ç®¡ç† â”€â”€å°æ‡‰â”€â”€â–º entry_remote_datasource.dart.updateEntry()
                           â””â”€â”€ entry_remote_datasource.dart.deleteEntry()
```

#### 5.2.3 å…¶ä»–æœå‹™ç¾¤çµ„é¡ä¼¼å°æ‡‰...

### 5.3 7å¤§æœå‹™ç¾¤çµ„åœ¨Clean Architectureä¸­çš„å®šä½

å›ç­”ä½¿ç”¨è€…çš„æ ¸å¿ƒå•é¡Œï¼š**7å¤§æœå‹™ç¾¤çµ„åœ¨åˆ†å±¤æ¶æ§‹è¨­è¨ˆçš„å“ªè£¡ï¼Ÿ**

```
Clean Architectureåˆ†å±¤æ¶æ§‹
â”‚
â”œâ”€â”€ ğŸ¯ Domain Layer (é ˜åŸŸå±¤)
â”‚   â”œâ”€â”€ entities/ â†’ æ¥­å‹™å¯¦é«”å®šç¾©
â”‚   â”œâ”€â”€ repositories/ â†’ RepositoryæŠ½è±¡ä»‹é¢
â”‚   â””â”€â”€ usecases/ â†’ æ¥­å‹™ç”¨ä¾‹å¯¦ä½œ â˜… 7å¤§æœå‹™ç¾¤çµ„çš„æ¥­å‹™é‚è¼¯åœ¨é€™è£¡ â˜…
â”‚       â”œâ”€â”€ auth/ â†’ AuthServiceçš„Use Cases
â”‚       â”œâ”€â”€ entry/ â†’ EntryServiceçš„Use Cases
â”‚       â”œâ”€â”€ project_ledger/ â†’ ProjectLedgerServiceçš„Use Cases
â”‚       â”œâ”€â”€ budget/ â†’ BudgetServiceçš„Use Cases
â”‚       â”œâ”€â”€ collaboration/ â†’ CollaborationServiceçš„Use Cases
â”‚       â”œâ”€â”€ report/ â†’ ReportServiceçš„Use Cases
â”‚       â””â”€â”€ system/ â†’ SystemServiceçš„Use Cases
â”‚
â”œâ”€â”€ ğŸ“Š Data Layer (è³‡æ–™å±¤)
â”‚   â””â”€â”€ datasources/remote/ â˜… 7å¤§æœå‹™ç¾¤çµ„çš„APIèª¿ç”¨åœ¨é€™è£¡ â˜…
â”‚       â”œâ”€â”€ auth_remote_datasource.dart â†’ AuthService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ entry_remote_datasource.dart â†’ EntryService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ project_ledger_remote_datasource.dart â†’ ProjectLedgerService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ budget_remote_datasource.dart â†’ BudgetService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ collaboration_remote_datasource.dart â†’ CollaborationService APIå¯¦ä½œ
â”‚       â”œâ”€â”€ report_remote_datasource.dart â†’ ReportService APIå¯¦ä½œ
â”‚       â””â”€â”€ system_remote_datasource.dart â†’ SystemService APIå¯¦ä½œ
â”‚
â””â”€â”€ ğŸ¨ Presentation Layer (å±•ç¤ºæ¥å£å±¤)
    â””â”€â”€ providers/ â˜… 7å¤§æœå‹™ç¾¤çµ„çš„ç‹€æ…‹ç®¡ç†åœ¨é€™è£¡ â˜…
        â”œâ”€â”€ auth_provider.dart â†’ AuthServiceç‹€æ…‹ç®¡ç†
        â”œâ”€â”€ entry_provider.dart â†’ EntryServiceç‹€æ…‹ç®¡ç†
        â””â”€â”€ ... (å…¶ä»–Provider)
```

**ç¸½çµå›ç­”**ï¼š
1. **7å¤§æœå‹™ç¾¤çµ„çš„æ¥­å‹™é‚è¼¯** â†’ `domain/usecases/` ç›®éŒ„
2. **7å¤§æœå‹™ç¾¤çµ„çš„APIèª¿ç”¨** â†’ `data/datasources/remote/` ç›®éŒ„  
3. **7å¤§æœå‹™ç¾¤çµ„çš„ç‹€æ…‹ç®¡ç†** â†’ `presentation/providers/` ç›®éŒ„

### 5.4 ä¾è³´æ³¨å…¥è¨­è¨ˆ
```dart
// lib/core/di/service_locator.dart
import 'package:get_it/get_it.dart';

final GetIt sl = GetIt.instance;

Future<void> init() async {
  // API Servicesè¨»å†Š
  sl.registerLazySingleton<ApiClient>(() => ApiClient(sl()));
  sl.registerLazySingleton<AuthService>(() => AuthService(sl()));
  sl.registerLazySingleton<EntryService>(() => EntryService(sl()));
  sl.registerLazySingleton<ProjectLedgerService>(() => ProjectLedgerService(sl()));
  sl.registerLazySingleton<BudgetService>(() => BudgetService(sl()));
  sl.registerLazySingleton<CollaborationService>(() => CollaborationService(sl()));
  sl.registerLazySingleton<ReportService>(() => ReportService(sl()));
  sl.registerLazySingleton<SystemService>(() => SystemService(sl()));
  
  // Repositoryè¨»å†Š
  sl.registerLazySingleton<AuthRepository>(() => AuthRepositoryImpl(sl(), sl()));
  sl.registerLazySingleton<EntryRepository>(() => EntryRepositoryImpl(sl(), sl()));
  
  // Use Casesè¨»å†Š
  sl.registerLazySingleton(() => LoginUser(sl()));
  sl.registerLazySingleton(() => CreateEntry(sl()));
  
  // åŸºç¤è¨­æ–½è¨»å†Š
  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(sl()));
  sl.registerLazySingleton<CacheManager>(() => CacheManagerImpl());
}
```

### 2.2 Repository Pattern å¯¦ä½œ

#### 2.2.1 Repositoryä»‹é¢å®šç¾©
```dart
// lib/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Future<Either<Failure, User>> registerUser(RegisterUserParams params);
  Future<Either<Failure, LoginResponse>> loginUser(LoginUserParams params);
  Future<Either<Failure, User>> getUserProfile();
  Future<Either<Failure, User>> updateUserProfile(UpdateUserParams params);
  Future<Either<Failure, void>> logoutUser();
}
```

#### 2.2.2 Repositoryå¯¦ä½œ
```dart
// lib/data/repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;
  final NetworkInfo networkInfo;

  AuthRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
    required this.networkInfo,
  });

  @override
  Future<Either<Failure, User>> registerUser(RegisterUserParams params) async {
    try {
      if (await networkInfo.isConnected) {
        final result = await remoteDataSource.registerUser(params);
        await localDataSource.cacheUser(result);
        return Right(result);
      } else {
        return Left(NetworkFailure('ç¶²è·¯é€£ç·šç•°å¸¸'));
      }
    } on ServerException {
      return Left(ServerFailure('ä¼ºæœå™¨éŒ¯èª¤'));
    } on CacheException {
      return Left(CacheFailure('æœ¬åœ°å„²å­˜éŒ¯èª¤'));
    }
  }
}
```

---

## 6.0 APIæœå‹™å±¤è¨­è¨ˆï¼ˆAPI Services Layerï¼‰

### 3.1 çµ±ä¸€APIå®¢æˆ¶ç«¯è¨­è¨ˆ

#### 3.1.1 APIå®¢æˆ¶ç«¯æ ¸å¿ƒå¯¦ä½œ
```dart
// lib/core/api/api_client.dart
class ApiClient {
  static const String baseUrl = 'https://lcas-api.replit.app/api/v1';
  late final Dio _dio;
  
  ApiClient() {
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ));
    
    _setupInterceptors();
  }
  
  void _setupInterceptors() {
    _dio.interceptors.addAll([
      AuthInterceptor(), // JWT Tokenè‡ªå‹•ç®¡ç†
      LoggingInterceptor(), // è«‹æ±‚/å›æ‡‰æ—¥èªŒ
      CacheInterceptor(), // å¿«å–è™•ç†
      ErrorInterceptor(), // éŒ¯èª¤è™•ç†
    ]);
  }
}
```

#### 3.1.2 JWT Tokenè‡ªå‹•ç®¡ç†
```dart
// lib/core/api/auth_interceptor.dart
class AuthInterceptor extends Interceptor {
  final TokenRepository _tokenRepository;
  
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    final token = _tokenRepository.getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }
  
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode == 401) {
      // TokenéæœŸï¼Œå˜—è©¦åˆ·æ–°
      final refreshed = await _refreshToken();
      if (refreshed) {
        // é‡è©¦åŸå§‹è«‹æ±‚
        final response = await _retry(err.requestOptions);
        handler.resolve(response);
        return;
      }
      // åˆ·æ–°å¤±æ•—ï¼Œæ¸…é™¤Tokenä¸¦å°å‘ç™»å…¥
      await _tokenRepository.clearTokens();
      NavigationService.pushAndClearStack('/login');
    }
    handler.next(err);
  }
}
```

### 3.2 APIç«¯é»å®šç¾©

#### 3.2.1 APIç«¯é»å¸¸æ•¸å®šç¾©
```dart
// lib/core/api/api_endpoints.dart
class ApiEndpoints {
  // èªè­‰ç®¡ç†ç¾¤çµ„ (F001-F005)
  static const String registerUser = '/auth/register';
  static const String loginUser = '/auth/login';
  static const String getUserProfile = '/auth/user';
  static const String updateUserProfile = '/auth/user';
  static const String logoutUser = '/auth/logout';
  
  // åŸºç¤è¨˜å¸³ç¾¤çµ„ (F006-F009)
  static const String createEntry = '/entries';
  static const String quickEntry = '/entries/quick';
  static const String getEntries = '/entries';
  static const String updateEntry = '/entries/{id}';
  static const String deleteEntry = '/entries/{id}';
  
  // å¤šå¸³æœ¬ç®¡ç†ç¾¤çµ„ (F010-F015)
  static const String createProject = '/projects';
  static const String getProjects = '/projects';
  static const String updateProject = '/projects/{id}';
  static const String deleteProject = '/projects/{id}';
  static const String getProjectMembers = '/projects/{id}/members';
  static const String switchLedger = '/ledgers/switch';
  
  // é ç®—ç®¡ç†ç¾¤çµ„ (F016-F018)
  static const String createBudget = '/budgets';
  static const String getBudgetProgress = '/budgets/{id}/progress';
  static const String setBudgetAlerts = '/budgets/{id}/alerts';
  
  // å”ä½œåŠŸèƒ½ç¾¤çµ„ (F019-F021)
  static const String createSharedLedger = '/shared/ledgers';
  static const String setMemberPermissions = '/shared/ledgers/{id}/permissions';
  static const String realtimeSync = '/sync/realtime'; // WebSocket
  
  // å ±è¡¨åŠŸèƒ½ç¾¤çµ„ (F022-F024)
  static const String generateReport = '/reports/generate';
  static const String createCustomReport = '/reports/custom';
  static const String exportReport = '/reports/{id}/export';
  
  // ç³»çµ±ç®¡ç†ç¾¤çµ„ (F025-F032)
  static const String scheduleBackup = '/system/backup/schedule';
  static const String manualBackup = '/backups/manual';
  static const String listBackups = '/backups';
  static const String checkSyncStatus = '/system/sync/status';
  static const String systemHealth = '/system/health';
  static const String errorLogs = '/system/logs/errors';
  static const String createReminder = '/reminders';
  static const String executeReminder = '/reminders/execute';
}
```

---

## 7.0 32å€‹APIç«¯é»æ•´åˆï¼ˆAPI Endpoints Integrationï¼‰

### 4.1 èªè­‰ç®¡ç†æœå‹™ (F001-F005)

#### 4.1.1 AuthServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/auth_remote_datasource.dart
abstract class AuthRemoteDataSource {
  Future<UserModel> registerUser(RegisterUserParams params);
  Future<LoginResponseModel> loginUser(LoginUserParams params);
  Future<UserModel> getUserProfile();
  Future<UserModel> updateUserProfile(UpdateUserParams params);
  Future<void> logoutUser();
}

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final ApiClient apiClient;
  
  AuthRemoteDataSourceImpl({required this.apiClient});
  
  @override
  Future<UserModel> registerUser(RegisterUserParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.registerUser,
      data: params.toJson(),
    );
    return UserModel.fromJson(response.data);
  }
  
  @override
  Future<LoginResponseModel> loginUser(LoginUserParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.loginUser,
      data: params.toJson(),
    );
    return LoginResponseModel.fromJson(response.data);
  }
  
  @override
  Future<UserModel> getUserProfile() async {
    final response = await apiClient.get(ApiEndpoints.getUserProfile);
    return UserModel.fromJson(response.data);
  }
  
  @override
  Future<UserModel> updateUserProfile(UpdateUserParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateUserProfile,
      data: params.toJson(),
    );
    return UserModel.fromJson(response.data);
  }
  
  @override
  Future<void> logoutUser() async {
    await apiClient.post(ApiEndpoints.logoutUser);
  }
}
```

### 4.2 åŸºç¤è¨˜å¸³æœå‹™ (F006-F009)

#### 4.2.1 EntryServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/entry_remote_datasource.dart
class EntryRemoteDataSourceImpl implements EntryRemoteDataSource {
  final ApiClient apiClient;
  
  EntryRemoteDataSourceImpl({required this.apiClient});
  
  @override
  Future<EntryModel> createEntry(CreateEntryParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createEntry,
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }
  
  @override
  Future<EntryModel> quickEntry(QuickEntryParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.quickEntry,
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }
  
  @override
  Future<PaginatedEntriesModel> getEntries(EntryQueryParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.getEntries,
      queryParameters: params.toJson(),
    );
    return PaginatedEntriesModel.fromJson(response.data);
  }
  
  @override
  Future<EntryModel> updateEntry(String id, UpdateEntryParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateEntry.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return EntryModel.fromJson(response.data);
  }
  
  @override
  Future<void> deleteEntry(String id) async {
    await apiClient.delete(ApiEndpoints.deleteEntry.replaceAll('{id}', id));
  }
}
```

### 4.3 å¤šå¸³æœ¬ç®¡ç†æœå‹™ (F010-F015)

#### 4.3.1 ProjectLedgerServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/project_ledger_remote_datasource.dart
class ProjectLedgerRemoteDataSourceImpl implements ProjectLedgerRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<ProjectModel> createProject(CreateProjectParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createProject,
      data: params.toJson(),
    );
    return ProjectModel.fromJson(response.data);
  }
  
  @override
  Future<List<ProjectModel>> getProjects() async {
    final response = await apiClient.get(ApiEndpoints.getProjects);
    return (response.data['projects'] as List)
        .map((json) => ProjectModel.fromJson(json))
        .toList();
  }
  
  @override
  Future<ProjectModel> updateProject(String id, UpdateProjectParams params) async {
    final response = await apiClient.put(
      ApiEndpoints.updateProject.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return ProjectModel.fromJson(response.data);
  }
  
  @override
  Future<void> deleteProject(String id) async {
    await apiClient.delete(ApiEndpoints.deleteProject.replaceAll('{id}', id));
  }
  
  @override
  Future<List<MemberModel>> getProjectMembers(String id) async {
    final response = await apiClient.get(
      ApiEndpoints.getProjectMembers.replaceAll('{id}', id)
    );
    return (response.data['members'] as List)
        .map((json) => MemberModel.fromJson(json))
        .toList();
  }
  
  @override
  Future<LedgerSwitchResponseModel> switchLedger(SwitchLedgerParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.switchLedger,
      queryParameters: params.toJson(),
    );
    return LedgerSwitchResponseModel.fromJson(response.data);
  }
}
```

### 4.4 é ç®—ç®¡ç†æœå‹™ (F016-F018)

#### 4.4.1 BudgetServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/budget_remote_datasource.dart
class BudgetRemoteDataSourceImpl implements BudgetRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<BudgetModel> createBudget(CreateBudgetParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createBudget,
      data: params.toJson(),
    );
    return BudgetModel.fromJson(response.data);
  }
  
  @override
  Future<BudgetProgressModel> getBudgetProgress(String id) async {
    final response = await apiClient.get(
      ApiEndpoints.getBudgetProgress.replaceAll('{id}', id)
    );
    return BudgetProgressModel.fromJson(response.data);
  }
  
  @override
  Future<BudgetAlertResponseModel> setBudgetAlerts(
    String id, 
    SetBudgetAlertsParams params
  ) async {
    final response = await apiClient.put(
      ApiEndpoints.setBudgetAlerts.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return BudgetAlertResponseModel.fromJson(response.data);
  }
}
```

### 4.5 å”ä½œåŠŸèƒ½æœå‹™ (F019-F021)

#### 4.5.1 CollaborationServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/collaboration_remote_datasource.dart
class CollaborationRemoteDataSourceImpl implements CollaborationRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<SharedLedgerModel> createSharedLedger(CreateSharedLedgerParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createSharedLedger,
      data: params.toJson(),
    );
    return SharedLedgerModel.fromJson(response.data);
  }
  
  @override
  Future<PermissionResponseModel> setMemberPermissions(
    String id, 
    SetPermissionsParams params
  ) async {
    final response = await apiClient.put(
      ApiEndpoints.setMemberPermissions.replaceAll('{id}', id),
      data: params.toJson(),
    );
    return PermissionResponseModel.fromJson(response.data);
  }
  
  // WebSocketé€£ç·šè™•ç†
  @override
  Stream<RealtimeSyncEvent> connectRealtimeSync(String ledgerId) {
    final channel = IOWebSocketChannel.connect(
      '${ApiEndpoints.realtimeSync}?ledger_id=$ledgerId'
    );
    
    return channel.stream.map((data) {
      final json = jsonDecode(data);
      return RealtimeSyncEvent.fromJson(json);
    });
  }
}
```

### 4.6 å ±è¡¨åŠŸèƒ½æœå‹™ (F022-F024)

#### 4.6.1 ReportServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/report_remote_datasource.dart
class ReportRemoteDataSourceImpl implements ReportRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<ReportModel> generateReport(GenerateReportParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.generateReport,
      data: params.toJson(),
    );
    return ReportModel.fromJson(response.data);
  }
  
  @override
  Future<CustomReportModel> createCustomReport(CreateCustomReportParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createCustomReport,
      data: params.toJson(),
    );
    return CustomReportModel.fromJson(response.data);
  }
  
  @override
  Future<ExportResponseModel> exportReport(String id, ExportReportParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.exportReport.replaceAll('{id}', id),
      queryParameters: params.toJson(),
    );
    return ExportResponseModel.fromJson(response.data);
  }
}
```

### 4.7 ç³»çµ±ç®¡ç†æœå‹™ (F025-F032)

#### 4.7.1 SystemServiceå¯¦ä½œ
```dart
// lib/data/datasources/remote/system_remote_datasource.dart
class SystemRemoteDataSourceImpl implements SystemRemoteDataSource {
  final ApiClient apiClient;
  
  @override
  Future<BackupScheduleModel> scheduleBackup(ScheduleBackupParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.scheduleBackup,
      data: params.toJson(),
    );
    return BackupScheduleModel.fromJson(response.data);
  }
  
  @override
  Future<BackupResponseModel> manualBackup(ManualBackupParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.manualBackup,
      data: params.toJson(),
    );
    return BackupResponseModel.fromJson(response.data);
  }
  
  @override
  Future<BackupListModel> listBackups(ListBackupsParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.listBackups,
      queryParameters: params.toJson(),
    );
    return BackupListModel.fromJson(response.data);
  }
  
  @override
  Future<SyncStatusModel> checkSyncStatus(CheckSyncParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.checkSyncStatus,
      queryParameters: params.toJson(),
    );
    return SyncStatusModel.fromJson(response.data);
  }
  
  @override
  Future<SystemHealthModel> getSystemHealth() async {
    final response = await apiClient.get(ApiEndpoints.systemHealth);
    return SystemHealthModel.fromJson(response.data);
  }
  
  @override
  Future<ErrorLogsModel> getErrorLogs(ErrorLogsParams params) async {
    final response = await apiClient.get(
      ApiEndpoints.errorLogs,
      queryParameters: params.toJson(),
    );
    return ErrorLogsModel.fromJson(response.data);
  }
  
  @override
  Future<ReminderModel> createReminder(CreateReminderParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.createReminder,
      data: params.toJson(),
    );
    return ReminderModel.fromJson(response.data);
  }
  
  @override
  Future<ReminderExecutionModel> executeReminder(ExecuteReminderParams params) async {
    final response = await apiClient.post(
      ApiEndpoints.executeReminder,
      data: params.toJson(),
    );
    return ReminderExecutionModel.fromJson(response.data);
  }
}
```

---

## 8.0 è³‡æ–™æ¨¡å‹å®šç¾©ï¼ˆData Modelsï¼‰

### 5.1 æ ¸å¿ƒè³‡æ–™æ¨¡å‹

#### 5.1.1 ä½¿ç”¨è€…ç›¸é—œæ¨¡å‹
```dart
// lib/data/models/user_model.dart
@JsonSerializable()
class UserModel extends User {
  final String uid;
  final String displayName;
  final String email;
  final String userType;
  final DateTime createdAt;
  final DateTime lastLogin;
  
  const UserModel({
    required this.uid,
    required this.displayName,
    required this.email,
    required this.userType,
    required this.createdAt,
    required this.lastLogin,
  }) : super(
    uid: uid,
    displayName: displayName,
    email: email,
    userType: userType,
    createdAt: createdAt,
    lastLogin: lastLogin,
  );
  
  factory UserModel.fromJson(Map<String, dynamic> json) => _$UserModelFromJson(json);
  Map<String, dynamic> toJson() => _$UserModelToJson(this);
}

@JsonSerializable()
class LoginResponseModel {
  final bool success;
  final String accessToken;
  final String refreshToken;
  final UserModel userInfo;
  final int expiresIn;
  
  const LoginResponseModel({
    required this.success,
    required this.accessToken,
    required this.refreshToken,
    required this.userInfo,
    required this.expiresIn,
  });
  
  factory LoginResponseModel.fromJson(Map<String, dynamic> json) => 
      _$LoginResponseModelFromJson(json);
  Map<String, dynamic> toJson() => _$LoginResponseModelToJson(this);
}
```

#### 5.1.2 è¨˜å¸³ç›¸é—œæ¨¡å‹
```dart
// lib/data/models/entry_model.dart
@JsonSerializable()
class EntryModel extends Entry {
  final String entryId;
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;
  
  const EntryModel({
    required this.entryId,
    required this.entryType,
    required this.amount,
    required this.subjectCode,
    required this.subjectName,
    required this.ledgerId,
    required this.entryDate,
    this.description,
    this.tags,
    this.location,
  }) : super(
    entryId: entryId,
    entryType: entryType,
    amount: amount,
    subjectCode: subjectCode,
    subjectName: subjectName,
    ledgerId: ledgerId,
    entryDate: entryDate,
    description: description,
    tags: tags,
    location: location,
  );
  
  factory EntryModel.fromJson(Map<String, dynamic> json) => _$EntryModelFromJson(json);
  Map<String, dynamic> toJson() => _$EntryModelToJson(this);
}

@JsonSerializable()
class PaginatedEntriesModel {
  final bool success;
  final List<EntryModel> entries;
  final EntrySummaryModel summary;
  final PaginationModel pagination;
  
  const PaginatedEntriesModel({
    required this.success,
    required this.entries,
    required this.summary,
    required this.pagination,
  });
  
  factory PaginatedEntriesModel.fromJson(Map<String, dynamic> json) => 
      _$PaginatedEntriesModelFromJson(json);
  Map<String, dynamic> toJson() => _$PaginatedEntriesModelToJson(this);
}
```

#### 5.1.3 å°ˆæ¡ˆå¸³æœ¬æ¨¡å‹
```dart
// lib/data/models/project_model.dart
@JsonSerializable()
class ProjectModel extends Project {
  final String projectId;
  final String projectName;
  final String description;
  final DateTime startDate;
  final DateTime endDate;
  final String currency;
  final String projectType;
  final String status;
  final String ownerUid;
  final BudgetSettingsModel? budgetSettings;
  final AccessSettingsModel accessSettings;
  
  const ProjectModel({
    required this.projectId,
    required this.projectName,
    required this.description,
    required this.startDate,
    required this.endDate,
    required this.currency,
    required this.projectType,
    required this.status,
    required this.ownerUid,
    this.budgetSettings,
    required this.accessSettings,
  }) : super(
    projectId: projectId,
    projectName: projectName,
    description: description,
    startDate: startDate,
    endDate: endDate,
    currency: currency,
    projectType: projectType,
    status: status,
    ownerUid: ownerUid,
  );
  
  factory ProjectModel.fromJson(Map<String, dynamic> json) => 
      _$ProjectModelFromJson(json);
  Map<String, dynamic> toJson() => _$ProjectModelToJson(this);
}
```

### 5.2 APIåƒæ•¸æ¨¡å‹

#### 5.2.1 è«‹æ±‚åƒæ•¸æ¨¡å‹
```dart
// lib/data/models/params/auth_params.dart
@JsonSerializable()
class RegisterUserParams {
  final String platform;
  final String? lineUid;
  final DeviceInfoModel deviceInfo;
  final String displayName;
  final String timezone;
  final String authProvider;
  
  const RegisterUserParams({
    required this.platform,
    this.lineUid,
    required this.deviceInfo,
    required this.displayName,
    required this.timezone,
    required this.authProvider,
  });
  
  factory RegisterUserParams.fromJson(Map<String, dynamic> json) => 
      _$RegisterUserParamsFromJson(json);
  Map<String, dynamic> toJson() => _$RegisterUserParamsToJson(this);
}

@JsonSerializable()
class LoginUserParams {
  final String platform;
  final String? lineUid;
  final String? email;
  final String? password;
  final String authProvider;
  final DeviceInfoModel deviceInfo;
  
  const LoginUserParams({
    required this.platform,
    this.lineUid,
    this.email,
    this.password,
    required this.authProvider,
    required this.deviceInfo,
  });
  
  factory LoginUserParams.fromJson(Map<String, dynamic> json) => 
      _$LoginUserParamsFromJson(json);
  Map<String, dynamic> toJson() => _$LoginUserParamsToJson(this);
}
```

#### 5.2.2 è¨˜å¸³åƒæ•¸æ¨¡å‹
```dart
// lib/data/models/params/entry_params.dart
@JsonSerializable()
class CreateEntryParams {
  final String entryType;
  final double amount;
  final String subjectCode;
  final String subjectName;
  final String ledgerId;
  final DateTime entryDate;
  final String? description;
  final List<String>? tags;
  final LocationModel? location;
  
  const CreateEntryParams({
    required this.entryType,
    required this.amount,
    required this.subjectCode,
    required this.subjectName,
    required this.ledgerId,
    required this.entryDate,
    this.description,
    this.tags,
    this.location,
  });
  
  factory CreateEntryParams.fromJson(Map<String, dynamic> json) => 
      _$CreateEntryParamsFromJson(json);
  Map<String, dynamic> toJson() => _$CreateEntryParamsToJson(this);
}

@JsonSerializable()
class EntryQueryParams {
  final EntryFiltersModel? filters;
  final PaginationParamsModel? pagination;
  final SortOptionsModel? sort;
  
  const EntryQueryParams({
    this.filters,
    this.pagination,
    this.sort,
  });
  
  factory EntryQueryParams.fromJson(Map<String, dynamic> json) => 
      _$EntryQueryParamsFromJson(json);
  Map<String, dynamic> toJson() => _$EntryQueryParamsToJson(this);
}
```

---

## 9.0 ç‹€æ…‹ç®¡ç†ç­–ç•¥ï¼ˆState Managementï¼‰

### 6.1 Providerç‹€æ…‹ç®¡ç†å¯¦ä½œ

#### 6.1.1 å…¨åŸŸç‹€æ…‹ç®¡ç†
```dart
// lib/presentation/providers/app_state_provider.dart
class AppStateProvider extends ChangeNotifier {
  // èªè­‰ç‹€æ…‹
  User? _currentUser;
  bool _isAuthenticated = false;
  
  // å¸³æœ¬ç‹€æ…‹
  String? _currentLedgerId;
  List<ProjectModel> _projects = [];
  
  // ç¶²è·¯ç‹€æ…‹
  bool _isOnline = true;
  
  // Getters
  User? get currentUser => _currentUser;
  bool get isAuthenticated => _isAuthenticated;
  String? get currentLedgerId => _currentLedgerId;
  List<ProjectModel> get projects => _projects;
  bool get isOnline => _isOnline;
  
  // èªè­‰ç›¸é—œæ–¹æ³•
  Future<void> login(LoginUserParams params) async {
    try {
      final result = await sl<LoginUser>().call(params);
      result.fold(
        (failure) => throw Exception(failure.message),
        (loginResponse) {
          _currentUser = loginResponse.userInfo;
          _isAuthenticated = true;
          notifyListeners();
        },
      );
    } catch (e) {
      throw Exception('ç™»å…¥å¤±æ•—: $e');
    }
  }
  
  Future<void> logout() async {
    try {
      await sl<LogoutUser>().call();
      _currentUser = null;
      _isAuthenticated = false;
      _currentLedgerId = null;
      _projects.clear();
      notifyListeners();
    } catch (e) {
      throw Exception('ç™»å‡ºå¤±æ•—: $e');
    }
  }
  
  // å¸³æœ¬ç›¸é—œæ–¹æ³•
  Future<void> switchLedger(String ledgerId) async {
    try {
      final result = await sl<SwitchLedger>().call(
        SwitchLedgerParams(targetLedgerId: ledgerId)
      );
      result.fold(
        (failure) => throw Exception(failure.message),
        (switchResponse) {
          _currentLedgerId = ledgerId;
          notifyListeners();
        },
      );
    } catch (e) {
      throw Exception('å¸³æœ¬åˆ‡æ›å¤±æ•—: $e');
    }
  }
  
  // ç¶²è·¯ç‹€æ…‹ç®¡ç†
  void updateNetworkStatus(bool isOnline) {
    _isOnline = isOnline;
    notifyListeners();
  }
}
```

#### 6.1.2 åŠŸèƒ½å°ˆå±¬ç‹€æ…‹ç®¡ç†
```dart
// lib/presentation/providers/entry_provider.dart
class EntryProvider extends ChangeNotifier {
  final CreateEntry _createEntry;
  final GetEntries _getEntries;
  final UpdateEntry _updateEntry;
  final DeleteEntry _deleteEntry;
  
  EntryProvider({
    required CreateEntry createEntry,
    required GetEntries getEntries,
    required UpdateEntry updateEntry,
    required DeleteEntry deleteEntry,
  }) : _createEntry = createEntry,
       _getEntries = getEntries,
       _updateEntry = updateEntry,
       _deleteEntry = deleteEntry;
  
  // ç‹€æ…‹è®Šæ•¸
  List<Entry> _entries = [];
  bool _isLoading = false;
  String? _error;
  PaginationModel? _pagination;
  
  // Getters
  List<Entry> get entries => _entries;
  bool get isLoading => _isLoading;
  String? get error => _error;
  PaginationModel? get pagination => _pagination;
  
  // æ–°å¢è¨˜å¸³è¨˜éŒ„
  Future<void> createEntry(CreateEntryParams params) async {
    _setLoading(true);
    _clearError();
    
    final result = await _createEntry(params);
    result.fold(
      (failure) => _setError(failure.message),
      (entry) {
        _entries.insert(0, entry);
        notifyListeners();
      },
    );
    
    _setLoading(false);
  }
  
  // æŸ¥è©¢è¨˜å¸³è¨˜éŒ„
  Future<void> getEntries(EntryQueryParams params) async {
    _setLoading(true);
    _clearError();
    
    final result = await _getEntries(params);
    result.fold(
      (failure) => _setError(failure.message),
      (paginatedEntries) {
        _entries = paginatedEntries.entries;
        _pagination = paginatedEntries.pagination;
        notifyListeners();
      },
    );
    
    _setLoading(false);
  }
  
  // è¼‰å…¥æ›´å¤šè¨˜éŒ„
  Future<void> loadMore() async {
    if (_pagination?.hasNext != true || _isLoading) return;
    
    final nextPage = (_pagination?.currentPage ?? 0) + 1;
    final params = EntryQueryParams(
      pagination: PaginationParamsModel(
        page: nextPage,
        limit: _pagination?.limit ?? 20,
      ),
    );
    
    final result = await _getEntries(params);
    result.fold(
      (failure) => _setError(failure.message),
      (paginatedEntries) {
        _entries.addAll(paginatedEntries.entries);
        _pagination = paginatedEntries.pagination;
        notifyListeners();
      },
    );
  }
  
  // ç§æœ‰æ–¹æ³•
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  void _setError(String error) {
    _error = error;
    notifyListeners();
  }
  
  void _clearError() {
    _error = null;
  }
}
```

### 6.2 Use Caseså¯¦ä½œ

#### 6.2.1 èªè­‰ç›¸é—œUse Cases
```dart
// lib/domain/usecases/auth/login_user.dart
class LoginUser implements UseCase<LoginResponse, LoginUserParams> {
  final AuthRepository repository;
  
  LoginUser(this.repository);
  
  @override
  Future<Either<Failure, LoginResponse>> call(LoginUserParams params) async {
    return await repository.loginUser(params);
  }
}

// lib/domain/usecases/auth/register_user.dart
class RegisterUser implements UseCase<User, RegisterUserParams> {
  final AuthRepository repository;
  
  RegisterUser(this.repository);
  
  @override
  Future<Either<Failure, User>> call(RegisterUserParams params) async {
    return await repository.registerUser(params);
  }
}
```

#### 6.2.2 è¨˜å¸³ç›¸é—œUse Cases
```dart
// lib/domain/usecases/entry/create_entry.dart
class CreateEntry implements UseCase<Entry, CreateEntryParams> {
  final EntryRepository repository;
  
  CreateEntry(this.repository);
  
  @override
  Future<Either<Failure, Entry>> call(CreateEntryParams params) async {
    // æ¥­å‹™é‚è¼¯é©—è­‰
    if (params.amount <= 0) {
      return Left(ValidationFailure('é‡‘é¡å¿…é ˆå¤§æ–¼0'));
    }
    
    if (params.subjectCode.isEmpty) {
      return Left(ValidationFailure('ç§‘ç›®ä»£ç¢¼ä¸èƒ½ç‚ºç©º'));
    }
    
    return await repository.createEntry(params);
  }
}

// lib/domain/usecases/entry/get_entries.dart
class GetEntries implements UseCase<PaginatedEntries, EntryQueryParams> {
  final EntryRepository repository;
  
  GetEntries(this.repository);
  
  @override
  Future<Either<Failure, PaginatedEntries>> call(EntryQueryParams params) async {
    return await repository.getEntries(params);
  }
}
```

---

## 10.0 éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼ˆError Handlingï¼‰

### 7.1 çµ±ä¸€éŒ¯èª¤å®šç¾©

#### 7.1.1 éŒ¯èª¤é¡å‹å®šç¾©
```dart
// lib/core/error/failures.dart
abstract class Failure extends Equatable {
  final String message;
  final String? code;
  final dynamic details;
  
  const Failure({
    required this.message,
    this.code,
    this.details,
  });
  
  @override
  List<Object?> get props => [message, code, details];
}

class ServerFailure extends Failure {
  const ServerFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class NetworkFailure extends Failure {
  const NetworkFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class CacheFailure extends Failure {
  const CacheFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class ValidationFailure extends Failure {
  const ValidationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class AuthenticationFailure extends Failure {
  const AuthenticationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}

class AuthorizationFailure extends Failure {
  const AuthorizationFailure(String message, {String? code, dynamic details})
      : super(message: message, code: code, details: details);
}
```

#### 7.1.2 ç•°å¸¸å®šç¾©
```dart
// lib/core/error/exceptions.dart
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic details;
  
  const AppException({
    required this.message,
    this.code,
    this.details,
  });
}

class ServerException extends AppException {
  const ServerException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}

class NetworkException extends AppException {
  const NetworkException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}

class CacheException extends AppException {
  const CacheException({
    required String message,
    String? code,
    dynamic details,
  }) : super(message: message, code: code, details: details);
}
```

### 7.2 éŒ¯èª¤è™•ç†å™¨å¯¦ä½œ

#### 7.2.1 APIéŒ¯èª¤è™•ç†å™¨
```dart
// lib/core/error/api_error_handler.dart
class ApiErrorHandler {
  static Failure handleError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return NetworkFailure(
          'ç¶²è·¯é€£ç·šé€¾æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²è·¯ç‹€æ…‹',
          code: 'NETWORK_TIMEOUT',
        );
      
      case DioExceptionType.badResponse:
        return _handleHttpError(error.response!);
      
      case DioExceptionType.connectionError:
        return NetworkFailure(
          'ç„¡æ³•é€£ç·šåˆ°ä¼ºæœå™¨ï¼Œè«‹æª¢æŸ¥ç¶²è·¯è¨­å®š',
          code: 'NETWORK_ERROR',
        );
      
      case DioExceptionType.cancel:
        return NetworkFailure(
          'è«‹æ±‚å·²å–æ¶ˆ',
          code: 'REQUEST_CANCELLED',
        );
      
      default:
        return ServerFailure(
          'æœªçŸ¥éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦',
          code: 'UNKNOWN_ERROR',
          details: error.message,
        );
    }
  }
  
  static Failure _handleHttpError(Response response) {
    final statusCode = response.statusCode;
    final data = response.data;
    
    String message = 'ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦';
    String? errorCode;
    
    if (data is Map<String, dynamic>) {
      message = data['message'] ?? message;
      errorCode = data['error_code'];
    }
    
    switch (statusCode) {
      case 400:
        return ValidationFailure(
          message.isNotEmpty ? message : 'è«‹æ±‚æ ¼å¼éŒ¯èª¤',
          code: errorCode ?? 'BAD_REQUEST',
          details: data,
        );
      
      case 401:
        return AuthenticationFailure(
          message.isNotEmpty ? message : 'èªè­‰å¤±æ•—ï¼Œè«‹é‡æ–°ç™»å…¥',
          code: errorCode ?? 'UNAUTHORIZED',
          details: data,
        );
      
      case 403:
        return AuthorizationFailure(
          message.isNotEmpty ? message : 'æ¬Šé™ä¸è¶³ï¼Œç„¡æ³•åŸ·è¡Œæ­¤æ“ä½œ',
          code: errorCode ?? 'FORBIDDEN',
          details: data,
        );
      
      case 404:
        return ServerFailure(
          message.isNotEmpty ? message : 'æ‰¾ä¸åˆ°è«‹æ±‚çš„è³‡æº',
          code: errorCode ?? 'NOT_FOUND',
          details: data,
        );
      
      case 422:
        return ValidationFailure(
          message.isNotEmpty ? message : 'è³‡æ–™é©—è­‰å¤±æ•—',
          code: errorCode ?? 'VALIDATION_ERROR',
          details: data,
        );
      
      case 500:
        return ServerFailure(
          message.isNotEmpty ? message : 'ä¼ºæœå™¨å…§éƒ¨éŒ¯èª¤',
          code: errorCode ?? 'INTERNAL_SERVER_ERROR',
          details: data,
        );
      
      default:
        return ServerFailure(
          message.isNotEmpty ? message : 'HTTPéŒ¯èª¤ $statusCode',
          code: errorCode ?? 'HTTP_$statusCode',
          details: data,
        );
    }
  }
}
```

#### 7.2.2 éŒ¯èª¤æ””æˆªå™¨
```dart
// lib/core/api/error_interceptor.dart
class ErrorInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // è¨˜éŒ„éŒ¯èª¤æ—¥èªŒ
    _logError(err);
    
    // è™•ç†ç‰¹å®šéŒ¯èª¤é¡å‹
    if (err.response?.statusCode == 401) {
      // TokenéæœŸï¼Œè§¸ç™¼é‡æ–°ç™»å…¥
      _handleTokenExpired();
    } else if (err.response?.statusCode == 503) {
      // æœå‹™ä¸å¯ç”¨ï¼Œé¡¯ç¤ºç¶­è­·é é¢
      _handleServiceUnavailable();
    }
    
    // è½‰æ›ç‚ºæ‡‰ç”¨éŒ¯èª¤
    final failure = ApiErrorHandler.handleError(err);
    
    // é¡¯ç¤ºç”¨æˆ¶å‹å–„çš„éŒ¯èª¤è¨Šæ¯
    _showUserFriendlyError(failure);
    
    handler.next(err);
  }
  
  void _logError(DioException error) {
    debugPrint('API Error: ${error.type}');
    debugPrint('URL: ${error.requestOptions.uri}');
    debugPrint('Method: ${error.requestOptions.method}');
    debugPrint('Status Code: ${error.response?.statusCode}');
    debugPrint('Response: ${error.response?.data}');
  }
  
  void _handleTokenExpired() {
    // æ¸…é™¤æœ¬åœ°Token
    sl<TokenRepository>().clearTokens();
    
    // å°å‘ç™»å…¥é é¢
    NavigationService.pushAndClearStack('/login');
    
    // é¡¯ç¤ºæç¤ºè¨Šæ¯
    ToastService.showError('ç™»å…¥å·²éæœŸï¼Œè«‹é‡æ–°ç™»å…¥');
  }
  
  void _handleServiceUnavailable() {
    NavigationService.pushNamed('/maintenance');
  }
  
  void _showUserFriendlyError(Failure failure) {
    String message;
    
    switch (failure.runtimeType) {
      case NetworkFailure:
        message = 'ç¶²è·¯é€£ç·šå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯è¨­å®š';
        break;
      case ServerFailure:
        message = 'ä¼ºæœå™¨æš«æ™‚ç„¡æ³•å›æ‡‰ï¼Œè«‹ç¨å¾Œå†è©¦';
        break;
      case ValidationFailure:
        message = failure.message;
        break;
      case AuthenticationFailure:
        message = 'ç™»å…¥é©—è­‰å¤±æ•—ï¼Œè«‹é‡æ–°ç™»å…¥';
        break;
      case AuthorizationFailure:
        message = 'æ‚¨æ²’æœ‰æ¬Šé™åŸ·è¡Œæ­¤æ“ä½œ';
        break;
      default:
        message = 'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦';
    }
    
    ToastService.showError(message);
  }
}
```

---

## 11.0 å¿«å–ç­–ç•¥è¨­è¨ˆï¼ˆCaching Strategyï¼‰

### 8.1 å¤šå±¤æ¬¡å¿«å–æ¶æ§‹

#### 8.1.1 å¿«å–ç®¡ç†å™¨å¯¦ä½œ
```dart
// lib/core/cache/cache_manager.dart
abstract class CacheManager {
  Future<void> put<T>(String key, T data, {Duration? expiry});
  Future<T?> get<T>(String key);
  Future<bool> exists(String key);
  Future<bool> isExpired(String key);
  Future<void> delete(String key);
  Future<void> clear();
  Future<void> clearExpired();
}

class CacheManagerImpl implements CacheManager {
  final Box _box;
  static const String _expiryPrefix = '_expiry_';
  
  CacheManagerImpl(this._box);
  
  @override
  Future<void> put<T>(String key, T data, {Duration? expiry}) async {
    await _box.put(key, data);
    
    if (expiry != null) {
      final expiryTime = DateTime.now().add(expiry);
      await _box.put('$_expiryPrefix$key', expiryTime.millisecondsSinceEpoch);
    }
  }
  
  @override
  Future<T?> get<T>(String key) async {
    if (await isExpired(key)) {
      await delete(key);
      return null;
    }
    
    return _box.get(key) as T?;
  }
  
  @override
  Future<bool> exists(String key) async {
    return _box.containsKey(key) && !await isExpired(key);
  }
  
  @override
  Future<bool> isExpired(String key) async {
    final expiryKey = '$_expiryPrefix$key';
    if (!_box.containsKey(expiryKey)) {
      return false;
    }
    
    final expiryTime = _box.get(expiryKey) as int;
    return DateTime.now().millisecondsSinceEpoch > expiryTime;
  }
  
  @override
  Future<void> delete(String key) async {
    await _box.delete(key);
    await _box.delete('$_expiryPrefix$key');
  }
  
  @override
  Future<void> clear() async {
    await _box.clear();
  }
  
  @override
  Future<void> clearExpired() async {
    final keys = _box.keys.where((key) => key.toString().startsWith(_expiryPrefix));
    
    for (final expiryKey in keys) {
      final dataKey = expiryKey.toString().substring(_expiryPrefix.length);
      if (await isExpired(dataKey)) {
        await delete(dataKey);
      }
    }
  }
}
```

#### 8.1.2 å¿«å–ç­–ç•¥å®šç¾©
```dart
// lib/core/cache/cache_strategies.dart
enum CacheStrategy {
  cacheFirst,    // å„ªå…ˆä½¿ç”¨å¿«å–
  networkFirst,  // å„ªå…ˆç¶²è·¯è«‹æ±‚
  cacheOnly,     // åƒ…ä½¿ç”¨å¿«å–
  networkOnly,   // åƒ…ç¶²è·¯è«‹æ±‚
  staleWhileRevalidate, // ä½¿ç”¨å¿«å–åŒæ™‚æ›´æ–°
}

class CacheConfig {
  final CacheStrategy strategy;
  final Duration? expiry;
  final bool storeOnFailure;
  final int maxRetries;
  
  const CacheConfig({
    required this.strategy,
    this.expiry,
    this.storeOnFailure = false,
    this.maxRetries = 3,
  });
}

class ApiCacheManager {
  static const Map<String, CacheConfig> _cacheConfigs = {
    // ä½¿ç”¨è€…è³‡æ–™ - ä¸­ç­‰é »ç‡å¿«å–
    'GET:/auth/user': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 30),
    ),
    
    // è¨˜å¸³æ­·å² - çŸ­æœŸå¿«å–
    'GET:/entries': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 5),
    ),
    
    // å°ˆæ¡ˆåˆ—è¡¨ - ä¸­æœŸå¿«å–
    'GET:/projects': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 15),
    ),
    
    // é ç®—é€²åº¦ - çŸ­æœŸå¿«å–
    'GET:/budgets/{id}/progress': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 2),
    ),
    
    // å ±è¡¨æ•¸æ“š - é•·æœŸå¿«å–
    'GET:/reports': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(hours: 1),
    ),
    
    // ç³»çµ±å¥åº· - æ¥µçŸ­æœŸå¿«å–
    'GET:/system/health': CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(seconds: 30),
    ),
    
    // å‚™ä»½åˆ—è¡¨ - ä¸­æœŸå¿«å–
    'GET:/backups': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 10),
    ),
    
    // å³æ™‚æ•¸æ“š - ä¸å¿«å–
    'POST:/entries': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
    
    'POST:/entries/quick': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
    
    'PUT:/entries/{id}': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
    
    'DELETE:/entries/{id}': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
  };
  
  static CacheConfig getConfig(String method, String path) {
    final key = '$method:$path';
    return _cacheConfigs[key] ?? const CacheConfig(
      strategy: CacheStrategy.networkFirst,
      expiry: Duration(minutes: 5),
    );
  }
}
```

#### 8.1.3 å¿«å–æ””æˆªå™¨å¯¦ä½œ
```dart
// lib/core/api/cache_interceptor.dart
class CacheInterceptor extends Interceptor {
  final CacheManager _cacheManager;
  
  CacheInterceptor(this._cacheManager);
  
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(options);
    final config = ApiCacheManager.getConfig(options.method, options.path);
    
    switch (config.strategy) {
      case CacheStrategy.cacheFirst:
        final cachedData = await _cacheManager.get(cacheKey);
        if (cachedData != null) {
          final response = Response(
            requestOptions: options,
            data: cachedData,
            statusCode: 200,
            headers: Headers.fromMap({'x-cache': ['HIT']}),
          );
          handler.resolve(response);
          return;
        }
        break;
        
      case CacheStrategy.cacheOnly:
        final cachedData = await _cacheManager.get(cacheKey);
        if (cachedData != null) {
          final response = Response(
            requestOptions: options,
            data: cachedData,
            statusCode: 200,
            headers: Headers.fromMap({'x-cache': ['HIT']}),
          );
          handler.resolve(response);
        } else {
          handler.reject(DioException(
            requestOptions: options,
            error: 'å¿«å–ä¸­ç„¡æ­¤è³‡æ–™ï¼Œä¸”åƒ…å…è¨±å¿«å–å­˜å–',
          ));
        }
        return;
        
      case CacheStrategy.networkOnly:
        // ä¸ä½¿ç”¨å¿«å–ï¼Œç›´æ¥ç¶²è·¯è«‹æ±‚
        break;
        
      case CacheStrategy.networkFirst:
      case CacheStrategy.staleWhileRevalidate:
        // å…ˆå˜—è©¦ç¶²è·¯è«‹æ±‚ï¼Œå¤±æ•—æ™‚ä½¿ç”¨å¿«å–
        break;
    }
    
    handler.next(options);
  }
  
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(response.requestOptions);
    final config = ApiCacheManager.getConfig(
      response.requestOptions.method,
      response.requestOptions.path,
    );
    
    // æ ¹æ“šç­–ç•¥æ±ºå®šæ˜¯å¦å¿«å–
    if (_shouldCache(config, response)) {
      await _cacheManager.put(
        cacheKey,
        response.data,
        expiry: config.expiry,
      );
    }
    
    handler.next(response);
  }
  
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    final cacheKey = _generateCacheKey(err.requestOptions);
    final config = ApiCacheManager.getConfig(
      err.requestOptions.method,
      err.requestOptions.path,
    );
    
    // ç¶²è·¯è«‹æ±‚å¤±æ•—æ™‚ï¼Œå˜—è©¦ä½¿ç”¨å¿«å–
    if (config.strategy == CacheStrategy.networkFirst ||
        config.strategy == CacheStrategy.staleWhileRevalidate) {
      final cachedData = await _cacheManager.get(cacheKey);
      if (cachedData != null) {
        final response = Response(
          requestOptions: err.requestOptions,
          data: cachedData,
          statusCode: 200,
          headers: Headers.fromMap({'x-cache': ['STALE']}),
        );
        handler.resolve(response);
        return;
      }
    }
    
    handler.next(err);
  }
  
  String _generateCacheKey(RequestOptions options) {
    final uri = options.uri.toString();
    final method = options.method;
    final queryParams = options.queryParameters.entries
        .map((e) => '${e.key}=${e.value}')
        .join('&');
    
    return '$method:$uri${queryParams.isNotEmpty ? '?$queryParams' : ''}';
  }
  
  bool _shouldCache(CacheConfig config, Response response) {
    // åªå¿«å–æˆåŠŸçš„å›æ‡‰
    if (response.statusCode != 200) {
      return config.storeOnFailure;
    }
    
    // ä¸å¿«å–ç©ºè³‡æ–™
    if (response.data == null) {
      return false;
    }
    
    return config.strategy != CacheStrategy.networkOnly;
  }
}
```

---

## 12.0 é›¢ç·šåŒæ­¥æ©Ÿåˆ¶ï¼ˆOffline Syncï¼‰

### 9.1 é›¢ç·šæ“ä½œä½‡åˆ—

#### 9.1.1 é›¢ç·šæ“ä½œæ¨¡å‹
```dart
// lib/core/sync/offline_operation.dart
@JsonSerializable()
class OfflineOperation {
  final String id;
  final String operationType; // create, update, delete
  final String endpoint;
  final String method;
  final Map<String, dynamic>? data;
  final Map<String, String>? headers;
  final DateTime timestamp;
  final int retryCount;
  final DateTime? nextRetry;
  final OperationStatus status;
  final String? errorMessage;
  
  OfflineOperation({
    required this.id,
    required this.operationType,
    required this.endpoint,
    required this.method,
    this.data,
    this.headers,
    required this.timestamp,
    this.retryCount = 0,
    this.nextRetry,
    this.status = OperationStatus.pending,
    this.errorMessage,
  });
  
  factory OfflineOperation.fromJson(Map<String, dynamic> json) => 
      _$OfflineOperationFromJson(json);
  Map<String, dynamic> toJson() => _$OfflineOperationToJson(this);
}

enum OperationStatus {
  pending,    // ç­‰å¾…åŒæ­¥
  syncing,    // åŒæ­¥ä¸­
  synced,     // å·²åŒæ­¥
  failed,     // åŒæ­¥å¤±æ•—
  cancelled,  // å·²å–æ¶ˆ
}
```

#### 9.1.2 é›¢ç·šåŒæ­¥ç®¡ç†å™¨
```dart
// lib/core/sync/offline_sync_manager.dart
class OfflineSyncManager {
  final CacheManager _cacheManager;
  final ApiClient _apiClient;
  final ConnectivityService _connectivity;
  final Queue<OfflineOperation> _syncQueue = Queue();
  
  static const String _queueKey = 'offline_sync_queue';
  static const int _maxRetries = 3;
  
  OfflineSyncManager({
    required CacheManager cacheManager,
    required ApiClient apiClient,
    required ConnectivityService connectivity,
  }) : _cacheManager = cacheManager,
       _apiClient = apiClient,
       _connectivity = connectivity;
  
  // åˆå§‹åŒ–åŒæ­¥ç®¡ç†å™¨
  Future<void> initialize() async {
    await _loadSyncQueue();
    _connectivity.onConnectivityChanged.listen(_onConnectivityChanged);
  }
  
  // æ–°å¢é›¢ç·šæ“ä½œåˆ°ä½‡åˆ—
  Future<void> queueOperation(OfflineOperation operation) async {
    // æœ¬åœ°åŸ·è¡Œæ“ä½œ
    await _executeLocalOperation(operation);
    
    // åŠ å…¥åŒæ­¥ä½‡åˆ—
    _syncQueue.add(operation);
    await _persistSyncQueue();
    
    // å¦‚æœç·šä¸Šï¼Œç«‹å³å˜—è©¦åŒæ­¥
    if (await _connectivity.isConnected) {
      _processSyncQueue();
    }
  }
  
  // è™•ç†åŒæ­¥ä½‡åˆ—
  Future<void> _processSyncQueue() async {
    while (_syncQueue.isNotEmpty && await _connectivity.isConnected) {
      final operation = _syncQueue.first;
      
      if (operation.status == OperationStatus.synced) {
        _syncQueue.removeFirst();
        continue;
      }
      
      if (operation.nextRetry != null && 
          DateTime.now().isBefore(operation.nextRetry!)) {
        break; // ç­‰å¾…é‡è©¦æ™‚é–“
      }
      
      try {
        operation.status = OperationStatus.syncing;
        await _executeRemoteOperation(operation);
        
        operation.status = OperationStatus.synced;
        _syncQueue.removeFirst();
        
      } catch (e) {
        await _handleSyncError(operation, e);
      }
      
      await _persistSyncQueue();
    }
  }
  
  // åŸ·è¡Œæœ¬åœ°æ“ä½œ
  Future<void> _executeLocalOperation(OfflineOperation operation) async {
    try {
      switch (operation.operationType) {
        case 'create':
          await _handleLocalCreate(operation);
          break;
        case 'update':
          await _handleLocalUpdate(operation);
          break;
        case 'delete':
          await _handleLocalDelete(operation);
          break;
      }
    } catch (e) {
      debugPrint('æœ¬åœ°æ“ä½œåŸ·è¡Œå¤±æ•—: $e');
    }
  }
  
  // åŸ·è¡Œé ç«¯åŒæ­¥
  Future<void> _executeRemoteOperation(OfflineOperation operation) async {
    final response = await _apiClient.request(
      operation.endpoint,
      options: Options(
        method: operation.method,
        headers: operation.headers,
      ),
      data: operation.data,
    );
    
    // æ›´æ–°æœ¬åœ°å¿«å–
    if (response.statusCode == 200 || response.statusCode == 201) {
      await _updateLocalCacheAfterSync(operation, response.data);
    }
  }
  
  // è™•ç†åŒæ­¥éŒ¯èª¤
  Future<void> _handleSyncError(OfflineOperation operation, dynamic error) async {
    operation.retryCount++;
    
    if (operation.retryCount < _maxRetries) {
      // è¨ˆç®—ä¸‹æ¬¡é‡è©¦æ™‚é–“ (æŒ‡æ•¸é€€é¿)
      final delay = Duration(seconds: math.pow(2, operation.retryCount).toInt());
      operation.nextRetry = DateTime.now().add(delay);
      operation.status = OperationStatus.pending;
    } else {
      operation.status = OperationStatus.failed;
      operation.errorMessage = error.toString();
    }
  }
  
  // æœ¬åœ°å»ºç«‹æ“ä½œè™•ç†
  Future<void> _handleLocalCreate(OfflineOperation operation) async {
    final localId = 'local_${operation.id}';
    await _cacheManager.put('temp_entry_$localId', operation.data);
  }
  
  // æœ¬åœ°æ›´æ–°æ“ä½œè™•ç†
  Future<void> _handleLocalUpdate(OfflineOperation operation) async {
    final existingData = await _cacheManager.get(operation.endpoint);
    if (existingData != null) {
      final updatedData = {...existingData as Map<String, dynamic>, ...?operation.data};
      await _cacheManager.put(operation.endpoint, updatedData);
    }
  }
  
  // æœ¬åœ°åˆªé™¤æ“ä½œè™•ç†
  Future<void> _handleLocalDelete(OfflineOperation operation) async {
    await _cacheManager.delete(operation.endpoint);
  }
  
  // ç¶²è·¯ç‹€æ…‹è®ŠåŒ–è™•ç†
  void _onConnectivityChanged(bool isConnected) {
    if (isConnected && _syncQueue.isNotEmpty) {
      _processSyncQueue();
    }
  }
  
  // è¼‰å…¥åŒæ­¥ä½‡åˆ—
  Future<void> _loadSyncQueue() async {
    final queueData = await _cacheManager.get<List>(_queueKey);
    if (queueData != null) {
      _syncQueue.addAll(
        queueData.map((json) => OfflineOperation.fromJson(json))
      );
    }
  }
  
  // æŒä¹…åŒ–åŒæ­¥ä½‡åˆ—
  Future<void> _persistSyncQueue() async {
    final queueData = _syncQueue.map((op) => op.toJson()).toList();
    await _cacheManager.put(_queueKey, queueData);
  }
  
  // åŒæ­¥å®Œæˆå¾Œæ›´æ–°æœ¬åœ°å¿«å–
  Future<void> _updateLocalCacheAfterSync(
    OfflineOperation operation, 
    dynamic responseData
  ) async {
    switch (operation.operationType) {
      case 'create':
        // æ›´æ–°æœ¬åœ°IDæ˜ å°„
        final localId = 'local_${operation.id}';
        await _cacheManager.delete('temp_entry_$localId');
        if (responseData != null) {
          await _cacheManager.put(operation.endpoint, responseData);
        }
        break;
      case 'update':
        if (responseData != null) {
          await _cacheManager.put(operation.endpoint, responseData);
        }
        break;
      case 'delete':
        // ç¢ºä¿æœ¬åœ°è³‡æ–™å·²åˆªé™¤
        await _cacheManager.delete(operation.endpoint);
        break;
    }
  }
}
```

### 9.2 è¡çªè§£æ±ºæ©Ÿåˆ¶

#### 9.2.1 è¡çªæª¢æ¸¬å™¨
```dart
// lib/core/sync/conflict_detector.dart
class ConflictDetector {
  static ConflictResult detectConflict(
    Map<String, dynamic> localData,
    Map<String, dynamic> remoteData,
  ) {
    final conflicts = <String, ConflictInfo>[];
    
    // æª¢æ¸¬æ™‚é–“æˆ³è¡çª
    final localTimestamp = DateTime.tryParse(localData['updated_at'] ?? '');
    final remoteTimestamp = DateTime.tryParse(remoteData['updated_at'] ?? '');
    
    if (localTimestamp != null && remoteTimestamp != null) {
      if (localTimestamp.isAfter(remoteTimestamp)) {
        return ConflictResult(
          hasConflict: true,
          conflictType: ConflictType.localNewer,
          localData: localData,
          remoteData: remoteData,
        );
      } else if (remoteTimestamp.isAfter(localTimestamp)) {
        return ConflictResult(
          hasConflict: true,
          conflictType: ConflictType.remoteNewer,
          localData: localData,
          remoteData: remoteData,
        );
      }
    }
    
    // æª¢æ¸¬æ¬„ä½ç´šåˆ¥è¡çª
    final allKeys = {...localData.keys, ...remoteData.keys};
    
    for (final key in allKeys) {
      if (key == 'updated_at' || key == 'created_at') continue;
      
      final localValue = localData[key];
      final remoteValue = remoteData[key];
      
      if (localValue != remoteValue) {
        conflicts.add(ConflictInfo(
          field: key,
          localValue: localValue,
          remoteValue: remoteValue,
        ));
      }
    }
    
    if (conflicts.isNotEmpty) {
      return ConflictResult(
        hasConflict: true,
        conflictType: ConflictType.fieldLevel,
        conflicts: conflicts,
        localData: localData,
        remoteData: remoteData,
      );
    }
    
    return ConflictResult(hasConflict: false);
  }
}

class ConflictResult {
  final bool hasConflict;
  final ConflictType? conflictType;
  final List<ConflictInfo>? conflicts;
  final Map<String, dynamic>? localData;
  final Map<String, dynamic>? remoteData;
  
  ConflictResult({
    required this.hasConflict,
    this.conflictType,
    this.conflicts,
    this.localData,
    this.remoteData,
  });
}

enum ConflictType {
  localNewer,   // æœ¬åœ°è³‡æ–™è¼ƒæ–°
  remoteNewer,  // é ç«¯è³‡æ–™è¼ƒæ–°
  fieldLevel,   // æ¬„ä½ç´šè¡çª
  concurrent,   // ä½µç™¼ä¿®æ”¹
}

class ConflictInfo {
  final String field;
  final dynamic localValue;
  final dynamic remoteValue;
  
  ConflictInfo({
    required this.field,
    required this.localValue,
    required this.remoteValue,
  });
}
```

#### 9.2.2 è¡çªè§£æ±ºå™¨
```dart
// lib/core/sync/conflict_resolver.dart
class ConflictResolver {
  // è‡ªå‹•è§£æ±ºè¡çª
  static Map<String, dynamic> autoResolve(ConflictResult conflict) {
    if (!conflict.hasConflict) {
      return conflict.remoteData ?? {};
    }
    
    switch (conflict.conflictType) {
      case ConflictType.localNewer:
        return conflict.localData!;
      
      case ConflictType.remoteNewer:
        return conflict.remoteData!;
      
      case ConflictType.fieldLevel:
        return _mergeFieldLevel(conflict);
      
      case ConflictType.concurrent:
        return _handleConcurrentConflict(conflict);
      
      default:
        return conflict.remoteData!;
    }
  }
  
  // æ¬„ä½ç´šè¡çªåˆä½µ
  static Map<String, dynamic> _mergeFieldLevel(ConflictResult conflict) {
    final merged = <String, dynamic>{...conflict.remoteData!};
    
    // å°æ–¼ç‰¹å®šæ¬„ä½ï¼Œæ¡ç”¨æœ¬åœ°å„ªå…ˆç­–ç•¥
    final localPriorityFields = ['amount', 'description', 'subject_code'];
    
    for (final conflictInfo in conflict.conflicts!) {
      if (localPriorityFields.contains(conflictInfo.field)) {
        merged[conflictInfo.field] = conflictInfo.localValue;
      }
    }
    
    return merged;
  }
  
  // è™•ç†ä½µç™¼è¡çª
  static Map<String, dynamic> _handleConcurrentConflict(ConflictResult conflict) {
    // å°æ–¼ä½µç™¼è¡çªï¼Œæ¡ç”¨æœ€å¾Œå¯«å…¥å‹åˆ©ç­–ç•¥
    final localTime = DateTime.tryParse(conflict.localData!['updated_at'] ?? '');
    final remoteTime = DateTime.tryParse(conflict.remoteData!['updated_at'] ?? '');
    
    if (localTime != null && remoteTime != null) {
      return localTime.isAfter(remoteTime) 
          ? conflict.localData! 
          : conflict.remoteData!;
    }
    
    return conflict.remoteData!;
  }
  
  // æ‰‹å‹•è§£æ±ºè¡çª (ç”±ä½¿ç”¨è€…é¸æ“‡)
  static Map<String, dynamic> manualResolve(
    ConflictResult conflict,
    ConflictResolution resolution,
  ) {
    switch (resolution.strategy) {
      case ResolutionStrategy.useLocal:
        return conflict.localData!;
      
      case ResolutionStrategy.useRemote:
        return conflict.remoteData!;
      
      case ResolutionStrategy.merge:
        return _customMerge(conflict, resolution.fieldChoices);
      
      case ResolutionStrategy.cancel:
        throw ConflictCancelledException('ä½¿ç”¨è€…å–æ¶ˆè¡çªè§£æ±º');
    }
  }
  
  // è‡ªè¨‚åˆä½µç­–ç•¥
  static Map<String, dynamic> _customMerge(
    ConflictResult conflict,
    Map<String, dynamic>? fieldChoices,
  ) {
    final merged = <String, dynamic>{...conflict.remoteData!};
    
    if (fieldChoices != null) {
      for (final entry in fieldChoices.entries) {
        final field = entry.key;
        final useLocal = entry.value as bool;
        
        if (useLocal && conflict.localData!.containsKey(field)) {
          merged[field] = conflict.localData![field];
        }
      }
    }
    
    return merged;
  }
}

class ConflictResolution {
  final ResolutionStrategy strategy;
  final Map<String, dynamic>? fieldChoices;
  
  ConflictResolution({
    required this.strategy,
    this.fieldChoices,
  });
}

enum ResolutionStrategy {
  useLocal,   // ä½¿ç”¨æœ¬åœ°ç‰ˆæœ¬
  useRemote,  // ä½¿ç”¨é ç«¯ç‰ˆæœ¬
  merge,      // æ‰‹å‹•åˆä½µ
  cancel,     // å–æ¶ˆæ“ä½œ
}

class ConflictCancelledException implements Exception {
  final String message;
  ConflictCancelledException(this.message);
}
```

---

## 13.0 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥ï¼ˆPerformance Optimizationï¼‰

### 10.1 APIè«‹æ±‚å„ªåŒ–

#### 10.1.1 è«‹æ±‚å»é‡èˆ‡æ‰¹é‡è™•ç†
```dart
// lib/core/optimization/request_optimizer.dart
class RequestOptimizer {
  final Map<String, Completer<Response>> _pendingRequests = {};
  final Map<String, Timer> _debounceTimers = {};
  
  static const Duration _debounceDelay = Duration(milliseconds: 300);
  static const int _batchSize = 10;
  
  // è«‹æ±‚å»é‡
  Future<Response> deduplicate(RequestOptions options, Future<Response> Function() request) async {
    final key = _generateRequestKey(options);
    
    if (_pendingRequests.containsKey(key)) {
      return _pendingRequests[key]!.future;
    }
    
    final completer = Completer<Response>();
    _pendingRequests[key] = completer;
    
    try {
      final response = await request();
      completer.complete(response);
      return response;
    } catch (error) {
      completer.completeError(error);
      rethrow;
    } finally {
      _pendingRequests.remove(key);
    }
  }
  
  // è«‹æ±‚é˜²æŠ–
  Future<Response> debounce(
    String key,
    RequestOptions options,
    Future<Response> Function() request,
  ) async {
    final completer = Completer<Response>();
    
    // å–æ¶ˆä¹‹å‰çš„è¨ˆæ™‚å™¨
    _debounceTimers[key]?.cancel();
    
    _debounceTimers[key] = Timer(_debounceDelay, () async {
      try {
        final response = await request();
        completer.complete(response);
      } catch (error) {
        completer.completeError(error);
      } finally {
        _debounceTimers.remove(key);
      }
    });
    
    return completer.future;
  }
  
  // æ‰¹é‡è«‹æ±‚è™•ç†
  Future<List<Response>> batchRequests(
    List<RequestOptions> requestsList,
    Future<Response> Function(RequestOptions) requestFunction,
  ) async {
    final responses = <Response>[];
    
    for (int i = 0; i < requestsList.length; i += _batchSize) {
      final batch = requestsList.skip(i).take(_batchSize);
      final futures = batch.map(requestFunction);
      
      final batchResponses = await Future.wait(futures);
      responses.addAll(batchResponses);
      
      // æ‰¹æ¬¡é–“ç¨ä½œå»¶é²ï¼Œé¿å…ä¼ºæœå™¨éè¼‰
      if (i + _batchSize < requestsList.length) {
        await Future.delayed(const Duration(milliseconds: 100));
      }
    }
    
    return responses;
  }
  
  String _generateRequestKey(RequestOptions options) {
    final uri = options.uri.toString();
    final method = options.method;
    final dataHash = options.data?.hashCode ?? 0;
    
    return '$method:$uri:$dataHash';
  }
}
```

#### 10.1.2 ä½µç™¼æ§åˆ¶èˆ‡é™æµ
```dart
// lib/core/optimization/concurrency_manager.dart
class ConcurrencyManager {
  final int _maxConcurrent;
  final Queue<_RequestTask> _waitingQueue = Queue();
  int _currentConcurrent = 0;
  
  ConcurrencyManager({int maxConcurrent = 5}) : _maxConcurrent = maxConcurrent;
  
  Future<T> execute<T>(Future<T> Function() task) async {
    final completer = Completer<T>();
    final requestTask = _RequestTask(task, completer);
    
    if (_currentConcurrent < _maxConcurrent) {
      _executeTask(requestTask);
    } else {
      _waitingQueue.add(requestTask);
    }
    
    return completer.future;
  }
  
  void _executeTask<T>(_RequestTask<T> task) async {
    _currentConcurrent++;
    
    try {
      final result = await task.task();
      task.completer.complete(result);
    } catch (error) {
      task.completer.completeError(error);
    } finally {
      _currentConcurrent--;
      _processWaitingQueue();
    }
  }
  
  void _processWaitingQueue() {
    if (_waitingQueue.isNotEmpty && _currentConcurrent < _maxConcurrent) {
      final nextTask = _waitingQueue.removeFirst();
      _executeTask(nextTask);
    }
  }
}

class _RequestTask<T> {
  final Future<T> Function() task;
  final Completer<T> completer;
  
  _RequestTask(this.task, this.completer);
}
```

### 10.2 è³‡æ–™è¼‰å…¥å„ªåŒ–

#### 10.2.1 é è¼‰å…¥ç­–ç•¥
```dart
// lib/core/optimization/preloader.dart
class DataPreloader {
  final Map<String, Future<dynamic>> _preloadTasks = {};
  final CacheManager _cacheManager;
  
  DataPreloader(this._cacheManager);
  
  // æ ¹æ“šä½¿ç”¨è€…è¡Œç‚ºé è¼‰å…¥è³‡æ–™
  Future<void> preloadBasedOnUsage(String userId) async {
    // é è¼‰å…¥ä½¿ç”¨è€…è³‡æ–™
    _preloadUserData(userId);
    
    // é è¼‰å…¥æœ€è¿‘ä½¿ç”¨çš„å¸³æœ¬
    _preloadRecentLedgers(userId);
    
    // é è¼‰å…¥å¸¸ç”¨ç§‘ç›®
    _preloadFrequentSubjects(userId);
    
    // é è¼‰å…¥æœ¬æœˆè¨˜å¸³è¨˜éŒ„
    _preloadCurrentMonthEntries(userId);
  }
  
  Future<void> _preloadUserData(String userId) async {
    const key = 'preload_user_data';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      final userService = sl<AuthService>();
      final user = await userService.getUserProfile();
      await _cacheManager.put('user_profile', user, expiry: Duration(hours: 1));
    });
  }
  
  Future<void> _preloadRecentLedgers(String userId) async {
    const key = 'preload_recent_ledgers';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      final projectService = sl<ProjectLedgerService>();
      final projects = await projectService.getProjects();
      await _cacheManager.put('recent_projects', projects, expiry: Duration(minutes: 30));
    });
  }
  
  Future<void> _preloadFrequentSubjects(String userId) async {
    const key = 'preload_frequent_subjects';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      // å‡è¨­æœ‰APIå¯ä»¥å–å¾—å¸¸ç”¨ç§‘ç›®
      final subjects = await sl<EntryService>().getFrequentSubjects();
      await _cacheManager.put('frequent_subjects', subjects, expiry: Duration(days: 1));
    });
  }
  
  Future<void> _preloadCurrentMonthEntries(String userId) async {
    const key = 'preload_current_month';
    if (_preloadTasks.containsKey(key)) return;
    
    _preloadTasks[key] = _executePreload(() async {
      final now = DateTime.now();
      final startOfMonth = DateTime(now.year, now.month, 1);
      final endOfMonth = DateTime(now.year, now.month + 1, 0);
      
      final params = EntryQueryParams(
        filters: EntryFiltersModel(
          dateRange: DateRangeModel(
            startDate: startOfMonth,
            endDate: endOfMonth,
          ),
        ),
        pagination: PaginationParamsModel(page: 1, limit: 50),
      );
      
      final entries = await sl<EntryService>().getEntries(params);
      await _cacheManager.put('current_month_entries', entries, expiry: Duration(hours: 2));
    });
  }
  
  Future<void> _executePreload(Future<void> Function() preloadFunction) async {
    try {
      await preloadFunction();
    } catch (e) {
      // é è¼‰å…¥å¤±æ•—ä¸å½±éŸ¿ä¸»è¦åŠŸèƒ½
      debugPrint('é è¼‰å…¥å¤±æ•—: $e');
    }
  }
  
  // æ¸…ç†é è¼‰å…¥ä»»å‹™
  void clearPreloadTasks() {
    _preloadTasks.clear();
  }
}
```

#### 10.2.2 åˆ†é èˆ‡è™›æ“¬æ»¾å‹•å„ªåŒ–
```dart
// lib/core/optimization/pagination_manager.dart
class PaginationManager<T> {
  final Future<PaginatedResult<T>> Function(int page, int limit) _loadFunction;
  final int _pageSize;
  
  final List<T> _items = [];
  final Set<int> _loadedPages = {};
  bool _hasMore = true;
  bool _isLoading = false;
  
  PaginationManager({
    required Future<PaginatedResult<T>> Function(int page, int limit) loadFunction,
    int pageSize = 20,
  }) : _loadFunction = loadFunction,
       _pageSize = pageSize;
  
  List<T> get items => _items;
  bool get hasMore => _hasMore;
  bool get isLoading => _isLoading;
  
  // è¼‰å…¥æŒ‡å®šé é¢
  Future<void> loadPage(int page) async {
    if (_loadedPages.contains(page) || _isLoading) return;
    
    _isLoading = true;
    
    try {
      final result = await _loadFunction(page, _pageSize);
      
      // æ’å…¥è³‡æ–™åˆ°æ­£ç¢ºä½ç½®
      final startIndex = (page - 1) * _pageSize;
      _insertItemsAtIndex(startIndex, result.items);
      
      _loadedPages.add(page);
      _hasMore = result.hasMore;
      
    } catch (e) {
      debugPrint('è¼‰å…¥é é¢å¤±æ•—: $e');
    } finally {
      _isLoading = false;
    }
  }
  
  // è¼‰å…¥ä¸‹ä¸€é 
  Future<void> loadMore() async {
    if (!_hasMore || _isLoading) return;
    
    final nextPage = (_loadedPages.isEmpty) ? 1 : _loadedPages.length + 1;
    await loadPage(nextPage);
  }
  
  // åˆ·æ–°è³‡æ–™
  Future<void> refresh() async {
    _items.clear();
    _loadedPages.clear();
    _hasMore = true;
    
    await loadPage(1);
  }
  
  // é è¼‰å…¥é„°è¿‘é é¢
  Future<void> preloadAdjacent(int currentIndex) async {
    final currentPage = (currentIndex / _pageSize).ceil();
    
    // é è¼‰å…¥å‰ä¸€é å’Œå¾Œä¸€é 
    final pagesToPreload = [currentPage - 1, currentPage + 1]
        .where((page) => page > 0 && !_loadedPages.contains(page));
    
    for (final page in pagesToPreload) {
      if (_hasMore || page <= _loadedPages.length) {
        loadPage(page); // ä¸ç­‰å¾…å®Œæˆï¼ŒèƒŒæ™¯è¼‰å…¥
      }
    }
  }
  
  void _insertItemsAtIndex(int startIndex, List<T> newItems) {
    // ç¢ºä¿åˆ—è¡¨æœ‰è¶³å¤ é•·åº¦
    while (_items.length < startIndex) {
      _items.add(null as T); // ä½”ä½ç¬¦
    }
    
    // æ’å…¥æ–°è³‡æ–™
    for (int i = 0; i < newItems.length; i++) {
      final index = startIndex + i;
      if (index < _items.length) {
        _items[index] = newItems[i];
      } else {
        _items.add(newItems[i]);
      }
    }
  }
}

class PaginatedResult<T> {
  final List<T> items;
  final bool hasMore;
  final int currentPage;
  final int totalPages;
  
  PaginatedResult({
    required this.items,
    required this.hasMore,
    required this.currentPage,
    required this.totalPages,
  });
}
```

---

## 14.0 æ¸¬è©¦ç­–ç•¥ï¼ˆTesting Strategyï¼‰

### 11.1 å–®å…ƒæ¸¬è©¦

#### 11.1.1 APIæœå‹™æ¸¬è©¦
```dart
// test/data/datasources/remote/auth_remote_datasource_test.dart
@GenerateMocks([ApiClient])
void main() {
  late AuthRemoteDataSourceImpl dataSource;
  late MockApiClient mockApiClient;
  
  setUp(() {
    mockApiClient = MockApiClient();
    dataSource = AuthRemoteDataSourceImpl(apiClient: mockApiClient);
  });
  
  group('AuthRemoteDataSource', () {
    group('registerUser', () {
      const tRegisterParams = RegisterUserParams(
        platform: 'mobile_app',
        displayName: 'Test User',
        timezone: 'Asia/Taipei',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(
          deviceType: 'ios',
          appVersion: '1.0.0',
        ),
      );
      
      const tUserModel = UserModel(
        uid: 'test_uid',
        displayName: 'Test User',
        email: 'test@example.com',
        userType: 'S',
        createdAt: '2025-01-24T10:00:00Z',
        lastLogin: '2025-01-24T10:00:00Z',
      );
      
      test('should perform POST request to correct endpoint', () async {
        // arrange
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenAnswer((_) async => Response(
                  requestOptions: RequestOptions(path: ''),
                  data: tUserModel.toJson(),
                  statusCode: 200,
                ));
        
        // act
        await dataSource.registerUser(tRegisterParams);
        
        // assert
        verify(mockApiClient.post(
          ApiEndpoints.registerUser,
          data: tRegisterParams.toJson(),
        ));
      });
      
      test('should return UserModel when response is successful', () async {
        // arrange
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenAnswer((_) async => Response(
                  requestOptions: RequestOptions(path: ''),
                  data: tUserModel.toJson(),
                  statusCode: 200,
                ));
        
        // act
        final result = await dataSource.registerUser(tRegisterParams);
        
        // assert
        expect(result, equals(tUserModel));
      });
      
      test('should throw ServerException when response code is not 200', () async {
        // arrange
        when(mockApiClient.post(any, data: anyNamed('data')))
            .thenThrow(DioException(
              requestOptions: RequestOptions(path: ''),
              response: Response(
                requestOptions: RequestOptions(path: ''),
                statusCode: 500,
              ),
            ));
        
        // act & assert
        expect(
          () => dataSource.registerUser(tRegisterParams),
          throwsA(isA<ServerException>()),
        );
      });
    });
    
    group('loginUser', () {
      // é¡ä¼¼çš„æ¸¬è©¦çµæ§‹...
    });
  });
}
```

#### 11.1.2 Repositoryæ¸¬è©¦
```dart
// test/data/repositories/auth_repository_impl_test.dart
@GenerateMocks([
  AuthRemoteDataSource,
  AuthLocalDataSource,
  NetworkInfo,
])
void main() {
  late AuthRepositoryImpl repository;
  late MockAuthRemoteDataSource mockRemoteDataSource;
  late MockAuthLocalDataSource mockLocalDataSource;
  late MockNetworkInfo mockNetworkInfo;
  
  setUp(() {
    mockRemoteDataSource = MockAuthRemoteDataSource();
    mockLocalDataSource = MockAuthLocalDataSource();
    mockNetworkInfo = MockNetworkInfo();
    repository = AuthRepositoryImpl(
      remoteDataSource: mockRemoteDataSource,
      localDataSource: mockLocalDataSource,
      networkInfo: mockNetworkInfo,
    );
  });
  
  group('AuthRepository', () {
    group('registerUser', () {
      const tRegisterParams = RegisterUserParams(
        platform: 'mobile_app',
        displayName: 'Test User',
        timezone: 'Asia/Taipei',
        authProvider: 'email',
        deviceInfo: DeviceInfoModel(
          deviceType: 'ios',
          appVersion: '1.0.0',
        ),
      );
      
      const tUser = UserModel(
        uid: 'test_uid',
        displayName: 'Test User',
        email: 'test@example.com',
        userType: 'S',
        createdAt: '2025-01-24T10:00:00Z',
        lastLogin: '2025-01-24T10:00:00Z',
      );
      
      test('should return User when device is online and call is successful', () async {
        // arrange
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);
        when(mockRemoteDataSource.registerUser(any))
            .thenAnswer((_) async => tUser);
        when(mockLocalDataSource.cacheUser(any))
            .thenAnswer((_) async => {});
        
        // act
        final result = await repository.registerUser(tRegisterParams);
        
        // assert
        verify(mockRemoteDataSource.registerUser(tRegisterParams));
        verify(mockLocalDataSource.cacheUser(tUser));
        expect(result, equals(const Right(tUser)));
      });
      
      test('should return NetworkFailure when device is offline', () async {
        // arrange
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => false);
        
        // act
        final result = await repository.registerUser(tRegisterParams);
        
        // assert
        verifyZeroInteractions(mockRemoteDataSource);
        expect(result, equals(const Left(NetworkFailure('ç¶²è·¯é€£ç·šç•°å¸¸'))));
      });
      
      test('should return ServerFailure when remote call throws ServerException', () async {
        // arrange
        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);
        when(mockRemoteDataSource.registerUser(any))
            .thenThrow(const ServerException(message: 'ä¼ºæœå™¨éŒ¯èª¤'));
        
        // act
        final result = await repository.registerUser(tRegisterParams);
        
        // assert
        expect(result, equals(const Left(ServerFailure('ä¼ºæœå™¨éŒ¯èª¤'))));
      });
    });
  });
}
```

### 11.2 æ•´åˆæ¸¬è©¦

#### 11.2.1 APIæ•´åˆæ¸¬è©¦
```dart
// test/integration/api_integration_test.dart
void main() {
  late ApiClient apiClient;
  late AuthRemoteDataSourceImpl authDataSource;
  
  setUpAll(() {
    // ä½¿ç”¨æ¸¬è©¦ç’°å¢ƒçš„APIç«¯é»
    apiClient = ApiClient(baseUrl: 'https://lcas-api-test.replit.app/api/v1');
    authDataSource = AuthRemoteDataSourceImpl(apiClient: apiClient);
  });
  
  group('API Integration Tests', () {
    group('Authentication Flow', () {
      test('complete authentication flow should work', () async {
        // 1. è¨»å†Šæ–°ç”¨æˆ¶
        final registerParams = RegisterUserParams(
          platform: 'mobile_app',
          displayName: 'Integration Test User',
          timezone: 'Asia/Taipei',
          authProvider: 'email',
          deviceInfo: DeviceInfoModel(
            deviceType: 'ios',
            appVersion: '1.0.0',
          ),
        );
        
        final registeredUser = await authDataSource.registerUser(registerParams);
        expect(registeredUser.displayName, 'Integration Test User');
        
        // 2. ä½¿ç”¨è¨»å†Šè³‡è¨Šç™»å…¥
        final loginParams = LoginUserParams(
          platform: 'mobile_app',
          email: registeredUser.email,
          password: 'test_password',
          authProvider: 'email',
          deviceInfo: DeviceInfoModel(
            deviceType: 'ios',
            appVersion: '1.0.0',
          ),
        );
        
        final loginResponse = await authDataSource.loginUser(loginParams);
        expect(loginResponse.success, true);
        expect(loginResponse.accessToken, isNotEmpty);
        
        // 3. ä½¿ç”¨Tokenå–å¾—ç”¨æˆ¶è³‡æ–™
        // è¨­å®šAuthorization header
        apiClient.setAuthToken(loginResponse.accessToken);
        
        final userProfile = await authDataSource.getUserProfile();
        expect(userProfile.uid, registeredUser.uid);
        
        // 4. ç™»å‡º
        await authDataSource.logoutUser();
      });
    });
    
    group('Entry Management Flow', () {
      late EntryRemoteDataSourceImpl entryDataSource;
      late String authToken;
      
      setUp(() async {
        entryDataSource = EntryRemoteDataSourceImpl(apiClient: apiClient);
        
        // ç™»å…¥å–å¾—Token
        final loginResponse = await authDataSource.loginUser(testLoginParams);
        authToken = loginResponse.accessToken;
        apiClient.setAuthToken(authToken);
      });
      
      test('complete entry CRUD flow should work', () async {
        // 1. å»ºç«‹è¨˜å¸³è¨˜éŒ„
        final createParams = CreateEntryParams(
          entryType: 'expense',
          amount: 100.0,
          subjectCode: '2003',
          subjectName: 'é¤é£²è²»',
          ledgerId: 'default',
          entryDate: DateTime.now(),
          description: 'åˆé¤',
        );
        
        final createdEntry = await entryDataSource.createEntry(createParams);
        expect(createdEntry.amount, 100.0);
        expect(createdEntry.description, 'åˆé¤');
        
        // 2. æŸ¥è©¢è¨˜å¸³è¨˜éŒ„
        final queryParams = EntryQueryParams(
          filters: EntryFiltersModel(
            entryTypes: ['expense'],
          ),
          pagination: PaginationParamsModel(page: 1, limit: 10),
        );
        
        final paginatedEntries = await entryDataSource.getEntries(queryParams);
        expect(paginatedEntries.entries, isNotEmpty);
        
        final foundEntry = paginatedEntries.entries
            .firstWhere((entry) => entry.entryId == createdEntry.entryId);
        expect(foundEntry.amount, 100.0);
        
        // 3. æ›´æ–°è¨˜å¸³è¨˜éŒ„
        final updateParams = UpdateEntryParams(
          amount: 120.0,
          description: 'åˆé¤ - å·²æ›´æ–°',
        );
        
        final updatedEntry = await entryDataSource.updateEntry(
          createdEntry.entryId,
          updateParams,
        );
        expect(updatedEntry.amount, 120.0);
        expect(updatedEntry.description, 'åˆé¤ - å·²æ›´æ–°');
        
        // 4. åˆªé™¤è¨˜å¸³è¨˜éŒ„
        await entryDataSource.deleteEntry(createdEntry.entryId);
        
        // é©—è­‰å·²åˆªé™¤
        final queryAfterDelete = await entryDataSource.getEntries(queryParams);
        final deletedEntry = queryAfterDelete.entries
            .where((entry) => entry.entryId == createdEntry.entryId);
        expect(deletedEntry, isEmpty);
      });
    });
  });
}
```

### 11.3 Widgetæ¸¬è©¦

#### 11.3.1 Provider Widgetæ¸¬è©¦
```dart
// test/presentation/providers/entry_provider_test.dart
@GenerateMocks([CreateEntry, GetEntries, UpdateEntry, DeleteEntry])
void main() {
  late EntryProvider entryProvider;
  late MockCreateEntry mockCreateEntry;
  late MockGetEntries mockGetEntries;
  late MockUpdateEntry mockUpdateEntry;
  late MockDeleteEntry mockDeleteEntry;
  
  setUp(() {
    mockCreateEntry = MockCreateEntry();
    mockGetEntries = MockGetEntries();
    mockUpdateEntry = MockUpdateEntry();
    mockDeleteEntry = MockDeleteEntry();
    
    entryProvider = EntryProvider(
      createEntry: mockCreateEntry,
      getEntries: mockGetEntries,
      updateEntry: mockUpdateEntry,
      deleteEntry: mockDeleteEntry,
    );
  });
  
  group('EntryProvider', () {
    const tEntry = Entry(
      entryId: 'test_id',
      entryType: 'expense',
      amount: 100.0,
      subjectCode: '2003',
      subjectName: 'é¤é£²è²»',
      ledgerId: 'default',
      entryDate: '2025-01-24T10:00:00Z',
      description: 'æ¸¬è©¦è¨˜éŒ„',
    );
    
    const tCreateParams = CreateEntryParams(
      entryType: 'expense',
      amount: 100.0,
      subjectCode: '2003',
      subjectName: 'é¤é£²è²»',
      ledgerId: 'default',
      entryDate: '2025-01-24T10:00:00Z',
      description: 'æ¸¬è©¦è¨˜éŒ„',
    );
    
    test('should create entry successfully', () async {
      // arrange
      when(mockCreateEntry(any))
          .thenAnswer((_) async => const Right(tEntry));
      
      // act
      await entryProvider.createEntry(tCreateParams);
      
      // assert
      expect(entryProvider.entries, contains(tEntry));
      expect(entryProvider.isLoading, false);
      expect(entryProvider.error, null);
      verify(mockCreateEntry(tCreateParams));
    });
    
    test('should handle create entry failure', () async {
      // arrange
      const tFailure = ServerFailure('å»ºç«‹å¤±æ•—');
      when(mockCreateEntry(any))
          .thenAnswer((_) async => const Left(tFailure));
      
      // act
      await entryProvider.createEntry(tCreateParams);
      
      // assert
      expect(entryProvider.entries, isEmpty);
      expect(entryProvider.isLoading, false);
      expect(entryProvider.error, 'å»ºç«‹å¤±æ•—');
    });
    
    test('should set loading state during create entry', () async {
      // arrange
      final completer = Completer<Either<Failure, Entry>>();
      when(mockCreateEntry(any)).thenAnswer((_) => completer.future);
      
      // act
      final future = entryProvider.createEntry(tCreateParams);
      
      // assert loading state
      expect(entryProvider.isLoading, true);
      
      // complete the operation
      completer.complete(const Right(tEntry));
      await future;
      
      expect(entryProvider.isLoading, false);
    });
  });
}
```

---

## 15.0 ç‰ˆæœ¬å‡ç´šè¨ˆç•«ï¼ˆVersion Upgradeï¼‰

### 15.1 æ¨¡çµ„ç‰ˆæœ¬è¦åŠƒ

| æ¨¡çµ„åç¨± | ç•¶å‰ç‰ˆæœ¬ | ç›®æ¨™ç‰ˆæœ¬ | å‡ç´šå…§å®¹ | ç›¸ä¾æ€§ |
|----------|----------|----------|----------|--------|
| **Flutter_AP_Layer** | v2.0.0 | v2.1.0 | æ¶æ§‹é—œä¿‚æ˜ç¢ºåŒ–ï¼ŒåŠŸèƒ½ç„¡è®Šæ›´ | æ‰€æœ‰ç›¸é—œæ¨¡çµ„ |
| **AuthService** | - | v2.1.0 | F001-F005 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **EntryService** | - | v2.1.0 | F006-F009 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **ProjectLedgerService** | - | v2.1.0 | F010-F015 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **BudgetService** | - | v2.1.0 | F016-F018 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **CollaborationService** | - | v2.1.0 | F019-F021 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **ReportService** | - | v2.1.0 | F022-F024 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |
| **SystemService** | - | v2.1.0 | F025-F032 APIæœå‹™å¯¦ä½œ | ApiClient v2.1.0 |

### 15.2 å‡½æ•¸ç‰ˆæœ¬å‡ç´š

#### 15.2.1 æ ¸å¿ƒAPIå‡½æ•¸ç‰ˆæœ¬
| APIç«¯é» | å‡½æ•¸åç¨± | ç‰ˆæœ¬ | å‡ç´šå…§å®¹ |
|---------|----------|------|----------|
| F001-F005 | AuthServiceå„æ–¹æ³• | v2.1.0 | å®Œæ•´èªè­‰æµç¨‹å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F006-F009 | EntryServiceå„æ–¹æ³• | v2.1.0 | è¨˜å¸³CRUDæ“ä½œå¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F010-F015 | ProjectLedgerServiceå„æ–¹æ³• | v2.1.0 | å¤šå¸³æœ¬ç®¡ç†å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F016-F018 | BudgetServiceå„æ–¹æ³• | v2.1.0 | é ç®—ç®¡ç†å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F019-F021 | CollaborationServiceå„æ–¹æ³• | v2.1.0 | å”ä½œåŠŸèƒ½å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F022-F024 | ReportServiceå„æ–¹æ³• | v2.1.0 | å ±è¡¨åŠŸèƒ½å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |
| F025-F032 | SystemServiceå„æ–¹æ³• | v2.1.0 | ç³»çµ±ç®¡ç†å¯¦ä½œï¼Œæ¶æ§‹å„ªåŒ– |

### 15.3 é–‹ç™¼é‡Œç¨‹ç¢‘

#### 12.3.1 Phase 1: åŸºç¤æ¶æ§‹å»ºç«‹ (Week 1-2)
- âœ… Clean Architectureæ¶æ§‹è¨­è¨ˆ
- âœ… ä¾è³´æ³¨å…¥è¨­å®š
- âœ… çµ±ä¸€APIå®¢æˆ¶ç«¯å¯¦ä½œ
- âœ… éŒ¯èª¤è™•ç†æ©Ÿåˆ¶å»ºç«‹
- âœ… è³‡æ–™æ¨¡å‹å®šç¾©

#### 12.3.2 Phase 2: æ ¸å¿ƒAPIæœå‹™å¯¦ä½œ (Week 3-4)
- ğŸ”„ AuthServiceå¯¦ä½œ (F001-F005)
- ğŸ”„ EntryServiceå¯¦ä½œ (F006-F009)
- ğŸ”„ Repository Patternå¯¦ä½œ
- ğŸ”„ Use Caseså¯¦ä½œ
- ğŸ”„ å–®å…ƒæ¸¬è©¦ç·¨å¯«

#### 12.3.3 Phase 3: é€²éšåŠŸèƒ½å¯¦ä½œ (Week 5-6)
- â³ ProjectLedgerServiceå¯¦ä½œ (F010-F015)
- â³ BudgetServiceå¯¦ä½œ (F016-F018)
- â³ CollaborationServiceå¯¦ä½œ (F019-F021)
- â³ WebSocketå³æ™‚åŒæ­¥å¯¦ä½œ

#### 12.3.4 Phase 4: ç³»çµ±åŠŸèƒ½èˆ‡å„ªåŒ– (Week 7-8)
- â³ ReportServiceå¯¦ä½œ (F022-F024)
- â³ SystemServiceå¯¦ä½œ (F025-F032)
- â³ å¿«å–ç­–ç•¥å¯¦ä½œ
- â³ é›¢ç·šåŒæ­¥æ©Ÿåˆ¶å¯¦ä½œ
- â³ æ•ˆèƒ½å„ªåŒ–å¯¦æ–½

#### 12.3.5 Phase 5: æ¸¬è©¦èˆ‡éƒ¨ç½² (Week 9-10)
- â³ æ•´åˆæ¸¬è©¦åŸ·è¡Œ
- â³ æ•ˆèƒ½æ¸¬è©¦åŸ·è¡Œ
- â³ æ–‡ä»¶å®Œå–„
- â³ éƒ¨ç½²æº–å‚™

### 15.4 å‘å¾Œç›¸å®¹æ€§ä¿è­‰

#### 12.4.1 APIç‰ˆæœ¬ç›¸å®¹æ€§
```dart
// lib/core/api/api_versioning.dart
class ApiVersionManager {
  static const String currentVersion = 'v2.0.0';
  static const List<String> supportedVersions = ['v1.0.0', 'v2.0.0'];
  
  static String getApiPath(String endpoint, {String? version}) {
    final apiVersion = version ?? currentVersion;
    return '/api/$apiVersion$endpoint';
  }
  
  static bool isVersionSupported(String version) {
    return supportedVersions.contains(version);
  }
  
  // ç‰ˆæœ¬é·ç§»é‚è¼¯
  static Map<String, dynamic> migrateRequest(
    String fromVersion,
    String toVersion,
    Map<String, dynamic> requestData,
  ) {
    if (fromVersion == toVersion) return requestData;
    
    // v1.0.0 -> v2.0.0 é·ç§»é‚è¼¯
    if (fromVersion == 'v1.0.0' && toVersion == 'v2.0.0') {
      return _migrateV1ToV2(requestData);
    }
    
    return requestData;
  }
  
  static Map<String, dynamic> _migrateV1ToV2(Map<String, dynamic> data) {
    // å¯¦æ–½å…·é«”çš„è³‡æ–™æ ¼å¼è½‰æ›é‚è¼¯
    final migratedData = Map<String, dynamic>.from(data);
    
    // ä¾‹å¦‚ï¼šæ™‚é–“æ ¼å¼è½‰æ›
    if (migratedData.containsKey('date')) {
      migratedData['entry_date'] = migratedData.remove('date');
    }
    
    return migratedData;
  }
}
```

---

## æ–‡ä»¶ç¶­è­·è¨˜éŒ„

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹è€… | ä¿®æ”¹å…§å®¹ |
|------|------|--------|----------|
| **v2.0.0** | **2025-01-24** | **LCAS PM Team** | **åˆç‰ˆå»ºç«‹ï¼šå®Œæ•´Flutter AP LayeræŠ€è¡“è¦æ ¼ï¼Œæ•´åˆ32å€‹RESTful APIç«¯é»ï¼Œå¯¦ä½œClean Architectureã€Repository Patternã€å¿«å–ç­–ç•¥ã€é›¢ç·šåŒæ­¥æ©Ÿåˆ¶ã€éŒ¯èª¤è™•ç†ã€æ•ˆèƒ½å„ªåŒ–ç­‰å®Œæ•´AP LayeråŠŸèƒ½** |
| **v2.1.0** | **2025-01-26** | **LCAS SA Team** | **æ¶æ§‹é‡çµ„å„ªåŒ–ï¼šåˆ†é›¢ç³»çµ±ã€æ¨¡çµ„ã€ç¨‹å¼ç¢¼ä¸‰å±¤æ¶æ§‹æè¿°ï¼Œæ–°å¢æ¶æ§‹é—œä¿‚å°æ‡‰ç« ç¯€ï¼Œæ˜ç¢º7å¤§æœå‹™ç¾¤çµ„åœ¨Clean Architectureä¸­çš„ä½ç½®ï¼Œè§£æ±ºæ¶æ§‹å±¤æ¬¡æ··æ·†å•é¡Œ** |

---

## å‚™è¨»

- **ç‰ˆæœ¬2.1.0é‡å¤§æ”¹é€²**: è§£æ±ºæ¶æ§‹å±¤æ¬¡æ··æ·†å•é¡Œï¼Œæ˜ç¢ºç³»çµ±ã€æ¨¡çµ„ã€ç¨‹å¼ç¢¼ä¸‰å±¤æ¶æ§‹é—œä¿‚
- **æ¶æ§‹é—œä¿‚é‡æ¸…**: æ–°å¢ç¬¬5ç« å°ˆé–€èªªæ˜7å¤§æœå‹™ç¾¤çµ„åœ¨Clean Architectureä¸­çš„å…·é«”ä½ç½®
- **å®Œæ•´APIæ•´åˆ**: 32å€‹RESTful APIç«¯é»(F001-F032)å®Œæ•´å°æ‡‰åˆ°ç¨‹å¼ç¢¼å¯¦ä½œ
- **Clean Architecture**: æ¡ç”¨åˆ†å±¤æ¶æ§‹ï¼Œç¢ºä¿ç¨‹å¼ç¢¼å¯ç¶­è­·æ€§å’Œå¯æ¸¬è©¦æ€§
- **Repository Pattern**: å¯¦ä½œè³‡æ–™å­˜å–æŠ½è±¡å±¤ï¼Œæ”¯æ´æœ¬åœ°å¿«å–å’Œé ç«¯API
- **å¿«å–ç­–ç•¥**: å¤šå±¤æ¬¡å¿«å–æ©Ÿåˆ¶ï¼Œæå‡æ‡‰ç”¨æ•ˆèƒ½å’Œä½¿ç”¨è€…é«”é©—
- **é›¢ç·šåŒæ­¥**: å®Œæ•´é›¢ç·šæ“ä½œæ”¯æ´å’Œæ™ºæ…§è¡çªè§£æ±ºæ©Ÿåˆ¶
- **éŒ¯èª¤è™•ç†**: çµ±ä¸€éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼Œæä¾›ä½¿ç”¨è€…å‹å–„çš„éŒ¯èª¤è¨Šæ¯
- **æ•ˆèƒ½å„ªåŒ–**: è«‹æ±‚å»é‡ã€æ‰¹é‡è™•ç†ã€ä½µç™¼æ§åˆ¶ç­‰æ•ˆèƒ½å„ªåŒ–ç­–ç•¥
- **æ¸¬è©¦ç­–ç•¥**: å®Œæ•´çš„å–®å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦å’ŒWidgetæ¸¬è©¦è¨ˆç•«
- **æŠ€è¡“å‚µå‹™**: è«‹åƒè€ƒ91è³‡æ–™å¤¾ä¸­çš„å…·é«”ç¨‹å¼ç¢¼å¯¦ä½œ
- **APIæ–‡ä»¶åƒè€ƒ**: è«‹åƒè€ƒ9205. Flutter_API list_AP layer.mdæ–‡ä»¶
- **UIæ•´åˆ**: é…åˆ9005. Flutter_Presentation layer.mdé€²è¡Œå‰ç«¯æ•´åˆ
- **æ¶æ§‹å•é¡Œè§£æ±º**: å›ç­”ã€Œ7å¤§æœå‹™ç¾¤çµ„åœ¨åˆ†å±¤æ¶æ§‹è¨­è¨ˆçš„å“ªè£¡ï¼Ÿã€â†’ ç­”æ¡ˆåœ¨ç¬¬5.3ç¯€
