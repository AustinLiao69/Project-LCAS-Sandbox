
# PRD_Flutter_Presentation Layer_v2.1.0

**文件編號**: 9005  
**版本**: 2.1.0  
**建立日期**: 2025-07-31  
**建立者**: LCAS PM Team  
**最後更新**: 2025-01-24 18:30:00 UTC+8

---

## 目次

1. [模組概述](#10-模組概述module-overview)
2. [API整合架構設計](#15-api整合架構設計)
3. [功能需求](#20-功能需求functional-requirements)
4. [32個端點UI對應表](#25-32個端點ui對應表)
5. [四模式UI差異化設計](#30-四模式ui差異化設計)
6. [四模式API權限矩陣](#35-四模式api權限矩陣)
7. [頁面架構與導航](#40-頁面架構與導航)
8. [元件庫規範](#50-元件庫規範)
9. [使用者體驗設計](#60-使用者體驗設計)
10. [技術架構需求](#70-技術架構需求)
11. [離線與同步策略](#75-離線與同步策略)
12. [效能與品質要求](#80-效能與品質要求)
13. [測試計畫](#90-測試計畫)
14. [風險評估與緩解](#100-風險評估與緩解)
15. [模組版本升級計畫](#110-模組版本升級計畫)

---

## 1.0 模組概述（Module Overview）

### 1.1 產品定位
Flutter Presentation Layer是LCAS 2.0系統的前端展示層，負責實現四模式個人化用戶介面，**完整支援32個RESTful API端點**，提供跨平台一致的視覺體驗和互動邏輯。

### 1.2 核心價值主張
- **完整API整合**: 支援9205文件定義的32個API端點，實現前後端無縫對接
- **四模式差異化**: 基於自律動機矩陣提供精準控制者、紀錄習慣者、轉型挑戰者、潛在覺醒者四種專屬UI體驗
- **跨平台協作**: 與LINE OA無縫整合，提供APP端深度功能擴展
- **智慧權限管理**: 依據模式動態調整API存取權限和功能可見性

### 1.3 API功能群組對應
基於9205文件API分類，定義七大功能群組：
- **認證管理群組** (F001-F005) → 5個API端點
- **基礎記帳群組** (F006-F009) → 4個API端點  
- **多帳本管理群組** (F010-F015) → 6個API端點
- **預算管理群組** (F016-F018) → 3個API端點
- **協作功能群組** (F019-F021) → 3個API端點
- **報表功能群組** (F022-F024) → 3個API端點
- **系統管理群組** (F025-F032) → 8個API端點

### 1.4 目標使用者
- **精準控制者（高動機+高自律）**: 完整32個API功能存取（5+4+6+3+3+3+8），專業儀表板和深度分析功能
- **紀錄習慣者（低動機+高自律）**: 重點API簡化呈現，美感體驗和流暢記帳儀式  
- **轉型挑戰者（高動機+低自律）**: 漸進式API功能解鎖，習慣養成支持和外部激勵
- **潛在覺醒者（低動機+低自律）**: 核心API友善引導，溫和引導和極簡操作

---

## 1.5 API整合架構設計

### 1.5.1 API客戶端架構

```
Flutter Service Architecture (基於業務功能群組)
├── AuthService (F001-F005認證管理) → 5個API端點
├── EntryService (F006-F009基礎記帳) → 4個API端點
├── ProjectLedgerService (F010-F015多帳本管理) → 6個API端點
├── BudgetService (F016-F018預算管理) → 3個API端點
├── CollaborationService (F019-F021協作功能) → 3個API端點
├── ReportService (F022-F024報表功能) → 3個API端點
└── SystemService (F025-F032系統管理) → 8個API端點

共享基礎設施：
├── ApiClient (HTTP請求、Token管理、錯誤處理)
├── CacheManager (快取策略)
└── StateManager (狀態管理)
```

### 1.5.2 HTTP客戶端配置

**基礎配置:**
```dart
class ApiClient {
  static const String baseUrl = 'https://lcas-api.replit.app';
  static const Duration timeout = Duration(seconds: 30);
  static const int maxRetries = 3;
  
  // JWT Token自動管理
  // 請求攔截器添加認證標頭
  // 回應攔截器處理401刷新Token
  // 錯誤攔截器統一錯誤處理
}
```

**認證流程:**
```
用戶登入 → 取得JWT Token → 儲存至SecureStorage
→ 每次API請求自動附加Token → Token過期自動刷新
→ 刷新失敗自動導向登入頁面
```

### 1.5.3 API端點映射策略

| API功能群組 | 對應Flutter Service | 主要UI頁面 | 快取策略 |
|------------|-------------------|-----------|----------|
| F001-F005認證管理 (5個API) | AuthService | 登入/註冊頁面群組 | Token安全儲存 |
| F006-F009基礎記帳 | EntryService | 記帳頁面群組 | 即時同步 |
| F010-F015多帳本管理 | ProjectLedgerService | 專案管理頁面群組 | 5分鐘快取 |
| F016-F018預算管理 | BudgetService | 預算頁面群組 | 10分鐘快取 |
| F019-F021協作功能 | CollaborationService | 協作頁面群組 | 即時同步 |
| F022-F024報表功能 | ReportService | 報表頁面群組 | 30分鐘快取 |
| F025-F032系統管理 | SystemService | 設定頁面群組 | 1小時快取 |

---

## 2.0 功能需求（Functional Requirements）

### 2.1 核心頁面功能（基於API端點）

#### 2.1.1 使用者註冊與認證頁面群組 (F001-F005)

**F001 - 使用者註冊API**
- 註冊表單：姓名、電子信箱、密碼、確認密碼
- 即時驗證：信箱格式、密碼強度、重複確認
- 註冊成功自動導向模式測評頁面

**F002 - 使用者登入API**  
- 登入表單：信箱/用戶名、密碼
- 記住登入狀態選項
- 生物辨識快速登入（指紋/Face ID）

**F003 - 取得使用者資料API**
- 個人資料頁面：頭像、姓名、信箱、註冊日期
- 支援頭像上傳和個人資料編輯
- 帳戶統計資訊：記帳天數、總筆數、使用模式

**F004 - 更新使用者資料API**
- 個人資料編輯表單：姓名、頭像、偏好設定
- 即時儲存和驗證回饋
- 修改確認提示和復原機制

**F005 - 使用者登出API**
- 安全登出確認對話框
- 清除本地快取和敏感資料
- 返回登入頁面

#### 2.1.2 基礎記帳頁面群組 (F006-F009)

**F006 - 記帳記錄建立API**
- 智慧記帳表單：金額、科目、日期、備註
- 四模式差異化輸入介面
- 即時計算和預算提醒

**F007 - APP記帳功能API**
- 快速記帳模式：大型數字鍵盤、常用科目
- 語音記帳功能：語音轉文字記帳
- 拍照記帳：收據OCR識別

**F008 - 記帳記錄查詢API**
- 記帳歷史列表：分頁載入、搜尋篩選
- 多維度篩選：日期範圍、科目、金額區間
- 排序選項：時間、金額、科目

**F009 - 記帳記錄更新/刪除API**
- 記帳記錄編輯：支援批量編輯
- 刪除確認機制：防誤刪保護
- 操作歷史記錄：支援復原功能

#### 2.1.3 多帳本管理頁面群組 (F010-F015)

**F010 - 專案帳本建立API**
- 專案建立精靈：名稱、描述、預算、期間
- 範本選擇：旅遊、裝修、活動等預設範本
- 成員邀請：支援邀請碼和QR Code分享

**F011-F015 - 專案帳本管理APIs**
- 專案儀表板：進度概覽、成員狀態、預算使用
- 專案記帳：專案專屬記帳介面
- 成員管理：權限設定、活動狀態
- 專案報表：專案專屬分析報表

### 2.2 進階功能頁面（API端點支援）

#### 2.2.1 預算管理頁面群組 (F016-F018)

**F016 - 預算設定建立API**
- 預算設定精靈：科目別預算、月度/年度預算
- 智慧預算建議：基於歷史資料推薦
- 預算範本：常見預算類型快速設定

**F017-F018 - 預算管理APIs**
- 預算追蹤儀表板：實際 vs 預算對比
- 預算預警系統：接近上限自動提醒
- 預算調整工具：動態調整和優化建議

#### 2.2.2 協作功能頁面群組 (F019-F021)

**F019 - 共享帳本建立API**
- 共享帳本精靈：類型選擇、成員設定、權限配置
- 邀請機制：邀請碼、QR Code、深度連結
- 初始設定：共同科目、分攤規則

**F020-F021 - 協作管理APIs**
- 協作儀表板：成員活動、即時同步狀態
- 權限管理介面：管理員/記帳者/檢視者權限設定
- 衝突解決機制：同時編輯衝突處理

#### 2.2.3 報表功能頁面群組 (F022-F024)

**F022 - 標準報表產出API**
- 報表中心：收支報表、科目分析、趨勢圖表
- 互動式圖表：可縮放、可篩選、可鑽取
- 報表匯出：PDF、Excel、圖片格式

**F023-F024 - 進階報表APIs**
- 自訂報表建構器：拖拽式報表設計
- 比較分析：期間對比、預算對比、專案對比
- 預測分析：基於趨勢的未來預測

#### 2.2.4 系統管理頁面群組 (F025-F032)

**F025-F032 - 系統功能APIs**
- 排程提醒設定：個人化提醒時間和頻率
- 資料備份與同步：自動備份、手動匯出入
- 通知管理：推播設定、EMAIL通知
- 系統設定：主題、語言、隱私設定

---

## 2.5 32個端點UI對應表

### 2.5.1 認證管理群組 (F001-F005)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F001 | 註冊頁面 | 帳號註冊流程 | 引導文案差異化 |
| F002 | 登入頁面 | 身份驗證 | 生物辨識支援程度 |
| F003 | 個人資料頁面 | 使用者資訊顯示 | 資訊詳細程度差異 |
| F004 | 個人資料編輯頁面 | 資料更新 | 設定選項複雜度 |
| F005 | 登出確認對話框 | 安全登出 | 確認流程複雜度 |

### 2.5.2 基礎記帳群組 (F006-F009)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F006 | 記帳表單頁面 | 建立記帳記錄 | 表單複雜度大幅差異 |
| F007 | APP記帳頁面 | 快速記帳 | 輸入方式差異化 |
| F008 | 記帳歷史頁面 | 記錄查詢 | 篩選功能複雜度 |
| F009 | 記錄編輯頁面 | 記錄修改/刪除 | 批量操作支援度 |

### 2.5.3 多帳本管理群組 (F010-F015)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F010 | 專案建立精靈 | 專案帳本建立 | 設定步驟複雜度 |
| F011 | 專案儀表板 | 專案總覽 | 儀表板資訊密度 |
| F012 | 專案記帳頁面 | 專案記帳 | 專案功能可見性 |
| F013 | 專案成員管理 | 成員權限設定 | 權限設定詳細度 |
| F014 | 專案報表頁面 | 專案分析 | 報表複雜度 |
| F015 | 專案設定頁面 | 專案管理 | 管理功能完整度 |

### 2.5.4 預算管理群組 (F016-F018)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F016 | 預算設定精靈 | 預算建立 | 設定精細度 |
| F017 | 預算追蹤儀表板 | 預算監控 | 視覺化複雜度 |
| F018 | 預算分析頁面 | 預算報表 | 分析深度差異 |

### 2.5.5 協作功能群組 (F019-F021)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F019 | 共享帳本建立 | 協作設定 | 協作功能複雜度 |
| F020 | 協作儀表板 | 協作狀態 | 協作資訊詳細度 |
| F021 | 權限管理頁面 | 成員權限 | 權限控制精細度 |

### 2.5.6 報表功能群組 (F022-F024)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F022 | 標準報表中心 | 基礎報表 | 報表類型豐富度 |
| F023 | 自訂報表建構器 | 進階報表 | 自訂功能複雜度 |
| F024 | 報表匯出頁面 | 報表輸出 | 匯出選項多樣性 |

### 2.5.7 系統管理群組 (F025-F032)

| API端點 | 對應UI頁面 | 主要功能 | 四模式差異 |
|---------|------------|----------|------------|
| F025 | 排程提醒設定 | 提醒管理 | 提醒設定精細度 |
| F026 | 資料備份頁面 | 資料管理 | 備份選項複雜度 |
| F027 | 通知設定頁面 | 通知管理 | 通知類型豐富度 |
| F028 | 主題設定頁面 | 視覺客製化 | 主題選項多樣性 |
| F029 | 隱私設定頁面 | 隱私控制 | 隱私選項詳細度 |
| F030 | 匯入匯出頁面 | 資料轉移 | 格式支援度 |
| F031 | 系統診斷頁面 | 系統狀態 | 診斷資訊詳細度 |
| F032 | 關於頁面 | 應用資訊 | 技術資訊詳細度 |

---

## 3.0 四模式UI差異化設計

### 3.1 視覺語言設計（基於API功能複雜度）

| 設計元素 | 精準控制者 | 紀錄習慣者 | 轉型挑戰者 | 潛在覺醒者 |
|----------|------------|------------|------------|------------|
| **API存取度** | 100% (32個端點) | 70% (22個端點) | 85% (27個端點) | 50% (16個端點) |
| **色彩主調** | 商業藍/深灰 | 櫻花粉/湖水藍 | 活力橙/青草綠 | 溫暖米/淺灰 |
| **字體選擇** | SF Pro/Roboto | 圓角字體 | 活力字體 | 友善字體 |
| **圖示風格** | 線性專業 | 面性美感 | 立體活潑 | 簡約友善 |
| **間距密度** | 緊湊高效 | 舒適優雅 | 適中平衡 | 寬鬆簡潔 |
| **表單複雜度** | 多欄位進階表單 | 美感簡化表單 | 步驟式引導表單 | 極簡單一表單 |

### 3.2 導航架構差異（對應API功能群組）

#### 3.2.1 精準控制者導航（完整API存取）
```
多層級專業導航 - 支援32個API端點
├── 專業儀表板 (F011,F017,F020,F022整合)
├── 記帳管理 → 基礎記帳(F006-F009) → 專案記帳(F010-F015)
├── 預算控制 → 預算設定(F016) → 追蹤分析(F017-F018)
├── 協作中心 → 共享設定(F019) → 權限管理(F020-F021)
├── 報表中心 → 標準報表(F022) → 自訂報表(F023-F024)
├── 專案管理 → 專案建立(F010) → 成員管理(F013) → 專案設定(F015)
└── 系統設定 → 進階設定(F025-F032) → API整合
```

#### 3.2.2 紀錄習慣者導航（精選API存取）
```
扁平化美感導航 - 支援22個精選API端點
├── 美感主頁 (F003,F008整合)
├── 優雅記帳 → 快速記帳(F007) → 記帳歷史(F008)
├── 月度美圖 → 標準報表(F022) → 視覺化展示
├── 專案參與 → 共享帳本(F019) → 簡化協作(F020)
├── 預算關懷 → 預算追蹤(F017) → 溫和提醒
└── 美感設定 → 主題選擇(F028) → 個人化(F004)
```

#### 3.2.3 轉型挑戰者導航（階段式API解鎖）
```
階段性解鎖導航 - 支援27個API端點（漸進開放）
├── 挑戰主頁 (進度整合儀表板)
├── 習慣養成 → 記帳打卡(F007) → 進度追蹤(F008)
├── 目標設定 → 預算設定(F016) → 挑戰追蹤(F017)
├── 專案挑戰 → 專案建立(F010) → 團隊協作(F019-F021)
├── 成就中心 → 成就解鎖 → 報表分析(F022-F023)
└── 激勵設定 → 提醒設定(F025) → 社群分享
```

#### 3.2.4 潛在覺醒者導航（核心API友善引導）
```
單一路徑引導 - 支援16個核心API端點
├── 友善歡迎 (F003簡化顯示)
├── 零門檻記帳 → 簡易記帳(F007) → 溫和確認
├── 溫和分析 → 基礎報表(F022) → 故事化呈現
├── 輕鬆分享 → 簡易共享(F019) → 一鍵邀請
└── 簡單設定 → 基本設定(F004,F028) → 引導完成
```

---

## 3.5 四模式API權限矩陣

### 3.5.1 API存取權限控制表

| API功能群組 | 精準控制者 | 紀錄習慣者 | 轉型挑戰者 | 潛在覺醒者 | 備註 |
|------------|------------|------------|------------|------------|------|
| **認證管理 (F001-F005)** | ✅完整存取 | ✅完整存取 | ✅完整存取 | ✅完整存取 | 基礎功能全模式支援 |
| **基礎記帳 (F006-F009)** | ✅完整存取 | ✅完整存取 | ✅完整存取 | 🔸簡化存取 | 覺醒者隱藏進階篩選 |
| **多帳本管理 (F010-F015)** | ✅完整存取 | 🔸限制存取 | ✅完整存取 | 🔸簡化存取 | 習慣者/覺醒者限制管理功能 |
| **預算管理 (F016-F018)** | ✅完整存取 | 🔸限制存取 | ✅完整存取 | ⭕階段解鎖 | 覺醒者需達成條件解鎖 |
| **協作功能 (F019-F021)** | ✅完整存取 | 🔸限制存取 | ✅完整存取 | 🔸簡化存取 | 習慣者/覺醒者簡化權限管理 |
| **報表功能 (F022-F024)** | ✅完整存取 | 🔸限制存取 | ✅完整存取 | 🔸簡化存取 | 習慣者/覺醒者僅標準報表 |
| **系統管理 (F025-F032)** | ✅完整存取 | 🔸限制存取 | 🔸限制存取 | 🔸簡化存取 | 診斷功能僅控制者可見 |

**圖例說明:**
- ✅ 完整存取：API端點100%功能可用
- 🔸 限制存取：API端點部分功能簡化或隱藏
- 🔸 簡化存取：API端點大幅簡化，僅核心功能
- ⭕ 階段解鎖：需滿足特定條件才能存取

### 3.5.2 動態權限升級機制

#### 潛在覺醒者 → 轉型挑戰者
**解鎖條件:**
- 連續記帳7天 → 解鎖預算管理 (F016-F018)
- 建立第一個專案 → 解鎖協作功能 (F020-F021)
- 查看報表5次 → 解鎖自訂報表 (F023-F024)

#### 紀錄習慣者 → 精準控制者
**解鎖條件:**
- 使用專案功能30天 → 解鎖進階專案管理 (F013-F015)
- 建立5個預算 → 解鎖預算分析 (F018)
- 匯出報表10次 → 解鎖自訂報表 (F023-F024)

#### 轉型挑戰者權限漸進開放
**30天內漸進解鎖:**
- Day 1-7: 基礎功能 (F001-F009)
- Day 8-14: 專案功能 (F010-F012)
- Day 15-21: 預算功能 (F016-F017)
- Day 22-30: 完整功能 (F001-F032)

### 3.5.3 API調用頻率限制

| 使用者模式 | 每分鐘調用限制 | 每日調用限制 | 特殊限制 |
|------------|----------------|--------------|----------|
| 精準控制者 | 120次/分鐘 | 10000次/日 | 無限制 |
| 紀錄習慣者 | 60次/分鐘 | 5000次/日 | 報表生成5次/日 |
| 轉型挑戰者 | 90次/分鐘 | 7500次/日 | 專案建立3個/日 |
| 潛在覺醒者 | 30次/分鐘 | 2000次/日 | 記帳10次/日上限 |

---

## 4.0 頁面架構與導航

### 4.1 頁面層次架構（基於API功能群組）

```
LCAS Flutter App 頁面架構 - API驅動設計
├── 入口層 (Entry Layer) - F001-F005 API支援
│   ├── 啟動畫面 (Splash Screen)
│   ├── 歡迎頁面 (Welcome Page)
│   ├── 登入驗證 (Authentication) → F002 API
│   ├── 註冊流程 (Registration) → F001 API
│   └── 模式測評 (Mode Assessment) → F003 API整合
│
├── 主功能層 (Main Feature Layer) - 依API群組分類
│   ├── 四模式主頁 (Mode-specific Home)
│   │   ├── 精準控制者儀表板 → F011,F017,F022 API整合
│   │   ├── 紀錄習慣者美感首頁 → F008,F022 API簡化
│   │   ├── 轉型挑戰者進度中心 → F017,進度API整合
│   │   └── 潛在覺醒者友善首頁 → F003,F008 API基礎
│   │
│   ├── 記帳功能群組 (Entry Feature Group) - F006-F009 API
│   │   ├── 基礎記帳頁面 → F006 API
│   │   ├── APP快速記帳 → F007 API
│   │   ├── 記帳歷史查詢 → F008 API
│   │   └── 記錄編輯管理 → F009 API
│   │
│   ├── 專案管理群組 (Project Management Group) - F010-F015 API
│   │   ├── 專案建立精靈 → F010 API
│   │   ├── 專案儀表板 → F011 API
│   │   ├── 專案記帳介面 → F012 API
│   │   ├── 成員權限管理 → F013 API
│   │   ├── 專案報表中心 → F014 API
│   │   └── 專案設定頁面 → F015 API
│   │
│   ├── 預算管理群組 (Budget Management Group) - F016-F018 API
│   │   ├── 預算設定精靈 → F016 API
│   │   ├── 預算追蹤儀表板 → F017 API
│   │   └── 預算分析報表 → F018 API
│   │
│   ├── 協作管理群組 (Collaboration Group) - F019-F021 API
│   │   ├── 共享帳本建立 → F019 API
│   │   ├── 協作狀態儀表板 → F020 API
│   │   └── 權限管理中心 → F021 API
│   │
│   └── 分析報表群組 (Analytics Group) - F022-F024 API
│       ├── 標準報表中心 → F022 API
│       ├── 自訂報表建構器 → F023 API
│       └── 報表匯出管理 → F024 API
│
├── 設定管理層 (Settings Layer) - F025-F032 API
│   ├── 個人設定 → F004 API (使用者資料更新)
│   ├── 模式切換 → F003 API (使用者資料取得)
│   ├── 主題設定 → F028 API
│   ├── 排程提醒設定 → F025 API
│   ├── 通知管理 → F027 API
│   ├── 隱私設定 → F029 API
│   ├── 資料備份 → F026 API
│   ├── 匯入匯出 → F030 API
│   ├── 系統診斷 → F031 API
│   └── 關於應用 → F032 API
│
└── 支援服務層 (Support Layer)
    ├── 錯誤處理頁面 (統一API錯誤處理)
    ├── 離線模式 (本地快取API數據)
    ├── 幫助中心 (API功能說明)
    └── 載入狀態 (API請求狀態管理)
```

### 4.2 跨平台頁面銜接（API狀態同步）

#### 4.2.1 LINE OA → Flutter APP 深度連結
```
深度連結參數傳遞架構:
├── 統一URL Scheme: lcas://function/{api_endpoint}
├── 參數編碼: Base64編碼確保數據完整性
├── 狀態驗證: JWT Token驗證用戶身份
└── API同步: 啟動時調用F003取得最新狀態
```

**深度連結對應表:**
- `lcas://entry/quick` → 快速記帳頁面 (F007 API)
- `lcas://project/{id}` → 專案儀表板 (F011 API)
- `lcas://budget/track` → 預算追蹤 (F017 API)
- `lcas://report/standard` → 標準報表 (F022 API)

#### 4.2.2 API狀態管理架構
```
Flutter狀態管理 - API驅動
├── 全域狀態 (Global State)
│   ├── 認證狀態 → F002/F005 API管理
│   ├── 使用者資料狀態 → F003/F004 API管理
│   └── 模式設定狀態 → F003 API整合
│
├── 功能狀態 (Feature State)  
│   ├── 記帳操作狀態 → F006-F009 API管理
│   ├── 專案狀態 → F010-F015 API管理
│   ├── 預算狀態 → F016-F018 API管理
│   ├── 協作狀態 → F019-F021 API管理
│   └── 報表狀態 → F022-F024 API管理
│
└── UI狀態 (UI State)
    ├── 載入狀態 → 統一API請求狀態
    ├── 錯誤狀態 → 統一API錯誤處理
    └── 快取狀態 → API數據本地快取
```

### 4.3 頁面轉場設計（API回應優化）

| 轉場情境 | 動畫類型 | 持續時間 | API最佳化 | 適用模式 |
|----------|----------|----------|-----------|----------|
| API載入轉場 | Skeleton + Fade | 直到API回應 | 預載入快取 | 所有模式 |
| 頁面前進 | Slide Right | 300ms | 預取下頁API | 所有模式 |
| 頁面後退 | Slide Left | 250ms | 保持快取狀態 | 所有模式 |
| 模態彈出 | Scale + Fade | 200ms | 即時API驗證 | 精準控制者/轉型挑戰者 |
| 美感確認 | Bounce + Glow | 400ms | 延遲API同步 | 紀錄習慣者 |
| 成就解鎖 | Confetti + Scale | 600ms | 背景API統計 | 轉型挑戰者 |
| 溫和提示 | Gentle Fade | 300ms | 靜默API更新 | 潛在覺醒者 |

---

## 5.0 元件庫規範

### 5.1 API整合元件

#### 5.1.1 API請求元件
- **ApiButton**: 整合API請求狀態的操作按鈕
  - 載入狀態：旋轉指示器
  - 成功狀態：勾選動畫
  - 錯誤狀態：錯誤提示
  - 重試機制：自動重試3次

- **ApiForm**: 整合API驗證的表單元件
  - 即時驗證：前端+後端雙重驗證
  - 錯誤顯示：API錯誤訊息整合
  - 自動儲存：定時調用API儲存草稿
  - 離線支援：離線時本地暫存

- **ApiList**: 整合分頁API的列表元件
  - 無限滾動：自動載入下一頁API
  - 下拉刷新：調用API刷新數據
  - 搜尋整合：即時調用搜尋API
  - 快取管理：智慧快取和失效處理

#### 5.1.2 API狀態元件
- **ApiStateWrapper**: 統一API狀態處理包裝器
  - 載入狀態：骨架屏或載入指示器
  - 錯誤狀態：錯誤頁面和重試按鈕
  - 空狀態：空數據引導頁面
  - 成功狀態：正常內容顯示

### 5.2 通用基礎元件（API支援）

#### 5.2.1 導航元件
- **AppBar**: 整合API通知的應用欄
  - 通知徽章：即時API通知計數
  - 用戶頭像：F003 API取得用戶資料
  - 搜尋功能：整合F008搜尋API
  - 設定入口：連接F025-F032設定API

- **TabBar**: API狀態感知的標籤欄
  - 徽章指示：未讀API數據提示
  - 動態標籤：基於API權限動態顯示
  - 載入狀態：API請求時的載入指示
  - 離線指示：API無法存取時的視覺提示

#### 5.2.2 輸入元件（API整合）
- **AmountInput**: 整合F006/F007記帳API的金額輸入
  - 即時計算：與預算API (F017)整合檢查
  - 格式驗證：前端格式化+API伺服器驗證
  - 歷史建議：基於F008 API的歷史金額建議
  - 快速填入：常用金額API快取

- **CategoryPicker**: 整合科目API的分類選擇器
  - 動態載入：從API載入可用科目
  - 搜尋功能：API驅動的科目搜尋
  - 自訂科目：調用API建立新科目
  - 使用統計：基於API統計的常用科目排序

### 5.3 模式專屬元件（API功能對應）

#### 5.3.1 精準控制者專屬元件
- **ProjectDashboard**: 多項目總覽儀表板
  - API整合：F011 (專案總覽) + F017 (預算狀態) + F022 (報表數據)
  - 即時更新：WebSocket或定時API輪詢
  - 互動圖表：點擊圖表元素調用詳細API
  - 批量操作：整合多個管理API的批量處理

- **DataTable**: 專業數據表格
  - API分頁：整合F008等查詢API的分頁功能
  - 即時篩選：每次篩選調用API重新查詢
  - 排序功能：API端排序提升效能
  - 匯出功能：整合F024報表匯出API

#### 5.3.2 紀錄習慣者專屬元件
- **AestheticCard**: 美感資訊卡片
  - API驅動：美感主題從F028 API取得
  - 動畫互動：配合API回應時機的美感動畫
  - 資料綁定：與F008記帳歷史API完美整合
  - 季節主題：基於時間API自動切換主題

#### 5.3.3 轉型挑戰者專屬元件
- **ProgressRing**: 挑戰進度指示器
  - API驅動：進度數據從F017預算API計算
  - 動畫反饋：API更新成功時的進度動畫
  - 目標設定：整合F016預算設定API
  - 激勵提示：基於進度API的個人化激勵

#### 5.3.4 潛在覺醒者專屬元件
- **SimpleButton**: 友善操作按鈕
  - API簡化：隱藏複雜API參數，使用預設值
  - 一鍵操作：單次點擊完成API調用流程
  - 溫和確認：API操作前的友善確認提示
  - 即時回饋：API成功後的溫暖回饋動畫

---

## 6.0 使用者體驗設計

### 6.1 API驅動的情感化設計策略

#### 6.1.1 精準控制者體驗（完整API支援）
- **專業信賴感**: 完整的API功能存取展現專業可靠
- **效率成就感**: API批量操作和快速回應提升效率感
- **掌控滿足感**: 所有32個API端點的完整控制權
- **深度分析感**: 複雜API查詢和報表生成的專業體驗

**API體驗設計重點:**
- 同時調用多個API的聚合儀表板
- API調用進度和效能監控顯示
- 複雜API參數的直觀設定介面
- API錯誤的詳細技術資訊顯示

#### 6.1.2 紀錄習慣者體驗（精選API簡化）
- **美感愉悅感**: 精選API的美感化資料呈現
- **儀式滿足感**: API操作完成的美感回饋動畫
- **安心信賴感**: API自動備份的安全感視覺化
- **優雅效率感**: 簡化API流程的優雅體驗

**API體驗設計重點:**
- 隱藏API複雜性，呈現美感結果
- API成功回應的優雅動畫設計
- 簡化API參數選擇，預設美感配置
- API數據的美感視覺化呈現

#### 6.1.3 轉型挑戰者體驗（階段式API解鎖）
- **激勵動力感**: API功能解鎖的成就感設計
- **社群歸屬感**: 協作API的社交互動體驗
- **成長成就感**: API使用熟練度的進步追蹤
- **挑戰克服感**: 複雜API功能的階段式征服

**API體驗設計重點:**
- API功能解鎖的遊戲化設計
- API使用統計的成就追蹤系統
- 協作API的即時互動和激勵
- API學習進度的視覺化展示

#### 6.1.4 潛在覺醒者體驗（核心API友善引導）
- **友善安全感**: 簡化API操作的安全感設計
- **發現驚喜感**: API數據洞察的故事化呈現
- **漸進自信感**: API功能理解的循序漸進
- **溫暖支持感**: API操作指導的溫暖語調

**API體驗設計重點:**
- 極簡化API操作流程設計
- API結果的故事化和情境化呈現
- 溫和的API功能引導和教學
- API錯誤的友善解釋和協助

### 6.2 API回應時間的UX優化

#### 6.2.1 API載入狀態設計
```
API回應時間優化策略:
├── < 100ms: 無載入指示器，即時回應
├── 100ms-1s: 微小載入動畫，保持互動感
├── 1s-3s: 骨架屏載入，預覽內容結構
├── 3s-10s: 進度指示器，顯示預估完成時間
└── > 10s: 背景處理，允許用戶繼續其他操作
```

#### 6.2.2 API錯誤狀態設計
```
統一API錯誤處理UX:
├── 網路錯誤: 離線模式提示，本地快取替代
├── 伺服器錯誤: 友善錯誤說明，自動重試機制
├── 認證錯誤: 溫和重新登入引導
├── 權限錯誤: 功能升級建議，模式切換引導
└── 數據錯誤: 數據修正建議，替代方案提供
```

### 6.3 API數據的個人化適應

#### 6.3.1 智慧API推薦
- **使用行為分析**: 追蹤API調用頻率和成功率
- **個人化API順序**: 基於使用頻率調整功能排序
- **智慧預設值**: 基於歷史API數據提供智慧預設
- **功能推薦**: 基於API使用模式推薦新功能

#### 6.3.2 API使用輔助
- **操作引導**: 首次使用API的步驟引導
- **快捷設定**: 常用API操作的快捷方式
- **批量操作**: 多個相關API的批量處理
- **操作歷史**: API操作記錄和快速重複

---

## 7.0 技術架構需求

### 7.1 Flutter架構規範（API整合優化）

#### 7.1.1 架構模式
```
MVVM + Repository + API Layer Architecture
├── Presentation Layer (UI/Widget)
│   ├── Pages: 對應32個API端點的UI頁面
│   ├── Widgets: 可重用的API整合UI元件
│   └── State Management: Provider/Riverpod API狀態管理
│
├── Domain Layer (Business Logic)
│   ├── Entities: API回應數據的業務實體
│   ├── Use Cases: API調用的業務邏輯封裝
│   └── Repositories: API數據存取的抽象介面
│
├── Data Layer (API Integration)
│   ├── Data Sources: 遠端API + 本地快取數據源
│   ├── Repositories: Repository接口的具體實現
│   ├── Models: API請求/回應的數據模型
│   └── API Services: 32個API端點的服務封裝
│
└── Infrastructure Layer (Core Services)
    ├── HTTP Client: 統一的API請求客戶端
    ├── Local Storage: 本地快取和離線儲存
    ├── Authentication: JWT Token管理和刷新
    └── Error Handling: 統一API錯誤處理機制
```

#### 7.1.2 核心依賴需求（API整合）
```yaml
dependencies:
  # Flutter SDK
  flutter: 
    sdk: flutter
  
  # HTTP & API
  dio: ^5.3.2                    # HTTP客戶端，支援攔截器
  retrofit: ^4.0.3               # 類型安全的API客戶端生成
  json_annotation: ^4.8.1        # JSON序列化註解
  
  # 狀態管理
  provider: ^6.1.1               # 狀態管理方案
  riverpod: ^2.4.9              # 進階狀態管理（可選）
  
  # 本地儲存
  shared_preferences: ^2.2.2     # 用戶偏好設定
  flutter_secure_storage: ^9.0.0 # 安全儲存（JWT Token）
  hive: ^2.2.3                   # 高效本地數據庫
  
  # UI & 工具
  flutter_svg: ^2.0.9           # SVG圖示支援
  cached_network_image: ^3.3.0   # 網路圖片快取
  connectivity_plus: ^5.0.2      # 網路連線狀態
  
dev_dependencies:
  # 代碼生成
  build_runner: ^2.4.7          # 代碼生成工具
  json_serializable: ^6.7.1     # JSON序列化代碼生成
  retrofit_generator: ^8.0.4     # API客戶端代碼生成
  
  # 測試
  mockito: ^5.4.2               # Mock測試
  http_mock_adapter: ^0.4.4     # HTTP Mock測試
```

### 7.2 API整合架構實現

#### 7.2.1 統一API客戶端設計
```dart
// lib/core/api/api_client.dart
@RestApi(baseUrl: 'https://lcas-api.replit.app/api/v1')
abstract class ApiClient {
  factory ApiClient(Dio dio, {String baseUrl}) = _ApiClient;
  
  // 認證管理群組 (F001-F005)
  @POST('/auth/register')
  Future<ApiResponse<User>> registerUser(@Body() RegisterRequest request);
  
  @POST('/auth/login')  
  Future<ApiResponse<LoginResponse>> loginUser(@Body() LoginRequest request);
  
  @GET('/auth/user')
  Future<ApiResponse<User>> getUserProfile();
  
  @PUT('/auth/user')
  Future<ApiResponse<User>> updateUserProfile(@Body() UpdateUserRequest request);
  
  @POST('/auth/logout')
  Future<ApiResponse<void>> logoutUser();
  
  // 基礎記帳群組 (F006-F009)
  @POST('/entries')
  Future<ApiResponse<Entry>> createEntry(@Body() CreateEntryRequest request);
  
  @POST('/entries/quick')
  Future<ApiResponse<Entry>> quickEntry(@Body() QuickEntryRequest request);
  
  @GET('/entries')
  Future<ApiResponse<PaginatedEntries>> getEntries(@Queries() EntryQueryParams params);
  
  @PUT('/entries/{id}')
  Future<ApiResponse<Entry>> updateEntry(@Path() String id, @Body() UpdateEntryRequest request);
  
  @DELETE('/entries/{id}')
  Future<ApiResponse<void>> deleteEntry(@Path() String id);
  
  // 繼續定義其他28個API端點...
}
```

#### 7.2.2 統一錯誤處理機制
```dart
// lib/core/api/api_error_handler.dart
class ApiErrorHandler {
  static AppException handleError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return NetworkException('網路連線逾時，請檢查網路狀態');
      
      case DioExceptionType.badResponse:
        return _handleHttpError(error.response!);
      
      case DioExceptionType.connectionError:
        return NetworkException('無法連線到伺服器，請檢查網路設定');
      
      default:
        return UnknownException('未知錯誤，請稍後再試');
    }
  }
  
  static AppException _handleHttpError(Response response) {
    switch (response.statusCode) {
      case 400:
        return BadRequestException('請求格式錯誤');
      case 401:
        return UnauthorizedException('認證失敗，請重新登入');
      case 403:
        return ForbiddenException('權限不足，無法執行此操作');
      case 404:
        return NotFoundException('找不到請求的資源');
      case 500:
        return ServerException('伺服器內部錯誤');
      default:
        return HttpException('HTTP錯誤 ${response.statusCode}');
    }
  }
}
```

#### 7.2.3 JWT Token自動管理
```dart
// lib/core/api/auth_interceptor.dart
class AuthInterceptor extends Interceptor {
  final TokenRepository _tokenRepository;
  
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    final token = _tokenRepository.getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }
  
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode == 401) {
      // Token過期，嘗試刷新
      final refreshed = await _tokenRepository.refreshToken();
      if (refreshed) {
        // 重試原始請求
        final options = err.requestOptions;
        options.headers['Authorization'] = 'Bearer ${_tokenRepository.getAccessToken()}';
        try {
          final response = await Dio().fetch(options);
          handler.resolve(response);
          return;
        } catch (e) {
          // 重試失敗，執行登出
        }
      }
      // Token刷新失敗，導向登入頁面
      _tokenRepository.clearTokens();
      NavigationService.pushAndClearStack('/login');
    }
    handler.next(err);
  }
}
```

### 7.3 本地快取與離線策略

#### 7.3.1 本地儲存架構
```dart
// lib/core/storage/local_storage.dart
abstract class LocalStorage {
  // 用戶偏好設定 (SharedPreferences)
  Future<void> saveUserPreferences(UserPreferences preferences);
  Future<UserPreferences?> getUserPreferences();
  
  // 安全儲存 (FlutterSecureStorage)  
  Future<void> saveSecureData(String key, String value);
  Future<String?> getSecureData(String key);
  
  // 結構化數據快取 (Hive)
  Future<void> cacheApiResponse<T>(String key, T data, Duration expiry);
  Future<T?> getCachedData<T>(String key);
  Future<bool> isCacheValid(String key);
  Future<void> invalidateCache(String key);
}
```

#### 7.3.2 API快取策略
```dart
// lib/core/cache/api_cache_strategy.dart
enum CacheStrategy {
  cacheFirst,    // 優先使用快取，快取失效才請求API
  networkFirst,  // 優先請求API，失敗才使用快取
  cacheOnly,     // 僅使用快取，不請求API
  networkOnly,   // 僅請求API，不使用快取
}

class ApiCacheManager {
  static const Map<String, CacheConfig> _cacheConfigs = {
    // 用戶資料 - 中等頻率快取
    'GET:/auth/user': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(minutes: 30),
    ),
    
    // 記帳歷史 - 短期快取
    'GET:/entries': CacheConfig(
      strategy: CacheStrategy.networkFirst, 
      expiry: Duration(minutes: 5),
    ),
    
    // 報表數據 - 長期快取
    'GET:/reports': CacheConfig(
      strategy: CacheStrategy.cacheFirst,
      expiry: Duration(hours: 1),
    ),
    
    // 即時數據 - 不快取
    'POST:/entries': CacheConfig(
      strategy: CacheStrategy.networkOnly,
    ),
  };
}
```

---

## 7.5 離線與同步策略

### 7.5.1 離線功能支援範圍

#### 完全離線支援（本地操作+同步佇列）
- **F006 記帳記錄建立**: 離線建立，上線後自動同步
- **F007 APP記帳功能**: 完整離線操作，批量同步
- **F009 記帳記錄更新/刪除**: 離線修改，衝突檢測同步

#### 快取離線支援（僅查詢功能）
- **F003 取得使用者資料**: 快取最後一次成功回應
- **F008 記帳記錄查詢**: 快取查詢結果，支援離線瀏覽
- **F022 標準報表產出**: 快取報表數據，離線查看

#### 線上限定功能（需網路連線）
- **F001 使用者註冊**: 需要即時驗證和帳號建立
- **F002 使用者登入**: 需要伺服器認證和Token發放
- **F019-F021 協作功能**: 需要即時同步和衝突解決
- **F025-F032 系統管理**: 需要伺服器端設定同步

### 7.5.2 離線同步架構

```dart
// lib/core/sync/offline_sync_manager.dart
class OfflineSyncManager {
  final LocalDatabase _localDb;
  final ApiClient _apiClient;
  final ConnectivityService _connectivity;
  
  // 離線操作佇列
  Queue<OfflineOperation> _syncQueue = Queue();
  
  // 監聽網路狀態變化
  void initializeSync() {
    _connectivity.onConnectivityChanged.listen((connected) {
      if (connected) {
        _processSyncQueue();
      }
    });
  }
  
  // 離線操作入佇列
  Future<void> queueOperation(OfflineOperation operation) async {
    operation.timestamp = DateTime.now();
    operation.id = _generateOperationId();
    
    // 本地執行
    await _executeLocalOperation(operation);
    
    // 加入同步佇列
    _syncQueue.add(operation);
    await _persistSyncQueue();
    
    // 如果線上，立即嘗試同步
    if (await _connectivity.isConnected()) {
      _processSyncQueue();
    }
  }
  
  // 處理同步佇列
  Future<void> _processSyncQueue() async {
    while (_syncQueue.isNotEmpty) {
      final operation = _syncQueue.first;
      
      try {
        // 執行API同步
        await _executeRemoteOperation(operation);
        
        // 同步成功，移除佇列
        _syncQueue.removeFirst();
        await _persistSyncQueue();
        
      } catch (e) {
        // 同步失敗，稍後重試
        if (operation.retryCount < maxRetries) {
          operation.retryCount++;
          operation.nextRetry = _calculateNextRetry(operation.retryCount);
        } else {
          // 超過重試次數，標記為失敗
          operation.status = OperationStatus.failed;
        }
        break;
      }
    }
  }
}
```

### 7.5.3 衝突解決策略

#### 衝突檢測機制
```dart
class ConflictResolver {
  // 檢測數據衝突
  ConflictType detectConflict(LocalData local, RemoteData remote) {
    if (local.lastModified == remote.lastModified) {
      return ConflictType.none;
    }
    
    if (local.lastModified > remote.lastModified) {
      return ConflictType.localNewer;
    }
    
    if (remote.lastModified > local.lastModified) {
      return ConflictType.remoteNewer;
    }
    
    return ConflictType.concurrent;
  }
  
  // 自動解決策略
  Future<ResolvedData> autoResolve(ConflictType type, LocalData local, RemoteData remote) {
    switch (type) {
      case ConflictType.localNewer:
        return _useLocal(local);
      
      case ConflictType.remoteNewer:
        return _useRemote(remote);
      
      case ConflictType.concurrent:
        return _mergeData(local, remote);
      
      default:
        return _useRemote(remote);
    }
  }
}
```

#### 用戶衝突解決介面
```dart
// 衝突解決UI元件
class ConflictResolutionDialog extends StatelessWidget {
  final ConflictData conflictData;
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('數據衝突'),
      content: Column(
        children: [
          Text('發現數據衝突，請選擇處理方式：'),
          
          ConflictOptionCard(
            title: '使用本地版本',
            description: '保留您的最新修改',
            data: conflictData.localData,
            onSelected: () => _resolveWithLocal(),
          ),
          
          ConflictOptionCard(
            title: '使用雲端版本', 
            description: '使用伺服器上的最新版本',
            data: conflictData.remoteData,
            onSelected: () => _resolveWithRemote(),
          ),
          
          ConflictOptionCard(
            title: '手動合併',
            description: '手動選擇要保留的內容',
            onSelected: () => _showMergeInterface(),
          ),
        ],
      ),
    );
  }
}
```

### 7.5.4 同步狀態UI指示

```dart
// 同步狀態指示器
class SyncStatusIndicator extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<SyncStateProvider>(
      builder: (context, syncState, child) {
        return Container(
          padding: EdgeInsets.symmetric(horizontal: 12, vertical: 4),
          decoration: BoxDecoration(
            color: _getStatusColor(syncState.status),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              _getStatusIcon(syncState.status),
              SizedBox(width: 4),
              Text(
                _getStatusText(syncState.status),
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                  fontWeight: FontWeight.w500,
                ),
              ),
              if (syncState.pendingCount > 0) ...[
                SizedBox(width: 4),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    '${syncState.pendingCount}',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ],
          ),
        );
      },
    );
  }
  
  Color _getStatusColor(SyncStatus status) {
    switch (status) {
      case SyncStatus.synced:
        return Colors.green;
      case SyncStatus.syncing:
        return Colors.blue;
      case SyncStatus.offline:
        return Colors.orange;
      case SyncStatus.error:
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
  
  String _getStatusText(SyncStatus status) {
    switch (status) {
      case SyncStatus.synced:
        return '已同步';
      case SyncStatus.syncing:
        return '同步中';
      case SyncStatus.offline:
        return '離線模式';
      case SyncStatus.error:
        return '同步錯誤';
      default:
        return '未知狀態';
    }
  }
}
```

---

## 8.0 效能與品質要求

### 8.1 API效能指標要求

#### 8.1.1 API回應時間要求
| API功能群組 | 目標回應時間 | 最大可接受時間 | 快取策略 | 離線支援 |
|------------|--------------|----------------|----------|----------|
| **認證管理 (F001-F005)** | < 1秒 | < 3秒 | Token快取30分鐘 | 僅F003支援 |
| **基礎記帳 (F006-F009)** | < 500ms | < 2秒 | 即時同步 | 完整支援 |
| **多帳本管理 (F010-F015)** | < 1秒 | < 3秒 | 快取5分鐘 | 查詢功能支援 |
| **預算管理 (F016-F018)** | < 800ms | < 2秒 | 快取10分鐘 | 查詢功能支援 |
| **協作功能 (F019-F021)** | < 1秒 | < 3秒 | 即時同步 | 不支援 |
| **報表功能 (F022-F024)** | < 2秒 | < 10秒 | 快取30分鐘 | 查詢功能支援 |
| **系統管理 (F025-F032)** | < 1秒 | < 5秒 | 快取1小時 | 部分支援 |

#### 8.1.2 API併發處理要求
- **同時API請求數**: 最大5個併發請求
- **請求佇列管理**: 超過限制時自動排隊
- **優先級管理**: 用戶操作API優先於背景同步
- **請求去重**: 相同API請求300ms內去重

#### 8.1.3 API錯誤處理效能
- **自動重試**: 最多3次，間隔1s、2s、5s
- **熔斷機制**: 連續5次失敗後暫停30秒
- **降級服務**: API失敗時自動切換快取數據
- **錯誤恢復**: 網路恢復後自動重試失敗請求

### 8.2 使用者介面效能要求

#### 8.2.1 載入效能（API驅動）
- **冷啟動時間**: < 3秒（包含F003用戶資料載入）
- **熱啟動時間**: < 1秒（使用快取數據）
- **頁面切換時間**: < 300ms（預載入API數據）
- **API數據載入**: < 2秒（含視覺化處理）

#### 8.2.2 API載入狀態優化
```dart
// API載入效能優化策略
enum LoadingStrategy {
  // 骨架屏 - 適用於結構化數據API
  skeleton,     
  
  // 漸進載入 - 適用於列表API
  progressive,  
  
  // 預載入 - 適用於預測性API調用
  preload,      
  
  // 懶載入 - 適用於非關鍵API
  lazy,         
}

class ApiLoadingOptimizer {
  static LoadingStrategy getStrategy(String apiEndpoint) {
    switch (apiEndpoint) {
      case 'GET:/entries':
        return LoadingStrategy.progressive;
      case 'GET:/reports':
        return LoadingStrategy.skeleton;
      case 'GET:/auth/user':
        return LoadingStrategy.preload;
      default:
        return LoadingStrategy.lazy;
    }
  }
}
```

### 8.3 資料同步效能要求

#### 8.3.1 同步效能指標
- **增量同步效率**: 僅同步變更數據，減少90%傳輸量
- **衝突解決時間**: < 5秒完成自動衝突解決
- **離線佇列處理**: 1000筆離線操作< 30秒同步完成
- **實時同步延遲**: 協作操作< 2秒顯示在其他設備

#### 8.3.2 快取效能管理
- **快取命中率**: > 80%（常用API數據）
- **快取大小限制**: 最大100MB，自動清理過期數據
- **快取索引速度**: < 10ms完成快取查詢
- **快取更新效率**: 背景更新，不阻塞UI操作

### 8.4 品質保證標準（API整合）

#### 8.4.1 API整合測試覆蓋
- **API端點測試**: 32個端點100%功能測試覆蓋
- **API錯誤測試**: 所有HTTP狀態碼處理測試
- **API快取測試**: 快取策略和失效機制測試
- **API同步測試**: 離線同步和衝突解決測試

#### 8.4.2 UI/API整合測試
- **端到端測試**: 用戶操作→API調用→UI更新完整流程
- **狀態管理測試**: API狀態變化的UI響應測試
- **錯誤處理測試**: API錯誤的UI顯示和用戶引導測試
- **效能測試**: API載入時間和UI響應速度測試

#### 8.4.3 程式碼品質標準（API模組）
```dart
// API服務代碼品質檢查清單
class ApiQualityStandards {
  // 1. 所有API方法必須有完整的錯誤處理
  Future<Result<T>> apiCall<T>() async {
    try {
      final response = await _apiClient.call();
      return Result.success(response.data);
    } on DioException catch (e) {
      return Result.error(ApiErrorHandler.handleError(e));
    }
  }
  
  // 2. 所有API模型必須有JSON序列化支援
  @JsonSerializable()
  class ApiModel {
    factory ApiModel.fromJson(Map<String, dynamic> json) => _$ApiModelFromJson(json);
    Map<String, dynamic> toJson() => _$ApiModelToJson(this);
  }
  
  // 3. 所有API服務必須有單元測試
  group('API Service Tests', () {
    test('should return user data when API call succeeds', () async {
      // 測試實現...
    });
  });
  
  // 4. 所有API快取必須有TTL管理
  class ApiCache {
    final Duration ttl;
    final DateTime createdAt;
    
    bool get isExpired => DateTime.now().difference(createdAt) > ttl;
  }
}
```

---

## 9.0 測試計畫

### 9.1 API整合測試策略

#### 9.1.1 測試金字塔（API驅動）
```
API整合測試金字塔
├── E2E測試 (10%) - 完整用戶流程測試
│   ├── 四模式端到端測試
│   ├── 跨平台整合測試（LINE OA ↔ Flutter）
│   └── API業務流程測試
│
├── 整合測試 (30%) - API與UI整合測試
│   ├── API服務整合測試
│   ├── 狀態管理整合測試
│   ├── 快取機制整合測試
│   └── 離線同步整合測試
│
├── API測試 (40%) - API端點功能測試
│   ├── 32個API端點功能測試
│   ├── API錯誤處理測試
│   ├── API效能基準測試
│   └── API安全性測試
│
└── 單元測試 (20%) - 業務邏輯測試
    ├── 數據模型測試
    ├── 工具函數測試
    └── UI元件單元測試
```

#### 9.1.2 API功能測試計畫

**認證管理群組測試 (F001-F005)**
```dart
// test/api/auth_api_test.dart
group('認證管理API測試', () {
  group('F001 - 使用者註冊API', () {
    test('成功註冊新用戶', () async {
      final request = RegisterRequest(
        email: 'test@example.com',
        password: 'Test123!',
        name: 'Test User',
      );
      
      final result = await authService.register(request);
      
      expect(result.isSuccess, true);
      expect(result.data.email, 'test@example.com');
    });
    
    test('重複信箱註冊失敗', () async {
      // 重複註冊測試...
    });
    
    test('無效密碼格式註冊失敗', () async {
      // 密碼驗證測試...
    });
  });
  
  group('F002 - 使用者登入API', () {
    test('正確帳密登入成功', () async {
      // 登入成功測試...
    });
    
    test('錯誤密碼登入失敗', () async {
      // 登入失敗測試...
    });
    
    test('JWT Token正確生成', () async {
      // Token驗證測試...
    });
  });
  
  // F003-F005 API測試...
});
```

**記帳功能群組測試 (F006-F009)**
```dart
// test/api/entry_api_test.dart
group('記帳功能API測試', () {
  group('F006 - 記帳記錄建立API', () {
    test('建立收入記錄', () async {
      final request = CreateEntryRequest(
        amount: 1000.0,
        category: 'salary',
        type: EntryType.income,
        date: DateTime.now(),
      );
      
      final result = await entryService.createEntry(request);
      
      expect(result.isSuccess, true);
      expect(result.data.amount, 1000.0);
      expect(result.data.type, EntryType.income);
    });
    
    test('建立支出記錄', () async {
      // 支出記錄測試...
    });
    
    test('無效金額建立失敗', () async {
      // 金額驗證測試...
    });
  });
  
  group('F007 - APP記帳功能API', () {
    test('快速記帳成功', () async {
      // 快速記帳測試...
    });
    
    test('語音記帳數據格式', () async {
      // 語音記帳測試...
    });
  });
  
  // F008-F009 API測試...
});
```

### 9.2 四模式體驗測試

#### 9.2.1 精準控制者模式測試
```dart
// test/modes/precision_controller_test.dart
group('精準控制者模式測試', () {
  setUp(() {
    // 設定精準控制者模式
    UserModeService.setMode(UserMode.precisionController);
  });
  
  testWidgets('應顯示完整32個API功能', (tester) async {
    await tester.pumpWidget(MyApp());
    await tester.pumpAndSettle();
    
    // 驗證專業儀表板顯示
    expect(find.byType(ProfessionalDashboard), findsOneWidget);
    
    // 驗證進階功能可見性
    expect(find.text('批量操作'), findsOneWidget);
    expect(find.text('自訂報表'), findsOneWidget);
    expect(find.text('系統診斷'), findsOneWidget);
  });
  
  testWidgets('批量API操作功能測試', (tester) async {
    // 批量操作測試...
  });
  
  testWidgets('複雜API參數設定測試', (tester) async {
    // 進階設定測試...
  });
});
```

#### 9.2.2 潛在覺醒者模式測試
```dart
// test/modes/potential_awakener_test.dart
group('潛在覺醒者模式測試', () {
  setUp(() {
    UserModeService.setMode(UserMode.potentialAwakener);
  });
  
  testWidgets('應僅顯示16個核心API功能', (tester) async {
    await tester.pumpWidget(MyApp());
    await tester.pumpAndSettle();
    
    // 驗證簡化介面
    expect(find.byType(FriendlyWelcome), findsOneWidget);
    
    // 驗證進階功能隱藏
    expect(find.text('批量操作'), findsNothing);
    expect(find.text('系統診斷'), findsNothing);
    
    // 驗證核心功能可見
    expect(find.text('簡易記帳'), findsOneWidget);
    expect(find.text('基礎報表'), findsOneWidget);
  });
  
  testWidgets('API功能漸進解鎖測試', (tester) async {
    // 功能解鎖測試...
  });
});
```

### 9.3 API效能測試計畫

#### 9.3.1 API回應時間測試
```dart
// test/performance/api_performance_test.dart
group('API效能測試', () {
  test('記帳API回應時間測試', () async {
    final stopwatch = Stopwatch()..start();
    
    final result = await entryService.createEntry(mockRequest);
    
    stopwatch.stop();
    
    // 驗證回應時間 < 500ms
    expect(stopwatch.elapsedMilliseconds, lessThan(500));
    expect(result.isSuccess, true);
  });
  
  test('報表API回應時間測試', () async {
    final stopwatch = Stopwatch()..start();
    
    final result = await reportService.generateReport(mockParams);
    
    stopwatch.stop();
    
    // 驗證回應時間 < 2s
    expect(stopwatch.elapsedMilliseconds, lessThan(2000));
  });
  
  test('併發API請求測試', () async {
    final futures = List.generate(10, (index) => 
      entryService.getEntries(EntryQueryParams())
    );
    
    final stopwatch = Stopwatch()..start();
    final results = await Future.wait(futures);
    stopwatch.stop();
    
    // 驗證併發處理效能
    expect(results.every((r) => r.isSuccess), true);
    expect(stopwatch.elapsedMilliseconds, lessThan(3000));
  });
});
```

#### 9.3.2 快取效能測試
```dart
// test/performance/cache_performance_test.dart
group('快取效能測試', () {
  test('快取命中率測試', () async {
    int cacheHits = 0;
    int totalRequests = 100;
    
    for (int i = 0; i < totalRequests; i++) {
      final result = await entryService.getEntries(
        EntryQueryParams(page: 1, limit: 20)
      );
      
      if (result.isFromCache) {
        cacheHits++;
      }
    }
    
    final hitRate = cacheHits / totalRequests;
    expect(hitRate, greaterThan(0.8)); // > 80%命中率
  });
  
  test('快取失效測試', () async {
    // 快取失效機制測試...
  });
});
```

### 9.4 離線同步測試計畫

#### 9.4.1 離線操作測試
```dart
// test/offline/offline_sync_test.dart
group('離線同步測試', () {
  test('離線記帳操作測試', () async {
    // 模擬離線狀態
    await NetworkSimulator.setOffline();
    
    final request = CreateEntryRequest(
      amount: 500.0,
      category: 'food',
      type: EntryType.expense,
    );
    
    // 離線建立記帳記錄
    final result = await entryService.createEntry(request);
    
    expect(result.isSuccess, true);
    expect(result.data.syncStatus, SyncStatus.pending);
    
    // 恢復網路連線
    await NetworkSimulator.setOnline();
    
    // 等待自動同步
    await Future.delayed(Duration(seconds: 5));
    
    // 驗證同步成功
    final syncedEntry = await entryService.getEntry(result.data.id);
    expect(syncedEntry.data.syncStatus, SyncStatus.synced);
  });
  
  test('離線衝突解決測試', () async {
    // 衝突解決測試...
  });
});
```

### 9.5 相容性測試計畫

#### 9.5.1 API版本相容性測試
```dart
// test/compatibility/api_version_test.dart
group('API版本相容性測試', () {
  test('向下相容性測試', () async {
    // 使用舊版API格式
    final oldFormatRequest = {
      'amount': '1000.0', // 字串格式（舊版）
      'category': 'food',
      'date': '2025-01-24', // 字串日期（舊版）
    };
    
    final result = await apiClient.post('/entries', data: oldFormatRequest);
    
    // 驗證新版API仍能處理舊格式
    expect(result.statusCode, 200);
  });
  
  test('API Schema驗證測試', () async {
    // API回應格式驗證測試...
  });
});
```

---

## 10.0 風險評估與緩解

### 10.1 API整合風險

#### 10.1.1 高風險項目

**風險**: 32個API端點整合複雜度過高
- **影響**: 開發週期延長、API調用錯誤率增加、系統穩定性下降
- **機率**: 高
- **緩解策略**:
  - 採用分階段API整合：核心功能API優先
  - 建立統一API客戶端和錯誤處理機制
  - 實施完整的API Mock測試環境
  - 建立API調用監控和預警系統

**風險**: API效能瓶頸導致用戶體驗下降
- **影響**: 頁面載入慢、操作延遲、用戶流失
- **機率**: 中高
- **緩解策略**:
  - 實施智慧快取策略，減少不必要API調用
  - 採用API請求優先級管理和併發控制
  - 建立API效能監控和自動優化機制
  - 實施降級服務，API失敗時使用快取數據

#### 10.1.2 中風險項目

**風險**: API認證和安全性漏洞
- **影響**: 用戶數據洩露、未授權API存取
- **機率**: 中等
- **緩解策略**:
  - 實施JWT Token自動管理和刷新機制
  - 建立API權限控制和存取日誌
  - 定期進行API安全性滲透測試
  - 實施API調用頻率限制和異常檢測

**風險**: 離線同步數據一致性問題
- **影響**: 數據衝突、同步失敗、數據遺失
- **機率**: 中等
- **緩解策略**:
  - 建立完善的衝突檢測和解決機制
  - 實施增量同步和數據版本控制
  - 提供手動衝突解決介面
  - 建立數據完整性檢查和修復機制

### 10.2 四模式使用者體驗風險

#### 10.2.1 API權限管理複雜性風險
- **風險**: 四模式API權限矩陣實施困難
- **影響**: 功能顯示錯誤、用戶困惑、開發複雜度增加
- **緩解策略**:
  - 建立統一的權限管理系統
  - 實施權限變更的漸進式過渡
  - 提供清晰的功能解鎖引導
  - 建立權限管理的測試自動化

#### 10.2.2 API功能解鎖機制風險
- **風險**: 潛在覺醒者和轉型挑戰者功能解鎖邏輯錯誤
- **影響**: 用戶無法正常解鎖功能、功能提前或延遲解鎖
- **緩解策略**:
  - 建立清晰的解鎖條件和追蹤機制
  - 實施解鎖狀態的本地快取和雲端同步
  - 提供手動解鎖的後門機制
  - 建立解鎖機制的完整測試覆蓋

### 10.3 技術架構風險

#### 10.3.1 API可用性風險
- **風險**: 後端API服務不穩定或頻繁變更
- **影響**: Flutter應用頻繁崩潰、功能不可用
- **緩解策略**:
  - 建立API版本管理和向下相容機制
  - 實施API熔斷和自動重試機制
  - 建立完整的離線備援機制
  - 與後端團隊建立API變更通知機制

#### 10.3.2 Flutter與API整合風險
- **風險**: Flutter更新導致API整合代碼失效
- **影響**: 應用無法正常建置或運行
- **緩解策略**:
  - 固定Flutter SDK版本，慎重評估升級
  - 建立完整的API整合測試套件
  - 實施持續整合和自動化測試
  - 建立版本相容性測試機制

### 10.4 商業風險

#### 10.4.1 API開發成本風險
- **風險**: 32個API端點整合成本超出預期
- **影響**: 專案預算超支、開發週期延長
- **緩解策略**:
  - 採用增量開發策略，分階段交付
  - 重用既有API整合框架和元件
  - 實施API開發工作量追蹤和預警
  - 建立API複雜度評估和調整機制

#### 10.4.2 用戶接受度風險
- **風險**: 四模式API功能差異化用戶理解困難
- **影響**: 用戶採用率低、客服負擔增加
- **緩解策略**:
  - 實施充分的用戶測試和回饋收集
  - 建立清晰的模式介紹和功能說明
  - 提供模式切換試用和比較功能
  - 建立用戶教育和支援機制

---

## 11.0 模組版本升級計畫

### 11.1 Presentation Layer版本升級

| 版本 | 主要變更 | API支援 | 完成時間 | 依賴升級 |
|------|----------|---------|----------|----------|
| **v2.0.0** | 完整32個API端點整合 | 100% | 2025-03-15 | 多個模組升級 |
| v2.1.0 | 四模式API權限優化 | 100% | 2025-04-30 | 權限系統升級 |
| v2.2.0 | 離線同步功能完善 | 100% | 2025-06-15 | 同步引擎升級 |
| v2.3.0 | API效能優化 | 100% | 2025-08-30 | 快取系統升級 |

### 11.2 相關模組版本升級

| 模組名稱 | 原版本 | 新版本 | 升級原因 | 主要變更 |
|----------|---------|---------|----------|----------|
| **Flutter_Presentation Layer** | 新建 | v2.0.0 | 初始版本建立 | 完整32個API端點UI實現 |
| **Flutter_Wireflow** | v1.0.1 | v1.2.0 | 支援API驅動設計 | 新增API流程圖和互動設計 |
| **Flutter_User_Flow** | v1.0.0 | v1.2.0 | 整合API使用流程 | 新增API操作流程和錯誤處理流程 |
| **Flutter_AP_Layer** | v1.0.0 | v2.0.0 | 完整API服務實現 | 實現32個API端點服務層 |
| **Flutter_API_list** | v1.0.0 | v1.1.0 | API清單對應UI | 新增UI頁面對應和權限說明 |

### 11.3 函數版本升級計畫

#### 11.3.1 核心API函數升級
| API端點 | 原版本 | 新版本 | 升級內容 | UI對應功能 |
|---------|---------|---------|----------|------------|
| **F001 使用者註冊** | v1.0.0 | v2.0.0 | 支援模式測評整合 | 註冊流程UI優化 |
| **F002 使用者登入** | v1.0.0 | v2.0.0 | JWT Token管理優化 | 生物辨識登入UI |
| **F003 取得使用者資料** | v1.0.0 | v2.0.0 | 支援四模式資料欄位 | 個人資料頁面差異化 |
| **F006 記帳記錄建立** | v1.0.0 | v2.1.0 | 支援離線建立和同步 | 四模式記帳UI差異化 |
| **F007 APP記帳功能** | v2.0.0 | v2.2.0 | 支援語音記帳和OCR | 智慧記帳UI功能 |

#### 11.3.2 進階功能API升級  
| API端點 | 原版本 | 新版本 | 升級內容 | UI對應功能 |
|---------|---------|---------|----------|------------|
| **F010-F015 專案管理** | v1.0.0 | v2.0.0 | 完整專案管理功能 | 專案管理UI頁面群組 |
| **F016-F018 預算管理** | v1.0.0 | v2.0.0 | 智慧預算分析 | 預算追蹤儀表板UI |
| **F019-F021 協作功能** | v1.0.0 | v2.0.0 | 即時協作同步 | 協作管理UI和權限介面 |
| **F022-F024 報表功能** | v1.0.0 | v2.1.0 | 互動式報表和匯出 | 報表中心UI和視覺化 |
| **F025-F032 系統管理** | v1.0.0 | v2.0.0 | 完整系統設定功能 | 系統設定UI頁面群組 |

### 11.4 開發里程碑計畫

#### 11.4.1 Phase 1: 核心API整合 (2025-01-24 ~ 2025-02-28)
```
核心功能開發
├── 認證管理API整合 (F001-F005)
├── 基礎記帳API整合 (F006-F009) 
├── 統一API客戶端架構
├── 四模式基礎UI框架
└── 基礎測試套件建立
```

#### 11.4.2 Phase 2: 進階功能整合 (2025-03-01 ~ 2025-03-31)
```
進階功能開發
├── 專案管理API整合 (F010-F015)
├── 預算管理API整合 (F016-F018)
├── 四模式權限矩陣實施
├── 離線功能基礎架構
└── API效能優化初步實施
```

#### 11.4.3 Phase 3: 協作與報表功能 (2025-04-01 ~ 2025-04-30)
```
協作報表功能
├── 協作功能API整合 (F019-F021)
├── 報表功能API整合 (F022-F024)
├── 系統管理API整合 (F025-F032)
├── 完整離線同步機制
└── 全面效能優化
```

#### 11.4.4 Phase 4: 品質保證與上線 (2025-05-01 ~ 2025-05-31)
```
品質保證階段
├── 完整API整合測試
├── 四模式用戶體驗測試
├── 效能壓力測試
├── 安全性測試
└── 產品上線準備
```

### 11.5 向下相容性保證

#### 11.5.1 API版本相容性
- **API版本管理**: 支援v1.0和v2.0 API並存
- **數據格式相容**: 新版本支援舊版本數據格式
- **功能漸進升級**: 用戶可選擇性升級到新功能
- **回退機制**: 提供版本回退和數據復原機制

#### 11.5.2 用戶設定遷移
```dart
// 用戶設定遷移機制
class SettingsMigration {
  Future<void> migrateToV2() async {
    final v1Settings = await _getV1Settings();
    
    // 遷移模式設定
    final userMode = _detectUserModeFromV1(v1Settings);
    await UserModeService.setMode(userMode);
    
    // 遷移API權限設定
    final apiPermissions = _migrateApiPermissions(v1Settings, userMode);
    await ApiPermissionService.setPermissions(apiPermissions);
    
    // 遷移快取設定
    await _migrateCacheSettings(v1Settings);
    
    // 標記遷移完成
    await PreferencesService.setMigrationComplete('v2.0.0');
  }
}
```

---

## 文件維護記錄

| 版本 | 日期 | 修改者 | 修改內容 |
|------|------|--------|----------|
| v1.0.0 | 2025-01-24 | LCAS PM Team | 初版建立，基於Flutter_Wireflow設計，整合四模式用戶體驗需求 |
| **v2.0.0** | **2025-01-24** | **LCAS PM Team** | **重大升級：整合9205文件32個API端點，新增API整合架構、四模式權限矩陣、離線同步策略、完整技術規格，從概念性PRD升級為可執行技術規格書** |
| **v2.1.0** | **2025-01-24** | **LCAS PM Team** | **架構優化：修正認證管理群組API端點數量（5個），簡化API整合架構為基於七大功能群組的單一分類系統，移除重複的技術分層架構** |

---

## 備註

- **版本2.0.0重大變更**: 完整整合9205文件定義的32個RESTful API端點
- **API驅動設計**: 所有UI設計基於具體API功能需求制定
- **四模式權限管理**: 實現基於用戶模式的動態API權限控制
- **離線優先策略**: 核心功能支援完整離線操作和智慧同步
- **技術實作細節**: 請參考91資料夾中的AP Layer程式碼實現
- **UI/UX設計規格**: 請參考9204. Flutter_Wireflow.md文件
- **API端點詳細規格**: 請參考9205. Flutter_API list_AP layer.md文件
- **四模式用戶體驗**: 基於自律動機矩陣理論的差異化設計策略
