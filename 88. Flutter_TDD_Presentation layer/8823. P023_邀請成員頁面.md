
# P023_邀請成員頁面TDD_v1.0.0

**文件編號**: 8823  
**版本**: v1.0.0  
**建立日期**: 2025-01-26  
**建立者**: LCAS SA Team  
**最後更新**: 2025-01-26 16:50:00 UTC+8

---

## 目次

1. [TDD概述](#10-tdd概述tdd-overview)
2. [測試環境設定](#20-測試環境設定test-environment-setup)
3. [單元測試規格](#30-單元測試規格unit-tests-specification)
4. [整合測試規格](#40-整合測試規格integration-tests-specification)
5. [使用者介面測試](#50-使用者介面測試ui-tests-specification)
6. [效能測試規格](#60-效能測試規格performance-tests-specification)
7. [安全性測試](#70-安全性測試security-tests-specification)
8. [測試資料管理](#80-測試資料管理test-data-management)

---

## 1.0 TDD概述（TDD Overview）

### 1.1 測試目標與範圍

**對應SRS文件**: [P023_邀請成員頁面_SRS.md](../87.%20Flutter_SRS_Presentation%20layer/P023_邀請成員頁面_SRS.md)

**測試範圍**:
- Email邀請功能的完整測試覆蓋
- 邀請連結生成與分享測試
- QR碼邀請功能驗證
- 權限預設定邏輯測試
- 邀請訊息客製化測試
- 邀請狀態追蹤功能驗證
- 批量邀請操作測試
- 邀請驗證與安全性測試

### 1.2 測試策略

**測試層級劃分**:
- **Unit Tests (40%)**: 邀請邏輯函數、驗證規則、資料處理函數
- **Integration Tests (30%)**: API整合、服務協作、Email服務測試
- **UI Tests (20%)**: 使用者介面互動、邀請流程、操作體驗測試
- **E2E Tests (10%)**: 完整邀請流程的端到端測試

### 1.3 品質目標

**測試覆蓋率目標**:
- 程式碼覆蓋率: ≥ 90%
- 分支覆蓋率: ≥ 85%
- 功能覆蓋率: 100%
- 使用者故事覆蓋率: 100%

---

## 2.0 測試環境設定（Test Environment Setup）

### 2.1 測試框架配置

```yaml
# test/test_config.yaml
test_framework:
  unit_test: flutter_test
  integration_test: integration_test
  ui_test: flutter_driver
  mock_framework: mockito
  state_management: provider

dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter
  mockito: ^5.4.0
  build_runner: ^2.3.0
  golden_toolkit: ^0.15.0
  network_image_mock: ^2.1.1
```

### 2.2 Mock服務設定

```dart
// test/mocks/invitation_mocks.dart

/**
 * 邀請成員頁面Mock服務設定_v1.0.0
 * @module InvitationMocks
 * @description 邀請成員頁面測試用Mock服務
 * @update 2025-01-26: 建立邀請成員Mock服務
 */

@GenerateMocks([
  AuthService,
  CollaborationService,
  ProjectLedgerService,
  EmailService,
  InvitationRepository,
  InvitationValidator,
  QRCodeGenerator,
])
class InvitationMocks {}

// Mock資料建構器
class MockInvitationDataBuilder {
  
  /**
   * 01. 建構邀請結果測試資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 建立邀請結果Mock資料建構功能
   */
  static InvitationResult buildMockInvitationResult() {
    return InvitationResult(
      successful: [
        {
          'email': 'user1@example.com',
          'inviteId': 'inv_001',
          'status': 'sent',
        },
        {
          'email': 'user2@example.com',
          'inviteId': 'inv_002',
          'status': 'queued',
        },
      ],
      failed: [
        {
          'email': 'invalid@',
          'reason': 'Invalid email format',
          'errorCode': 'INVALID_EMAIL_FORMAT',
        },
      ],
      duplicates: [
        {
          'email': 'existing@example.com',
          'existingRole': 'member',
        },
      ],
      statistics: {
        'totalAttempted': 4,
        'successCount': 2,
        'failureCount': 1,
        'duplicateCount': 1,
      },
    );
  }

  /**
   * 02. 建構權限選項測試資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 建立權限選項Mock資料建構功能
   */
  static List<RoleOption> buildMockRoleOptions() {
    return [
      RoleOption(
        roleId: 'owner',
        roleName: '擁有者',
        description: '帳本擁有者，擁有所有權限',
        permissions: ['all'],
        isRecommended: false,
        restrictions: ['cannot_be_assigned'],
      ),
      RoleOption(
        roleId: 'admin',
        roleName: '管理員',
        description: '帳本管理員，可管理成員和權限',
        permissions: ['manage_members', 'edit_settings'],
        isRecommended: true,
        restrictions: [],
      ),
      RoleOption(
        roleId: 'member',
        roleName: '成員',
        description: '普通成員，可編輯記帳資料',
        permissions: ['create_entry', 'edit_entry'],
        isRecommended: true,
        restrictions: [],
      ),
      RoleOption(
        roleId: 'viewer',
        roleName: '檢視者',
        description: '唯讀權限，僅能檢視資料',
        permissions: ['view_only'],
        isRecommended: false,
        restrictions: [],
      ),
    ];
  }

  /**
   * 03. 建構邀請連結測試資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 建立邀請連結Mock資料建構功能
   */
  static InvitationLink buildMockInvitationLink() {
    return InvitationLink(
      linkId: 'link_001',
      inviteUrl: 'https://app.lcas.com/invite/abc123def456',
      qrCodeUrl: 'https://app.lcas.com/qr/abc123def456.png',
      expiryDate: DateTime.now().add(Duration(days: 30)).toIso8601String(),
      usageLimit: 10,
      currentUsage: 0,
      defaultRole: 'member',
      requireApproval: false,
      createdDate: DateTime.now().toIso8601String(),
      createdBy: 'test_user',
    );
  }

  /**
   * 04. 建構邀請統計測試資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 建立邀請統計Mock資料建構功能
   */
  static InvitationStats buildMockInvitationStats() {
    return InvitationStats(
      totalInvitesSent: 25,
      pendingInvitations: 5,
      acceptedInvitations: 18,
      expiredInvitations: 2,
      dailyLimit: 20,
      remainingToday: 15,
      memberCapacity: {
        'current': 8,
        'maximum': 20,
        'available': 12,
      },
    );
  }
}
```

---

## 3.0 單元測試規格（Unit Tests Specification）

### 3.1 邀請驗證邏輯測試

```dart
// test/unit/invitation_validation_test.dart

/**
 * 邀請驗證邏輯單元測試_v1.0.0
 * @module InvitationValidationTest
 * @description 邀請成員頁面驗證邏輯單元測試
 * @update 2025-01-26: 建立邀請驗證測試套件
 */

class InvitationValidationTest {
  group('InvitationValidation 邀請驗證測試', () {
    late InvitationValidator validator;
    late MockInvitationRepository mockRepository;

    setUp(() {
      mockRepository = MockInvitationRepository();
      validator = InvitationValidator(mockRepository);
    });

    /**
     * 05. 測試Email格式驗證
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試Email格式驗證邏輯的正確性
     */
    group('Email格式驗證測試', () {
      test('應該通過有效的Email格式', () {
        // Given
        final validEmails = [
          'user@example.com',
          'test.email+tag@domain.co.uk',
          'user123@test-domain.org',
        ];

        // When & Then
        for (final email in validEmails) {
          final result = validator.validateEmailFormat(email);
          expect(result.isValid, true, reason: 'Email: $email should be valid');
          expect(result.errorMessage, isNull);
        }
      });

      test('應該拒絕無效的Email格式', () {
        // Given
        final invalidEmails = [
          'invalid-email',
          '@example.com',
          'user@',
          'user..double.dot@example.com',
        ];

        // When & Then
        for (final email in invalidEmails) {
          final result = validator.validateEmailFormat(email);
          expect(result.isValid, false, reason: 'Email: $email should be invalid');
          expect(result.errorMessage, isNotNull);
        }
      });
    });

    /**
     * 06. 測試重複邀請檢查
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試重複邀請檢查邏輯
     */
    group('重複邀請檢查測試', () {
      test('應該檢測已存在的成員', () async {
        // Given
        const email = 'existing@example.com';
        when(mockRepository.isMemberExists(any, email))
            .thenAnswer((_) async => true);

        // When
        final result = await validator.checkDuplicateInvitation('ledger_001', email);

        // Then
        expect(result.isDuplicate, true);
        expect(result.existingRole, isNotNull);
      });

      test('應該允許邀請新成員', () async {
        // Given
        const email = 'new@example.com';
        when(mockRepository.isMemberExists(any, email))
            .thenAnswer((_) async => false);

        // When
        final result = await validator.checkDuplicateInvitation('ledger_001', email);

        // Then
        expect(result.isDuplicate, false);
        expect(result.existingRole, isNull);
      });
    });

    /**
     * 07. 測試邀請配額驗證
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請配額限制驗證
     */
    group('邀請配額驗證測試', () {
      test('應該允許在配額內的邀請', () async {
        // Given
        when(mockRepository.getDailyInvitationCount(any))
            .thenAnswer((_) async => 5);
        when(mockRepository.getDailyLimit(any))
            .thenAnswer((_) async => 20);

        // When
        final result = await validator.validateInvitationQuota('user_001', 10);

        // Then
        expect(result.isAllowed, true);
        expect(result.remainingQuota, equals(15));
      });

      test('應該拒絕超過配額的邀請', () async {
        // Given
        when(mockRepository.getDailyInvitationCount(any))
            .thenAnswer((_) async => 18);
        when(mockRepository.getDailyLimit(any))
            .thenAnswer((_) async => 20);

        // When
        final result = await validator.validateInvitationQuota('user_001', 5);

        // Then
        expect(result.isAllowed, false);
        expect(result.errorReason, contains('超過每日邀請配額'));
      });
    });
  });
}
```

### 3.2 邀請資料處理測試

```dart
// test/unit/invitation_data_test.dart

/**
 * 邀請資料處理單元測試_v1.0.0
 * @module InvitationDataTest
 * @description 邀請資料處理函數單元測試
 * @update 2025-01-26: 建立邀請資料處理測試
 */

class InvitationDataTest {
  group('InvitationData 邀請資料處理測試', () {
    late InvitationDataProcessor processor;
    
    setUp(() {
      processor = InvitationDataProcessor();
    });

    /**
     * 08. 測試批量Email處理
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試批量Email邀請資料處理
     */
    test('應該正確處理批量Email清單', () {
      // Given
      final emailText = '''
        user1@example.com
        user2@example.com,user3@example.com
        user4@example.com;user5@example.com
        
        user6@example.com
      ''';

      // When
      final emails = processor.parseEmailList(emailText);

      // Then
      expect(emails, hasLength(6));
      expect(emails, containsAll([
        'user1@example.com',
        'user2@example.com',
        'user3@example.com',
        'user4@example.com',
        'user5@example.com',
        'user6@example.com',
      ]));
    });

    /**
     * 09. 測試邀請連結生成
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請連結生成邏輯
     */
    test('應該生成有效的邀請連結', () {
      // Given
      final linkConfig = InvitationLinkConfig(
        ledgerId: 'ledger_001',
        defaultRole: 'member',
        expiryDays: 30,
        usageLimit: 10,
      );

      // When
      final link = processor.generateInvitationLink(linkConfig);

      // Then
      expect(link.inviteUrl, isNotEmpty);
      expect(link.inviteUrl, startsWith('https://'));
      expect(link.linkId, isNotEmpty);
      expect(link.defaultRole, equals('member'));
      expect(link.usageLimit, equals(10));
    });

    /**
     * 10. 測試QR碼資料編碼
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試QR碼資料編碼處理
     */
    test('應該正確編碼QR碼資料', () {
      // Given
      final qrData = QRCodeData(
        inviteUrl: 'https://app.lcas.com/invite/abc123',
        ledgerName: '測試帳本',
        inviterName: '邀請者',
        message: '歡迎加入我們的記帳團隊！',
      );

      // When
      final encodedData = processor.encodeQRData(qrData);

      // Then
      expect(encodedData, isNotEmpty);
      expect(encodedData, contains('https://app.lcas.com/invite/abc123'));
    });

    /**
     * 11. 測試邀請訊息範本處理
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請訊息範本變數替換
     */
    test('應該正確處理訊息範本變數', () {
      // Given
      final template = '您好 {invitee_name}，{inviter_name} 邀請您加入 {ledger_name} 帳本。';
      final variables = {
        'invitee_name': '張先生',
        'inviter_name': '李小姐',
        'ledger_name': '家庭記帳本',
      };

      // When
      final message = processor.processMessageTemplate(template, variables);

      // Then
      expect(message, equals('您好 張先生，李小姐 邀請您加入 家庭記帳本 帳本。'));
    });
  });
}
```

---

## 4.0 整合測試規格（Integration Tests Specification）

### 4.1 Email服務整合測試

```dart
// test/integration/email_service_integration_test.dart

/**
 * Email服務整合測試_v1.0.0
 * @module EmailServiceIntegrationTest
 * @description 邀請成員Email服務整合測試
 * @update 2025-01-26: 建立Email服務整合測試套件
 */

class EmailServiceIntegrationTest {
  group('Email Service 整合測試', () {
    late InviteMemberPage page;
    late MockEmailService mockEmailService;
    late MockCollaborationService mockCollaborationService;

    setUpAll(() {
      mockEmailService = MockEmailService();
      mockCollaborationService = MockCollaborationService();
    });

    /**
     * 12. 測試單一Email邀請發送
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試單一Email邀請的完整流程
     */
    testWidgets('應該成功發送單一Email邀請', (tester) async {
      // Given
      when(mockEmailService.sendInvitationEmail(any))
          .thenAnswer((_) async => EmailSendResult(
              success: true, messageId: 'msg_001'));

      // When
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          emailService: mockEmailService,
          collaborationService: mockCollaborationService,
        ),
      ));

      await tester.enterText(
          find.byKey(Key('email_input')), 'test@example.com');
      await tester.tap(find.byKey(Key('send_invitation_button')));
      await tester.pumpAndSettle();

      // Then
      expect(find.text('邀請發送成功'), findsOneWidget);
      verify(mockEmailService.sendInvitationEmail(argThat(
        isA<InvitationEmailRequest>()
            .having((req) => req.recipientEmail, 'recipientEmail', 'test@example.com')
      )));
    });

    /**
     * 13. 測試批量Email邀請發送
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試批量Email邀請處理
     */
    testWidgets('應該處理批量Email邀請', (tester) async {
      // Given
      when(mockEmailService.sendBatchInvitations(any))
          .thenAnswer((_) async => BatchEmailResult(
              totalSent: 3,
              successful: ['user1@test.com', 'user2@test.com', 'user3@test.com'],
              failed: [],
          ));

      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          emailService: mockEmailService,
          collaborationService: mockCollaborationService,
        ),
      ));

      // When
      await tester.enterText(find.byKey(Key('email_input')), 
          'user1@test.com\nuser2@test.com\nuser3@test.com');
      await tester.tap(find.byKey(Key('send_batch_invitation_button')));
      await tester.pumpAndSettle();

      // Then
      expect(find.text('成功發送 3 封邀請'), findsOneWidget);
      verify(mockEmailService.sendBatchInvitations(argThat(
        isA<BatchInvitationRequest>()
            .having((req) => req.emails, 'emails', hasLength(3))
      )));
    });

    /**
     * 14. 測試Email發送失敗處理
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試Email發送失敗的錯誤處理
     */
    testWidgets('應該正確處理Email發送失敗', (tester) async {
      // Given
      when(mockEmailService.sendInvitationEmail(any))
          .thenThrow(EmailServiceException('SMTP server unavailable'));

      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          emailService: mockEmailService,
          collaborationService: mockCollaborationService,
        ),
      ));

      // When
      await tester.enterText(
          find.byKey(Key('email_input')), 'test@example.com');
      await tester.tap(find.byKey(Key('send_invitation_button')));
      await tester.pumpAndSettle();

      // Then
      expect(find.text('邀請發送失敗'), findsOneWidget);
      expect(find.byKey(Key('retry_button')), findsOneWidget);
    });
  });
}
```

### 4.2 邀請連結整合測試

```dart
// test/integration/invitation_link_integration_test.dart

/**
 * 邀請連結整合測試_v1.0.0
 * @module InvitationLinkIntegrationTest
 * @description 邀請連結生成與管理整合測試
 * @update 2025-01-26: 建立邀請連結整合測試
 */

class InvitationLinkIntegrationTest {
  group('Invitation Link 邀請連結整合測試', () {
    late MockProjectLedgerService mockProjectLedgerService;
    late MockQRCodeGenerator mockQRCodeGenerator;

    setUp(() {
      mockProjectLedgerService = MockProjectLedgerService();
      mockQRCodeGenerator = MockQRCodeGenerator();
    });

    /**
     * 15. 測試邀請連結生成
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請連結生成的完整流程
     */
    testWidgets('應該成功生成邀請連結', (tester) async {
      // Given
      when(mockProjectLedgerService.generateInvitationLink(any))
          .thenAnswer((_) async => Response.success(
              MockInvitationDataBuilder.buildMockInvitationLink()));

      // When
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          projectLedgerService: mockProjectLedgerService,
        ),
      ));

      await tester.tap(find.byKey(Key('link_invite_tab')));
      await tester.tap(find.byKey(Key('generate_link_button')));
      await tester.pumpAndSettle();

      // Then
      expect(find.byType(InvitationLinkDisplay), findsOneWidget);
      expect(find.text('邀請連結已生成'), findsOneWidget);
      verify(mockProjectLedgerService.generateInvitationLink(any));
    });

    /**
     * 16. 測試QR碼生成
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試QR碼生成功能
     */
    testWidgets('應該生成對應的QR碼', (tester) async {
      // Given
      final mockLink = MockInvitationDataBuilder.buildMockInvitationLink();
      when(mockProjectLedgerService.generateInvitationLink(any))
          .thenAnswer((_) async => Response.success(mockLink));
      when(mockQRCodeGenerator.generateQRCode(any))
          .thenAnswer((_) async => QRCodeImage(
              imageBytes: Uint8List.fromList([1, 2, 3]),
              size: Size(200, 200)));

      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          projectLedgerService: mockProjectLedgerService,
          qrCodeGenerator: mockQRCodeGenerator,
        ),
      ));

      // When
      await tester.tap(find.byKey(Key('qr_invite_tab')));
      await tester.tap(find.byKey(Key('generate_qr_button')));
      await tester.pumpAndSettle();

      // Then
      expect(find.byType(QRCodeDisplay), findsOneWidget);
      verify(mockQRCodeGenerator.generateQRCode(mockLink.inviteUrl));
    });

    /**
     * 17. 測試連結分享功能
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請連結的分享功能
     */
    testWidgets('應該提供連結分享選項', (tester) async {
      // Given
      final mockLink = MockInvitationDataBuilder.buildMockInvitationLink();
      when(mockProjectLedgerService.generateInvitationLink(any))
          .thenAnswer((_) async => Response.success(mockLink));

      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          projectLedgerService: mockProjectLedgerService,
        ),
      ));

      await tester.tap(find.byKey(Key('link_invite_tab')));
      await tester.tap(find.byKey(Key('generate_link_button')));
      await tester.pumpAndSettle();

      // When
      await tester.tap(find.byKey(Key('share_link_button')));

      // Then
      expect(find.byType(ShareOptionsDialog), findsOneWidget);
      expect(find.text('複製連結'), findsOneWidget);
      expect(find.text('分享到社群媒體'), findsOneWidget);
    });
  });
}
```

---

## 5.0 使用者介面測試（UI Tests Specification）

### 5.1 邀請介面操作測試

```dart
// test/ui/invitation_interface_ui_test.dart

/**
 * 邀請介面操作測試_v1.0.0
 * @module InvitationInterfaceUITest
 * @description 邀請成員介面操作測試
 * @update 2025-01-26: 建立邀請介面UI測試套件
 */

class InvitationInterfaceUITest {
  group('InvitationInterface UI 介面測試', () {
    
    /**
     * 18. 測試邀請方式切換
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請方式Tab切換功能
     */
    testWidgets('應該支援邀請方式切換', (tester) async {
      // Given
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(ledgerId: 'test_ledger'),
      ));

      // When & Then - 測試Email邀請Tab
      expect(find.byKey(Key('email_invite_tab')), findsOneWidget);
      expect(find.byKey(Key('email_input_form')), findsOneWidget);

      // When & Then - 切換到連結邀請Tab
      await tester.tap(find.byKey(Key('link_invite_tab')));
      await tester.pumpAndSettle();
      expect(find.byKey(Key('link_settings_form')), findsOneWidget);

      // When & Then - 切換到QR碼邀請Tab
      await tester.tap(find.byKey(Key('qr_invite_tab')));
      await tester.pumpAndSettle();
      expect(find.byKey(Key('qr_settings_form')), findsOneWidget);
    });

    /**
     * 19. 測試Email輸入介面
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試Email輸入表單功能
     */
    testWidgets('應該提供友善的Email輸入介面', (tester) async {
      // Given
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(ledgerId: 'test_ledger'),
      ));

      // When - 輸入Email
      await tester.enterText(find.byKey(Key('email_input')), 
          'user1@test.com\nuser2@test.com');

      // Then - 檢查Email計數顯示
      expect(find.text('2 個Email地址'), findsOneWidget);
      
      // When - 選擇預設角色
      await tester.tap(find.byKey(Key('default_role_dropdown')));
      await tester.pumpAndSettle();
      await tester.tap(find.text('管理員'));

      // Then - 檢查選擇結果
      expect(find.text('管理員'), findsOneWidget);
    });

    /**
     * 20. 測試權限選擇介面
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試權限選擇下拉選單
     */
    testWidgets('應該顯示可用的權限選項', (tester) async {
      // Given
      final roles = MockInvitationDataBuilder.buildMockRoleOptions();
      
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          availableRoles: roles,
        ),
      ));

      // When
      await tester.tap(find.byKey(Key('default_role_dropdown')));
      await tester.pumpAndSettle();

      // Then
      expect(find.text('管理員'), findsOneWidget);
      expect(find.text('成員'), findsOneWidget);
      expect(find.text('檢視者'), findsOneWidget);
      expect(find.text('(推薦)'), findsWidgets); // 推薦標示
    });

    /**
     * 21. 測試邀請統計顯示
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請統計資訊顯示
     */
    testWidgets('應該顯示邀請統計資訊', (tester) async {
      // Given
      final stats = MockInvitationDataBuilder.buildMockInvitationStats();
      
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(
          ledgerId: 'test_ledger',
          invitationStats: stats,
        ),
      ));

      // Then
      expect(find.text('8 / 20'), findsOneWidget);  // 目前成員數
      expect(find.text('剩餘 15 次'), findsOneWidget); // 今日剩餘配額
      expect(find.text('5 個待處理'), findsOneWidget); // 待處理邀請
    });

    /**
     * 22. 測試邀請結果顯示
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請結果的顯示與操作
     */
    testWidgets('應該清楚顯示邀請結果', (tester) async {
      // Given
      final result = MockInvitationDataBuilder.buildMockInvitationResult();
      
      await tester.pumpWidget(MaterialApp(
        home: Scaffold(
          body: InvitationResultDisplay(result: result),
        ),
      ));

      // Then - 檢查成功邀請顯示
      expect(find.text('成功發送: 2'), findsOneWidget);
      expect(find.text('user1@example.com'), findsOneWidget);
      expect(find.text('user2@example.com'), findsOneWidget);

      // Then - 檢查失敗邀請顯示
      expect(find.text('發送失敗: 1'), findsOneWidget);
      expect(find.text('invalid@'), findsOneWidget);

      // Then - 檢查重複邀請顯示
      expect(find.text('已是成員: 1'), findsOneWidget);
      expect(find.text('existing@example.com'), findsOneWidget);
    });
  });
}
```

### 5.2 響應式設計測試

```dart
// test/ui/responsive_design_ui_test.dart

/**
 * 響應式設計測試_v1.0.0
 * @module ResponsiveDesignUITest
 * @description 邀請成員頁面響應式設計測試
 * @update 2025-01-26: 建立響應式設計測試套件
 */

class ResponsiveDesignUITest {
  group('ResponsiveDesign UI 響應式設計測試', () {

    /**
     * 23. 測試手機直向佈局
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試手機直向模式的佈局適應
     */
    testWidgets('應該適應手機直向佈局', (tester) async {
      // Given - 設定手機直向尺寸
      tester.binding.window.physicalSizeTestValue = Size(375, 812);
      tester.binding.window.devicePixelRatioTestValue = 2.0;

      // When
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(ledgerId: 'test_ledger'),
      ));

      // Then - 檢查垂直堆疊佈局
      expect(find.byType(Column), findsWidgets);
      expect(find.byType(SingleChildScrollView), findsOneWidget);
      
      // 清理
      addTearDown(tester.binding.window.clearPhysicalSizeTestValue);
    });

    /**
     * 24. 測試平板橫向佈局
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試平板橫向模式的佈局適應
     */
    testWidgets('應該適應平板橫向佈局', (tester) async {
      // Given - 設定平板橫向尺寸
      tester.binding.window.physicalSizeTestValue = Size(1024, 768);
      tester.binding.window.devicePixelRatioTestValue = 2.0;

      // When
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(ledgerId: 'test_ledger'),
      ));

      // Then - 檢查分欄佈局
      expect(find.byType(Row), findsWidgets);
      expect(find.byType(Expanded), findsWidgets);
      
      // 清理
      addTearDown(tester.binding.window.clearPhysicalSizeTestValue);
    });

    /**
     * 25. 測試動態字體大小
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試動態字體大小適應
     */
    testWidgets('應該支援動態字體大小', (tester) async {
      // Given - 設定大字體
      tester.binding.window.textScaleFactorTestValue = 1.5;

      // When
      await tester.pumpWidget(MaterialApp(
        home: InviteMemberPage(ledgerId: 'test_ledger'),
      ));

      // Then - 檢查文字元件適應
      final textWidgets = find.byType(Text);
      expect(textWidgets, findsWidgets);
      
      // 清理
      addTearDown(tester.binding.window.clearTextScaleFactorTestValue);
    });
  });
}
```

---

## 6.0 效能測試規格（Performance Tests Specification）

### 6.1 邀請處理效能測試

```dart
// test/performance/invitation_performance_test.dart

/**
 * 邀請處理效能測試_v1.0.0
 * @module InvitationPerformanceTest
 * @description 邀請成員頁面效能測試
 * @update 2025-01-26: 建立邀請處理效能測試套件
 */

class InvitationPerformanceTest {
  group('Invitation Performance 效能測試', () {

    /**
     * 26. 測試大量Email處理效能
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試大量Email邀請的處理效能
     */
    test('大量Email處理應保持高效能', () async {
      // Given - 建立大量Email清單 (100個)
      final largeEmailList = List.generate(100, (i) => 'user$i@test.com');
      final processor = InvitationDataProcessor();

      // When - 測量處理時間
      final stopwatch = Stopwatch()..start();
      final validationResults = await processor.validateEmailBatch(largeEmailList);
      stopwatch.stop();

      // Then - 確保處理時間在可接受範圍內 (< 2秒)
      expect(stopwatch.elapsedMilliseconds, lessThan(2000));
      expect(validationResults.length, equals(100));
    });

    /**
     * 27. 測試邀請連結生成效能
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請連結生成的效能
     */
    test('邀請連結生成應快速響應', () async {
      // Given
      final linkGenerator = InvitationLinkGenerator();
      final config = InvitationLinkConfig(
        ledgerId: 'test_ledger',
        defaultRole: 'member',
        expiryDays: 30,
      );

      // When
      final stopwatch = Stopwatch()..start();
      final link = await linkGenerator.generateLink(config);
      stopwatch.stop();

      // Then - 連結生成應在 500ms 內完成
      expect(stopwatch.elapsedMilliseconds, lessThan(500));
      expect(link.inviteUrl, isNotEmpty);
    });

    /**
     * 28. 測試QR碼生成效能
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試QR碼圖片生成效能
     */
    test('QR碼生成應具備良好效能', () async {
      // Given
      final qrGenerator = QRCodeGenerator();
      final data = 'https://app.lcas.com/invite/very-long-invitation-url-with-parameters';

      // When
      final stopwatch = Stopwatch()..start();
      final qrImage = await qrGenerator.generateQRCode(data, size: 400);
      stopwatch.stop();

      // Then - QR碼生成應在 1 秒內完成
      expect(stopwatch.elapsedMilliseconds, lessThan(1000));
      expect(qrImage.imageBytes, isNotEmpty);
    });

    /**
     * 29. 測試併發邀請處理效能
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試併發邀請處理能力
     */
    test('併發邀請處理應保持穩定', () async {
      // Given
      final invitationService = InvitationService();
      final futures = <Future>[];

      // When - 模擬 10 個併發邀請請求
      final stopwatch = Stopwatch()..start();
      for (int i = 0; i < 10; i++) {
        futures.add(invitationService.sendInvitation(
          InvitationRequest(
            email: 'concurrent$i@test.com',
            ledgerId: 'test_ledger',
            role: 'member',
          ),
        ));
      }

      final results = await Future.wait(futures);
      stopwatch.stop();

      // Then - 併發處理應在合理時間內完成
      expect(stopwatch.elapsedMilliseconds, lessThan(5000));
      expect(results.where((r) => r.success).length, equals(10));
    });
  });
}
```

---

## 7.0 安全性測試（Security Tests Specification）

### 7.1 邀請安全性測試

```dart
// test/security/invitation_security_test.dart

/**
 * 邀請安全性測試_v1.0.0
 * @module InvitationSecurityTest
 * @description 邀請成員頁面安全性測試
 * @update 2025-01-26: 建立邀請安全性測試套件
 */

class InvitationSecurityTest {
  group('Invitation Security 安全性測試', () {
    late MockAuthService mockAuthService;
    late InvitationSecurityValidator validator;

    setUp(() {
      mockAuthService = MockAuthService();
      validator = InvitationSecurityValidator(mockAuthService);
    });

    /**
     * 30. 測試邀請權限驗證
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請權限的安全驗證
     */
    test('應該嚴格驗證邀請權限', () async {
      // Given
      const userId = 'user_123';
      const ledgerId = 'ledger_001';
      when(mockAuthService.getUserRole(userId, ledgerId))
          .thenAnswer((_) async => 'viewer');

      // When
      final result = await validator.validateInvitationPermission(userId, ledgerId);

      // Then
      expect(result.hasPermission, false);
      expect(result.errorReason, contains('權限不足'));
    });

    /**
     * 31. 測試Email注入攻擊防護
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試Email注入攻擊的防護機制
     */
    test('應該防止Email注入攻擊', () {
      // Given - 惡意Email輸入
      final maliciousEmails = [
        'test@example.com\nBcc: attacker@evil.com',
        'test@example.com\r\nSubject: Hacked',
        'test@example.com%0ABcc:hacker@evil.com',
        'test@example.com\x0ATo: victim@company.com',
      ];

      // When & Then
      for (final email in maliciousEmails) {
        final result = validator.validateEmailSecurity(email);
        expect(result.isSafe, false, reason: 'Email injection detected: $email');
        expect(result.threatType, equals(ThreatType.emailInjection));
      }
    });

    /**
     * 32. 測試邀請連結安全性
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請連結的安全性控制
     */
    test('應該生成安全的邀請連結', () {
      // Given
      final linkGenerator = SecureInvitationLinkGenerator();
      final config = InvitationLinkConfig(
        ledgerId: 'test_ledger',
        defaultRole: 'member',
        expiryDays: 7,
      );

      // When
      final link = linkGenerator.generateSecureLink(config);

      // Then
      expect(link.linkId, hasLength(greaterThan(32))); // 足夠長的隨機ID
      expect(link.inviteUrl, contains('https://')); // 使用HTTPS
      expect(link.hasExpiry, true); // 設定過期時間
      expect(link.isEncrypted, true); // 包含加密參數
    });

    /**
     * 33. 測試邀請濫用防護
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試防止邀請濫用的機制
     */
    test('應該防止邀請濫用行為', () async {
      // Given
      const userId = 'user_123';
      final abuseDetector = InvitationAbuseDetector();

      // 模擬快速連續邀請（在短時間內發送大量邀請）
      for (int i = 0; i < 25; i++) {
        await abuseDetector.recordInvitationAttempt(userId);
      }

      // When
      final result = await abuseDetector.checkAbusePattern(userId);

      // Then
      expect(result.isAbusive, true);
      expect(result.suspiciousActivityType, equals(AbuseType.rapidInvitation));
      expect(result.recommendedAction, equals(ActionType.temporaryBlock));
    });

    /**
     * 34. 測試敏感資料保護
     * @version 2025-01-26-V1.0.0
     * @date 2025-01-26 16:50:02
     * @update: 測試邀請過程中的敏感資料保護
     */
    test('應該保護邀請過程中的敏感資料', () {
      // Given
      final dataProtector = InvitationDataProtector();
      final sensitiveData = InvitationData(
        recipientEmail: 'sensitive@company.com',
        personalMessage: '包含機密資訊的邀請訊息',
        ledgerName: '內部財務帳本',
      );

      // When
      final protectedData = dataProtector.protectSensitiveData(sensitiveData);

      // Then
      expect(protectedData.recipientEmail, isNot(contains('@'))); // Email被遮蔽
      expect(protectedData.personalMessage, contains('***')); // 訊息被部分遮蔽
      expect(protectedData.auditTrail, isNotEmpty); // 包含審計追蹤
    });
  });
}
```

---

## 8.0 測試資料管理（Test Data Management）

### 8.1 測試資料生成器

```dart
// test/data/invitation_test_data_generator.dart

/**
 * 邀請測試資料生成器_v1.0.0
 * @module InvitationTestDataGenerator
 * @description 邀請成員測試用資料生成器
 * @update 2025-01-26: 建立測試資料生成工具
 */

class InvitationTestDataGenerator {
  static final Random _random = Random();

  /**
   * 35. 生成測試用Email清單
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 生成各種格式的測試Email清單
   */
  static List<String> generateTestEmails({
    int count = 10,
    bool includeInvalid = false,
    bool includeDuplicates = false,
  }) {
    final emails = <String>[];
    final domains = ['test.com', 'example.org', 'demo.net', 'sample.edu'];
    
    // 生成有效的Email
    for (int i = 0; i < count; i++) {
      final username = 'user${i}_${_random.nextInt(1000)}';
      final domain = domains[i % domains.length];
      emails.add('$username@$domain');
    }

    // 添加無效Email（如果需要）
    if (includeInvalid) {
      emails.addAll([
        'invalid-email',
        '@missing-username.com',
        'missing-at-symbol.com',
        'double..dot@example.com',
      ]);
    }

    // 添加重複Email（如果需要）
    if (includeDuplicates && emails.isNotEmpty) {
      emails.add(emails.first);
    }

    return emails;
  }

  /**
   * 36. 生成邀請場景測試資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 生成各種邀請場景的測試資料
   */
  static List<InvitationScenario> generateInvitationScenarios() {
    return [
      InvitationScenario(
        name: '單一Email邀請',
        emails: ['single@example.com'],
        expectedSuccessCount: 1,
        expectedFailureCount: 0,
      ),
      InvitationScenario(
        name: '批量Email邀請',
        emails: generateTestEmails(count: 5),
        expectedSuccessCount: 5,
        expectedFailureCount: 0,
      ),
      InvitationScenario(
        name: '混合有效無效Email',
        emails: generateTestEmails(count: 3, includeInvalid: true),
        expectedSuccessCount: 3,
        expectedFailureCount: 4, // 4個無效Email
      ),
      InvitationScenario(
        name: '包含重複Email',
        emails: generateTestEmails(count: 3, includeDuplicates: true),
        expectedSuccessCount: 3,
        expectedFailureCount: 0,
        expectedDuplicateCount: 1,
      ),
    ];
  }

  /**
   * 37. 生成邀請連結配置
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 生成邀請連結配置測試資料
   */
  static List<InvitationLinkConfig> generateLinkConfigs() {
    return [
      InvitationLinkConfig(
        ledgerId: 'test_ledger_001',
        defaultRole: 'member',
        expiryDays: 7,
        usageLimit: 1,
        requireApproval: false,
      ),
      InvitationLinkConfig(
        ledgerId: 'test_ledger_002',
        defaultRole: 'viewer',
        expiryDays: 30,
        usageLimit: 10,
        requireApproval: true,
      ),
      InvitationLinkConfig(
        ledgerId: 'test_ledger_003',
        defaultRole: 'admin',
        expiryDays: 90,
        usageLimit: 100,
        requireApproval: false,
      ),
    ];
  }

  /**
   * 38. 生成性能測試資料集
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 生成大量資料用於性能測試
   */
  static PerformanceTestDataSet generatePerformanceTestData() {
    return PerformanceTestDataSet(
      smallEmailBatch: generateTestEmails(count: 10),
      mediumEmailBatch: generateTestEmails(count: 50),
      largeEmailBatch: generateTestEmails(count: 100),
      xlEmailBatch: generateTestEmails(count: 500),
      concurrentRequests: List.generate(20, (i) => 
        InvitationRequest(
          email: 'concurrent$i@test.com',
          ledgerId: 'test_ledger',
          role: 'member',
        )),
    );
  }
}

/**
 * 39. 邀請場景資料類別
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 16:50:02
 * @update: 定義邀請測試場景的資料結構
 */
class InvitationScenario {
  final String name;
  final List<String> emails;
  final int expectedSuccessCount;
  final int expectedFailureCount;
  final int expectedDuplicateCount;

  InvitationScenario({
    required this.name,
    required this.emails,
    required this.expectedSuccessCount,
    required this.expectedFailureCount,
    this.expectedDuplicateCount = 0,
  });
}

/**
 * 40. 性能測試資料集類別
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 16:50:02
 * @update: 定義性能測試用的資料集結構
 */
class PerformanceTestDataSet {
  final List<String> smallEmailBatch;
  final List<String> mediumEmailBatch;
  final List<String> largeEmailBatch;
  final List<String> xlEmailBatch;
  final List<InvitationRequest> concurrentRequests;

  PerformanceTestDataSet({
    required this.smallEmailBatch,
    required this.mediumEmailBatch,
    required this.largeEmailBatch,
    required this.xlEmailBatch,
    required this.concurrentRequests,
  });
}
```

### 8.2 測試資料清理器

```dart
// test/data/invitation_test_data_cleaner.dart

/**
 * 邀請測試資料清理器_v1.0.0
 * @module InvitationTestDataCleaner
 * @description 邀請測試後的資料清理工具
 * @update 2025-01-26: 建立邀請測試資料清理機制
 */

class InvitationTestDataCleaner {
  
  /**
   * 41. 清理邀請測試資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 16:50:02
   * @update: 清理測試產生的邀請相關資料
   */
  static Future<void> cleanupInvitationTestData() async {
    // 清理測試邀請記錄
    await _cleanupTestInvitations();
    
    // 清理測試邀請連結
    await _cleanupTestInvitationLinks();
    
    // 清理測試Email記錄
    await _cleanupTestEmailRecords();
    
    // 清理測試QR碼圖片
    await _cleanupTestQRCodes();
    
    // 重置測試狀態
    await _resetInvitationTestState();
  }

  static Future<void> _cleanupTestInvitations() async {
    // 實作測試邀請記錄清理邏輯
  }

  static Future<void> _cleanupTestInvitationLinks() async {
    // 實作測試邀請連結清理邏輯
  }

  static Future<void> _cleanupTestEmailRecords() async {
    // 實作測試Email記錄清理邏輯
  }

  static Future<void> _cleanupTestQRCodes() async {
    // 實作測試QR碼圖片清理邏輯
  }

  static Future<void> _resetInvitationTestState() async {
    // 實作測試狀態重置邏輯
  }
}
```

---

## 文件維護記錄

| 版本 | 日期 | 修改者 | 修改內容 |
|------|------|--------|----------|
| **v1.0.0** | **2025-01-26** | **LCAS SA Team** | **P023邀請成員頁面TDD建立：完整的測試驅動開發規格，包含41個測試函數，涵蓋單元測試、整合測試、UI測試、效能測試、安全性測試等全面測試策略** |

---

## 備註

- **版本1.0.0特色**: 完整的邀請成員頁面TDD，包含41個測試函數的全面覆蓋
- **對應SRS**: P023_邀請成員頁面_SRS.md的完整測試實作
- **測試架構**: 分層測試策略，確保邀請系統的穩定性與安全性
- **測試覆蓋**: 單元測試、整合測試、UI測試、效能測試、安全性測試
- **API整合**: CollaborationService、ProjectLedgerService、EmailService整合測試
- **安全測試**: Email注入防護、邀請濫用防護、敏感資料保護
- **效能測試**: 大量Email處理、併發邀請、QR碼生成效能驗證
- **測試資料**: 完整的測試資料生成器與清理機制，支援多種測試場景
- **品質保證**: 90%以上程式碼覆蓋率、100%功能覆蓋率目標
- **維護性**: 模組化測試設計，易於擴展和維護
