
# TDD_P027_建立預算頁面_v1.0.0

**文件編號**: 8827  
**版本**: v1.0.0  
**建立日期**: 2025-01-26  
**建立者**: LCAS SA Team  
**最後更新**: 2025-01-26 20:15:00 UTC+8

---

## 目次

1. [模組概述](#10-模組概述module-overview)
2. [測試需求分析](#20-測試需求分析test-requirements-analysis)
3. [核心Widget架構](#30-核心widget架構core-widget-architecture)
4. [預算建立流程測試](#40-預算建立流程測試budget-creation-flow-tests)
5. [表單驗證測試](#50-表單驗證測試form-validation-tests)
6. [四模式差異化測試](#60-四模式差異化測試four-mode-differentiation-tests)
7. [API整合測試](#70-api整合測試api-integration-tests)
8. [使用者互動測試](#80-使用者互動測試user-interaction-tests)
9. [效能與快取測試](#90-效能與快取測試performance-and-cache-tests)

---

## 1.0 模組概述（Module Overview）

### 1.1 產品定位
P027建立預算頁面TDD規格是LCAS 2.0 Flutter Presentation Layer的預算建立核心界面測試檔案，負責驗證多步驟預算建立流程、智慧預算建議、範本應用、表單驗證等完整預算建立功能的正確性與效能表現。

### 1.2 測試覆蓋範圍
- **完整建立流程**: 多步驟預算建立精靈、進度指示、流程導航測試
- **智慧建議功能**: 預算範本選擇、智慧金額建議、分類推薦測試
- **四模式適配**: 精準控制者、紀錄習慣者、轉型挑戰者、潛在覺醒者界面測試
- **API整合驗證**: BudgetService、ProjectLedgerService、CollaborationService整合測試
- **互動體驗測試**: 觸控操作、表單驗證、響應式設計測試

---

## 2.0 測試需求分析（Test Requirements Analysis）

### 2.1 功能性測試需求

#### 2.1.1 核心預算建立功能
- **基本資訊設定**: 預算名稱、類型、金額的輸入和驗證
- **時間範圍設定**: 開始日期、結束日期、週期性設定
- **分類項目配置**: 預算分類選擇、專案關聯設定
- **預算建立完成**: 資料提交、驗證、儲存流程

#### 2.1.2 預算建立精靈需求
- **步驟導航**: 多步驟流程的前進、後退、跳躍
- **進度指示**: 當前步驟、完成度、剩餘步驟顯示
- **資料暫存**: 步驟間資料保存、草稿功能
- **流程驗證**: 每步驟的資料驗證和錯誤提示

#### 2.1.3 智慧建議功能
- **範本選擇**: 預算範本清單、預覽、套用功能
- **智慧建議**: 基於歷史資料的金額建議
- **分類推薦**: 常用分類、相關分類推薦
- **預設值處理**: 合理預設值設定和調整

### 2.2 非功能性測試需求

#### 2.2.1 效能需求
- **頁面載入**: 建立頁面初始載入時間 ≤ 2秒
- **步驟切換**: 精靈步驟切換時間 ≤ 500ms
- **表單驗證**: 即時驗證響應時間 ≤ 100ms
- **資料提交**: 預算建立提交時間 ≤ 3秒

#### 2.2.2 使用者體驗需求
- **操作直觀**: 建立流程清晰易懂，引導明確
- **錯誤處理**: 友善的錯誤提示和修正建議
- **資料保護**: 意外離開時的資料保護機制
- **輔助功能**: 無障礙設計和鍵盤導航支援

---

## 3.0 核心Widget架構（Core Widget Architecture）

### 3.1 主頁面Widget測試

#### 3.1.1 CreateBudgetPage Widget
```dart
/**
 * 01. 對應 SRS P027：建立預算頁面主Widget測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試建立預算頁面的完整功能和四模式差異化界面
 */
class CreateBudgetPageTest extends StatefulWidget {
  final String? ledgerId;
  final String? templateId;
  final UserMode? userMode;
  final VoidCallback? onBudgetCreated;

  const CreateBudgetPageTest({
    Key? key,
    this.ledgerId,
    this.templateId,
    this.userMode,
    this.onBudgetCreated,
  }) : super(key: key);

  @override
  State<CreateBudgetPageTest> createState() => _CreateBudgetPageTestState();
}

class _CreateBudgetPageTestState extends State<CreateBudgetPageTest>
    with TickerProviderStateMixin {
  late PageController _pageController;
  late AnimationController _progressAnimationController;
  late CreateBudgetProvider _provider;

  /**
   * 02. 初始化建立預算頁面並載入相關資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 載入預算範本、分類資料並初始化建立狀態
   */
  Future<void> _initializeCreateBudget();

  @override
  void initState() {
    super.initState();
    _setupControllers();
    _initializeCreateBudget();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<CreateBudgetProvider>(
      builder: (context, provider, child) {
        return Scaffold(
          appBar: _buildAppBar(context, provider),
          body: _buildBody(context, provider),
          bottomNavigationBar: _buildBottomNavigation(context, provider),
        );
      },
    );
  }

  /**
   * 03. 設定控制器和動畫
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 初始化頁面控制器和動畫控制器
   */
  void _setupControllers();

  @override
  void dispose() {
    _pageController.dispose();
    _progressAnimationController.dispose();
    super.dispose();
  }
}
```

### 3.2 建立精靈Widget

#### 3.2.1 BudgetCreationWizard Widget
```dart
/**
 * 04. 對應 2.2：預算建立精靈Widget
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 提供多步驟預算建立流程的精靈界面
 */
class BudgetCreationWizard extends StatelessWidget {
  final PageController pageController;
  final CreateBudgetProvider provider;
  final UserMode userMode;

  const BudgetCreationWizard({
    Key? key,
    required this.pageController,
    required this.provider,
    required this.userMode,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildProgressIndicator(context),
        Expanded(
          child: PageView(
            controller: pageController,
            physics: const NeverScrollableScrollPhysics(),
            children: [
              _buildBasicInfoStep(context),
              _buildBudgetTypeStep(context),
              _buildAmountConfigStep(context),
              _buildTimeRangeStep(context),
              _buildCategoryStep(context),
              _buildAdvancedSettingsStep(context),
              _buildReviewStep(context),
            ],
          ),
        ),
      ],
    );
  }

  /**
   * 05. 建構進度指示器
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 顯示當前步驟和整體進度的指示器
   */
  Widget _buildProgressIndicator(BuildContext context);

  /**
   * 06. 建構基本資訊設定步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 預算名稱、描述等基本資訊輸入界面
   */
  Widget _buildBasicInfoStep(BuildContext context);

  /**
   * 07. 建構預算類型選擇步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 總預算、分類預算、專案預算類型選擇界面
   */
  Widget _buildBudgetTypeStep(BuildContext context);

  /**
   * 08. 建構預算金額配置步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 預算金額設定和智慧建議界面
   */
  Widget _buildAmountConfigStep(BuildContext context);

  /**
   * 09. 建構時間範圍設定步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 開始日期、結束日期、週期性設定界面
   */
  Widget _buildTimeRangeStep(BuildContext context);

  /**
   * 10. 建構分類項目配置步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 預算適用分類和項目選擇界面
   */
  Widget _buildCategoryStep(BuildContext context);

  /**
   * 11. 建構進階設定步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 警示設定、提醒設定等進階選項界面
   */
  Widget _buildAdvancedSettingsStep(BuildContext context);

  /**
   * 12. 建構預覽確認步驟
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 預算設定預覽和最終確認界面
   */
  Widget _buildReviewStep(BuildContext context);
}
```

### 3.3 範本選擇Widget

#### 3.3.1 BudgetTemplateSelector Widget
```dart
/**
 * 13. 對應 3.3：預算範本選擇器Widget
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 提供預算範本選擇和預覽功能
 */
class BudgetTemplateSelector extends StatelessWidget {
  final List<BudgetTemplate> templates;
  final BudgetTemplate? selectedTemplate;
  final UserMode userMode;
  final Function(BudgetTemplate)? onTemplateSelected;
  final VoidCallback? onCustomTemplate;

  const BudgetTemplateSelector({
    Key? key,
    required this.templates,
    this.selectedTemplate,
    required this.userMode,
    this.onTemplateSelected,
    this.onCustomTemplate,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionHeader(context),
        const SizedBox(height: 16),
        _buildQuickStartOptions(context),
        const SizedBox(height: 24),
        _buildTemplateGrid(context),
        const SizedBox(height: 16),
        _buildCustomTemplateOption(context),
      ],
    );
  }

  /**
   * 14. 建構範本選擇器標題區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 顯示範本選擇的標題和說明
   */
  Widget _buildSectionHeader(BuildContext context);

  /**
   * 15. 建構快速開始選項
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 提供常用預算類型的快速建立選項
   */
  Widget _buildQuickStartOptions(BuildContext context);

  /**
   * 16. 建構範本網格列表
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 以網格形式展示所有可用範本
   */
  Widget _buildTemplateGrid(BuildContext context);

  /**
   * 17. 建構單一範本卡片
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 顯示範本資訊、預覽、選擇功能的卡片
   */
  Widget _buildTemplateCard(BuildContext context, BudgetTemplate template);

  /**
   * 18. 建構自訂範本選項
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 提供從零開始建立自訂預算的選項
   */
  Widget _buildCustomTemplateOption(BuildContext context);
}
```

---

## 4.0 預算建立流程測試（Budget Creation Flow Tests）

### 4.1 建立流程完整性測試

#### 4.1.1 BudgetCreationFlowTest
```dart
/**
 * 19. 對應 4.1：預算建立流程完整性測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試完整的預算建立流程和步驟導航
 */
class BudgetCreationFlowTest {

  /**
   * 20. 測試完整建立流程
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試從開始到完成的完整預算建立流程
   */
  @test
  void testCompleteBudgetCreationFlow() async {
    // Arrange
    final mockBudgetService = MockBudgetService();
    final provider = CreateBudgetProvider(budgetService: mockBudgetService);

    await tester.pumpWidget(
      MaterialApp(
        home: ChangeNotifierProvider<CreateBudgetProvider>.value(
          value: provider,
          child: CreateBudgetPage(userMode: UserMode.preciseController),
        ),
      ),
    );

    // Act & Assert - 步驟1: 基本資訊
    expect(find.text('預算名稱'), findsOneWidget);
    await tester.enterText(find.byKey(Key('budget_name_field')), '餐飲預算');
    await tester.enterText(find.byKey(Key('budget_description_field')), '每月餐飲支出預算');

    // 進入下一步
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟2: 預算類型
    expect(find.text('選擇預算類型'), findsOneWidget);
    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟3: 金額配置
    expect(find.text('設定預算金額'), findsOneWidget);
    await tester.enterText(find.byKey(Key('budget_amount_field')), '5000');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟4: 時間範圍
    expect(find.text('設定時間範圍'), findsOneWidget);
    await tester.tap(find.byKey(Key('start_date_picker')));
    await tester.pumpAndSettle();
    // 選擇當月第一天
    await tester.tap(find.text('1'));
    await tester.tap(find.text('確定'));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟5: 分類設定
    expect(find.text('選擇適用分類'), findsOneWidget);
    await tester.tap(find.byKey(Key('category_2003')));  // 餐飲費
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟6: 進階設定（跳過）
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟7: 預覽確認
    expect(find.text('預算設定預覽'), findsOneWidget);
    expect(find.text('餐飲預算'), findsOneWidget);
    expect(find.text('5,000'), findsOneWidget);

    // 模擬API回應
    when(mockBudgetService.createBudget(any)).thenAnswer((_) async => 
      BudgetResponse(
        success: true,
        budgetId: 'budget_001',
        budgetName: '餐飲預算',
        budgetAmount: 5000.0,
        currentSpent: 0.0,
        remainingAmount: 5000.0,
        usagePercentage: 0.0,
        budgetPeriod: 'monthly',
        startDate: DateTime.now(),
        endDate: DateTime.now().add(Duration(days: 30)),
        status: BudgetStatus.active,
      )
    );

    // 確認建立
    await tester.tap(find.byKey(Key('create_budget_button')));
    await tester.pumpAndSettle();

    // 驗證API調用
    verify(mockBudgetService.createBudget(any)).called(1);

    // 驗證成功訊息
    expect(find.text('預算建立成功'), findsOneWidget);
  }

  /**
   * 21. 測試步驟導航功能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試精靈步驟間的前進、後退、跳躍導航
   */
  @test
  void testStepNavigation() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    // Act & Assert - 測試前進
    for (int step = 1; step <= 7; step++) {
      expect(find.byKey(Key('step_indicator_$step')), findsOneWidget);
      
      if (step < 7) {
        await tester.tap(find.byKey(Key('next_button')));
        await tester.pumpAndSettle();
      }
    }

    // 測試後退
    for (int step = 6; step >= 1; step--) {
      await tester.tap(find.byKey(Key('back_button')));
      await tester.pumpAndSettle();
      expect(find.byKey(Key('step_indicator_$step')), findsOneWidget);
    }
  }

  /**
   * 22. 測試進度指示器
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試進度指示器的顯示和動畫效果
   */
  @test
  void testProgressIndicator() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.transformChallenger),
      ),
    );

    // Act & Assert
    // 檢查初始狀態
    expect(find.byKey(Key('progress_bar')), findsOneWidget);
    expect(find.text('步驟 1 / 7'), findsOneWidget);

    // 檢查進度條初始值
    final progressBar = tester.widget<LinearProgressIndicator>(
      find.byKey(Key('progress_bar'))
    );
    expect(progressBar.value, closeTo(1/7, 0.01));

    // 前進到步驟3
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 檢查更新後的進度
    expect(find.text('步驟 3 / 7'), findsOneWidget);
    final updatedProgressBar = tester.widget<LinearProgressIndicator>(
      find.byKey(Key('progress_bar'))
    );
    expect(updatedProgressBar.value, closeTo(3/7, 0.01));
  }
}
```

### 4.2 範本應用測試

#### 4.2.1 TemplateApplicationTest
```dart
/**
 * 23. 對應 4.2：範本應用功能測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試預算範本選擇和套用功能
 */
class TemplateApplicationTest {

  /**
   * 24. 測試範本選擇功能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試從範本清單中選擇範本的功能
   */
  @test
  void testTemplateSelection() async {
    // Arrange
    final mockTemplates = [
      BudgetTemplate(
        id: 'template_001',
        name: '餐飲預算範本',
        description: '適合餐飲支出管理',
        budgetType: BudgetType.category,
        defaultAmount: 3000.0,
        categories: ['2003'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
      BudgetTemplate(
        id: 'template_002',
        name: '交通預算範本',
        description: '適合交通費用管理',
        budgetType: BudgetType.category,
        defaultAmount: 2000.0,
        categories: ['2004'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
    ];

    await tester.pumpWidget(
      MaterialApp(
        home: BudgetTemplateSelector(
          templates: mockTemplates,
          userMode: UserMode.potentialAwakener,
          onTemplateSelected: (template) => print('Selected: ${template.name}'),
        ),
      ),
    );

    // Act & Assert
    expect(find.text('餐飲預算範本'), findsOneWidget);
    expect(find.text('交通預算範本'), findsOneWidget);

    // 點擊選擇餐飲預算範本
    await tester.tap(find.text('餐飲預算範本'));
    await tester.pumpAndSettle();

    // 驗證範本被選中
    final selectedCard = tester.widget<Card>(
      find.ancestor(
        of: find.text('餐飲預算範本'),
        matching: find.byType(Card),
      )
    );
    expect(selectedCard.color, equals(Colors.blue.shade50));
  }

  /**
   * 25. 測試範本套用功能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試選擇範本後自動填充表單資料
   */
  @test
  void testTemplateApplication() async {
    // Arrange
    final mockProvider = MockCreateBudgetProvider();
    final template = BudgetTemplate(
      id: 'template_001',
      name: '購物預算範本',
      description: '每月購物支出控制',
      budgetType: BudgetType.category,
      defaultAmount: 4000.0,
      categories: ['2005'],
      alertConfig: AlertConfig(
        enableAlerts: true,
        warningThreshold: 80.0,
        dangerThreshold: 95.0,
        notificationMethods: [NotificationMethod.push],
      ),
    );

    when(mockProvider.applyTemplate(any)).thenAnswer((_) async => {});

    await tester.pumpWidget(
      MaterialApp(
        home: ChangeNotifierProvider<CreateBudgetProvider>.value(
          value: mockProvider,
          child: CreateBudgetPage(
            templateId: template.id,
            userMode: UserMode.habitTracker,
          ),
        ),
      ),
    );

    // Act
    await tester.pumpAndSettle();

    // Assert
    verify(mockProvider.applyTemplate(template.id)).called(1);

    // 驗證表單資料被填充
    expect(find.text('購物預算範本'), findsOneWidget);
    expect(find.text('4,000'), findsOneWidget);
    expect(find.text('分類預算'), findsOneWidget);
  }

  /**
   * 26. 測試自訂範本建立
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試從零開始建立自訂預算的功能
   */
  @test
  void testCustomTemplateCreation() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetTemplateSelector(
          templates: [],
          userMode: UserMode.preciseController,
          onCustomTemplate: () => print('Custom template selected'),
        ),
      ),
    );

    // Act
    await tester.tap(find.byKey(Key('custom_template_button')));
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('自訂預算'), findsOneWidget);
    expect(find.text('從零開始建立您的專屬預算'), findsOneWidget);

    // 點擊自訂範本按鈕
    await tester.tap(find.text('開始自訂'));
    await tester.pumpAndSettle();

    // 驗證導航到基本資訊步驟
    expect(find.text('預算名稱'), findsOneWidget);
    expect(find.byKey(Key('budget_name_field')), findsOneWidget);
  }
}
```

---

## 5.0 表單驗證測試（Form Validation Tests）

### 5.1 輸入驗證測試

#### 5.1.1 InputValidationTest
```dart
/**
 * 27. 對應 5.1：表單輸入驗證測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試表單各欄位的輸入驗證和錯誤處理
 */
class InputValidationTest {

  /**
   * 28. 測試預算名稱驗證
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試預算名稱的長度、格式、唯一性驗證
   */
  @test
  void testBudgetNameValidation() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.preciseController),
      ),
    );

    final nameField = find.byKey(Key('budget_name_field'));

    // Test Case 1: 空名稱
    await tester.enterText(nameField, '');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('請輸入預算名稱'), findsOneWidget);

    // Test Case 2: 名稱過短
    await tester.enterText(nameField, 'a');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算名稱至少需要2個字元'), findsOneWidget);

    // Test Case 3: 名稱過長
    final longName = 'a' * 51;
    await tester.enterText(nameField, longName);
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算名稱不可超過50個字元'), findsOneWidget);

    // Test Case 4: 有效名稱
    await tester.enterText(nameField, '餐飲預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('請輸入預算名稱'), findsNothing);
    expect(find.text('選擇預算類型'), findsOneWidget);
  }

  /**
   * 29. 測試預算金額驗證
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試預算金額的數值範圍和格式驗證
   */
  @test
  void testBudgetAmountValidation() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    // 導航到金額設定步驟
    await _navigateToAmountStep();

    final amountField = find.byKey(Key('budget_amount_field'));

    // Test Case 1: 空金額
    await tester.enterText(amountField, '');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('請輸入預算金額'), findsOneWidget);

    // Test Case 2: 負數金額
    await tester.enterText(amountField, '-100');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算金額必須大於0'), findsOneWidget);

    // Test Case 3: 零金額
    await tester.enterText(amountField, '0');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算金額必須大於0'), findsOneWidget);

    // Test Case 4: 過大金額
    await tester.enterText(amountField, '1000000000');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算金額不可超過999,999,999'), findsOneWidget);

    // Test Case 5: 無效格式
    await tester.enterText(amountField, 'abc');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('請輸入有效的金額'), findsOneWidget);

    // Test Case 6: 有效金額
    await tester.enterText(amountField, '5000');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('請輸入預算金額'), findsNothing);
    expect(find.text('設定時間範圍'), findsOneWidget);
  }

  /**
   * 30. 測試日期範圍驗證
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試開始日期和結束日期的邏輯驗證
   */
  @test
  void testDateRangeValidation() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.transformChallenger),
      ),
    );

    // 導航到時間範圍步驟
    await _navigateToTimeRangeStep();

    // Test Case 1: 結束日期早於開始日期
    await tester.tap(find.byKey(Key('start_date_picker')));
    await tester.pumpAndSettle();
    await tester.tap(find.text('15')); // 選擇15號
    await tester.tap(find.text('確定'));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('end_date_picker')));
    await tester.pumpAndSettle();
    await tester.tap(find.text('10')); // 選擇10號（早於開始日期）
    await tester.tap(find.text('確定'));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('結束日期必須晚於開始日期'), findsOneWidget);

    // Test Case 2: 期間過短
    await tester.tap(find.byKey(Key('end_date_picker')));
    await tester.pumpAndSettle();
    await tester.tap(find.text('15')); // 同一天
    await tester.tap(find.text('確定'));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算期間至少需要1天'), findsOneWidget);

    // Test Case 3: 有效日期範圍
    await tester.tap(find.byKey(Key('end_date_picker')));
    await tester.pumpAndSettle();
    await tester.tap(find.text('30')); // 選擇30號
    await tester.tap(find.text('確定'));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('結束日期必須晚於開始日期'), findsNothing);
    expect(find.text('選擇適用分類'), findsOneWidget);
  }

  Future<void> _navigateToAmountStep() async {
    // 填寫基本資訊
    await tester.enterText(find.byKey(Key('budget_name_field')), '測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 選擇預算類型
    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
  }

  Future<void> _navigateToTimeRangeStep() async {
    await _navigateToAmountStep();
    
    // 填寫金額
    await tester.enterText(find.byKey(Key('budget_amount_field')), '5000');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
  }
}
```

### 5.2 即時驗證測試

#### 5.2.1 RealTimeValidationTest
```dart
/**
 * 31. 對應 5.2：即時驗證功能測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試表單欄位的即時驗證和回饋機制
 */
class RealTimeValidationTest {

  /**
   * 32. 測試即時名稱唯一性檢查
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試預算名稱的即時唯一性驗證
   */
  @test
  void testRealTimeNameUniquenessCheck() async {
    // Arrange
    final mockBudgetService = MockBudgetService();
    when(mockBudgetService.validateBudgetName(any))
        .thenAnswer((_) async => ValidateNameResponse(
          isValid: false,
          suggestions: ['餐飲預算_新', '餐飲支出預算'],
        ));

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(userMode: UserMode.potentialAwakener),
        ),
      ),
    );

    final nameField = find.byKey(Key('budget_name_field'));

    // Act
    await tester.enterText(nameField, '餐飲預算');
    await tester.pump(Duration(milliseconds: 500)); // 等待防抖延遲

    // Assert
    verify(mockBudgetService.validateBudgetName(any)).called(1);
    expect(find.text('此預算名稱已存在'), findsOneWidget);
    expect(find.text('建議名稱：'), findsOneWidget);
    expect(find.text('餐飲預算_新'), findsOneWidget);
  }

  /**
   * 33. 測試即時金額格式化
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試金額輸入的即時格式化和驗證
   */
  @test
  void testRealTimeAmountFormatting() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    await _navigateToAmountStep();

    final amountField = find.byKey(Key('budget_amount_field'));

    // Act & Assert
    // 測試千位分隔符自動格式化
    await tester.enterText(amountField, '12345');
    await tester.pump();

    final textField = tester.widget<TextField>(amountField);
    expect(textField.controller?.text, equals('12,345'));

    // 測試小數點格式化
    await tester.enterText(amountField, '12345.67');
    await tester.pump();

    expect(textField.controller?.text, equals('12,345.67'));

    // 測試超過兩位小數的處理
    await tester.enterText(amountField, '12345.678');
    await tester.pump();

    expect(textField.controller?.text, equals('12,345.68'));
  }

  /**
   * 34. 測試智慧建議功能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試基於歷史資料的智慧金額建議
   */
  @test
  void testSmartAmountSuggestions() async {
    // Arrange
    final mockBudgetService = MockBudgetService();
    when(mockBudgetService.getSmartSuggestions(any))
        .thenAnswer((_) async => SmartSuggestionsResponse(
          suggestions: [
            AmountSuggestion(
              amount: 3000.0,
              reason: '基於過去3個月平均支出',
              confidence: 0.85,
            ),
            AmountSuggestion(
              amount: 3500.0,
              reason: '建議增加15%緩衝',
              confidence: 0.75,
            ),
          ],
        ));

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(userMode: UserMode.preciseController),
        ),
      ),
    );

    await _navigateToAmountStep();

    // Act
    await tester.tap(find.byKey(Key('smart_suggestion_button')));
    await tester.pumpAndSettle();

    // Assert
    verify(mockBudgetService.getSmartSuggestions(any)).called(1);
    expect(find.text('智慧建議'), findsOneWidget);
    expect(find.text('3,000'), findsOneWidget);
    expect(find.text('基於過去3個月平均支出'), findsOneWidget);
    expect(find.text('3,500'), findsOneWidget);

    // 測試點擊建議
    await tester.tap(find.text('3,000'));
    await tester.pumpAndSettle();

    final amountField = tester.widget<TextField>(find.byKey(Key('budget_amount_field')));
    expect(amountField.controller?.text, equals('3,000'));
  }

  Future<void> _navigateToAmountStep() async {
    await tester.enterText(find.byKey(Key('budget_name_field')), '測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
  }
}
```

---

## 6.0 四模式差異化測試（Four Mode Differentiation Tests）

### 6.1 界面適配測試

#### 6.1.1 UserModeInterfaceTest
```dart
/**
 * 35. 對應 6.1：使用者模式界面適配測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試四種使用者模式的界面差異化適配
 */
class UserModeInterfaceTest {

  /**
   * 36. 測試精準控制者模式界面
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試精準控制者模式的完整功能界面
   */
  @test
  void testPreciseControllerInterface() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.preciseController),
      ),
    );

    // Assert - 檢查完整功能可見性
    expect(find.text('進階設定'), findsOneWidget);
    expect(find.byKey(Key('smart_suggestion_button')), findsOneWidget);
    expect(find.byKey(Key('template_selector')), findsOneWidget);
    expect(find.byKey(Key('advanced_alerts_config')), findsOneWidget);

    // 檢查所有步驟都可見
    final stepIndicators = find.byType(StepIndicator);
    expect(stepIndicators, findsNWidgets(7));

    // 檢查詳細選項
    await _navigateToAdvancedStep();
    expect(find.text('警示閾值設定'), findsOneWidget);
    expect(find.text('通知方式選擇'), findsOneWidget);
    expect(find.text('自動調整選項'), findsOneWidget);
  }

  /**
   * 37. 測試紀錄習慣者模式界面
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試紀錄習慣者模式的美觀簡化界面
   */
  @test
  void testHabitTrackerInterface() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    // Assert - 檢查美觀設計元素
    expect(find.byType(AnimatedContainer), findsWidgets);
    expect(find.byType(GradientBackground), findsOneWidget);

    // 檢查簡化的步驟指示
    final progressBar = tester.widget<LinearProgressIndicator>(
      find.byKey(Key('progress_bar'))
    );
    expect(progressBar.backgroundColor, equals(Colors.grey.shade200));
    expect(progressBar.valueColor?.value, equals(Colors.green));

    // 檢查美觀的卡片設計
    final cards = find.byType(Card);
    expect(cards, findsWidgets);

    final firstCard = tester.widget<Card>(cards.first);
    expect(firstCard.elevation, greaterThan(4.0));
    expect(firstCard.shape, isA<RoundedRectangleBorder>());
  }

  /**
   * 38. 測試轉型挑戰者模式界面
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試轉型挑戰者模式的目標導向界面
   */
  @test
  void testTransformChallengerInterface() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.transformChallenger),
      ),
    );

    // Assert - 檢查激勵元素
    expect(find.text('設定您的理財目標'), findsOneWidget);
    expect(find.byKey(Key('motivation_quotes')), findsOneWidget);
    expect(find.byKey(Key('achievement_badges')), findsOneWidget);

    // 檢查挑戰性設計
    expect(find.text('挑戰等級'), findsOneWidget);
    expect(find.byType(ProgressIndicator), findsWidgets);

    // 檢查目標設定功能
    await _navigateToAmountStep();
    expect(find.text('設定挑戰目標'), findsOneWidget);
    expect(find.byKey(Key('challenge_level_selector')), findsOneWidget);
  }

  /**
   * 39. 測試潛在覺醒者模式界面
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試潛在覺醒者模式的極簡界面
   */
  @test
  void testPotentialAwakenerInterface() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.potentialAwakener),
      ),
    );

    // Assert - 檢查簡化元素
    // 步驟數量應該減少
    final stepIndicators = find.byType(StepIndicator);
    expect(stepIndicators, findsNWidgets(4)); // 簡化為4步驟

    // 檢查大按鈕設計
    final buttons = find.byType(ElevatedButton);
    expect(buttons, findsWidgets);

    final firstButton = tester.widget<ElevatedButton>(buttons.first);
    expect(firstButton.style?.minimumSize?.resolve({}), 
           equals(Size(200, 56))); // 大按鈕尺寸

    // 檢查簡化的表單
    expect(find.text('進階設定'), findsNothing);
    expect(find.byKey(Key('advanced_alerts_config')), findsNothing);

    // 檢查引導文字
    expect(find.text('讓我們簡單開始'), findsOneWidget);
    expect(find.text('只需要幾個步驟'), findsOneWidget);
  }

  /**
   * 40. 測試模式間的動態切換
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試在建立過程中動態切換使用者模式
   */
  @test
  void testDynamicModeSwitch() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: StatefulBuilder(
          builder: (context, setState) {
            return CreateBudgetPage(
              userMode: UserMode.preciseController,
              onModeChanged: (newMode) => setState(() {
                // 重建頁面以反映新模式
              }),
            );
          },
        ),
      ),
    );

    // Act - 切換到潛在覺醒者模式
    await tester.tap(find.byKey(Key('mode_switcher')));
    await tester.pumpAndSettle();
    await tester.tap(find.text('簡化模式'));
    await tester.pumpAndSettle();

    // Assert - 檢查界面已更新
    expect(find.text('讓我們簡單開始'), findsOneWidget);
    final stepIndicators = find.byType(StepIndicator);
    expect(stepIndicators, findsNWidgets(4));
  }

  Future<void> _navigateToAmountStep() async {
    await tester.enterText(find.byKey(Key('budget_name_field')), '測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
  }

  Future<void> _navigateToAdvancedStep() async {
    // 完成前面所有步驟
    for (int i = 0; i < 5; i++) {
      await tester.tap(find.byKey(Key('next_button')));
      await tester.pumpAndSettle();
    }
  }
}
```

### 6.2 功能差異化測試

#### 6.2.1 FeatureDifferentiationTest
```dart
/**
 * 41. 對應 6.2：功能差異化測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試不同使用者模式下功能的可見性和可用性
 */
class FeatureDifferentiationTest {

  /**
   * 42. 測試進階功能可見性
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試不同模式下進階功能的顯示與隱藏
   */
  @test
  void testAdvancedFeatureVisibility() async {
    final testCases = [
      (UserMode.preciseController, true),
      (UserMode.habitTracker, false),
      (UserMode.transformChallenger, true),
      (UserMode.potentialAwakener, false),
    ];

    for (final (mode, shouldShowAdvanced) in testCases) {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: CreateBudgetPage(userMode: mode),
        ),
      );

      // Act & Assert
      if (shouldShowAdvanced) {
        expect(find.text('進階設定'), findsOneWidget, 
               reason: '$mode should show advanced features');
        expect(find.byKey(Key('custom_alerts_config')), findsOneWidget);
        expect(find.byKey(Key('auto_adjust_settings')), findsOneWidget);
      } else {
        expect(find.text('進階設定'), findsNothing, 
               reason: '$mode should hide advanced features');
        expect(find.byKey(Key('custom_alerts_config')), findsNothing);
        expect(find.byKey(Key('auto_adjust_settings')), findsNothing);
      }

      // 清理
      await tester.pumpWidget(Container());
    }
  }

  /**
   * 43. 測試範本功能差異化
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試不同模式下範本選擇功能的差異
   */
  @test
  void testTemplateFeatureDifferentiation() async {
    // Arrange
    final mockTemplates = _createMockTemplates();

    // Test Case 1: 精準控制者 - 完整範本功能
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetTemplateSelector(
          templates: mockTemplates,
          userMode: UserMode.preciseController,
        ),
      ),
    );

    expect(find.text('專業範本'), findsOneWidget);
    expect(find.text('自訂範本'), findsOneWidget);
    expect(find.byKey(Key('template_preview')), findsWidgets);

    // Test Case 2: 潛在覺醒者 - 簡化範本功能
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetTemplateSelector(
          templates: mockTemplates.take(3).toList(), // 只顯示前3個範本
          userMode: UserMode.potentialAwakener,
        ),
      ),
    );

    expect(find.text('推薦範本'), findsOneWidget);
    expect(find.text('快速開始'), findsOneWidget);
    final templateCards = find.byType(TemplateCard);
    expect(templateCards, findsNWidgets(3)); // 限制範本數量
  }

  /**
   * 44. 測試步驟流程差異化
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試不同模式下建立步驟的差異
   */
  @test
  void testStepFlowDifferentiation() async {
    final stepCounts = {
      UserMode.preciseController: 7,
      UserMode.habitTracker: 6,
      UserMode.transformChallenger: 6,
      UserMode.potentialAwakener: 4,
    };

    for (final entry in stepCounts.entries) {
      final mode = entry.key;
      final expectedSteps = entry.value;

      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: CreateBudgetPage(userMode: mode),
        ),
      );

      // Act & Assert
      final stepIndicators = find.byType(StepIndicator);
      expect(stepIndicators, findsNWidgets(expectedSteps),
             reason: '$mode should have $expectedSteps steps');

      // 檢查特定步驟的存在性
      if (mode == UserMode.potentialAwakener) {
        // 潛在覺醒者模式應該跳過進階設定步驟
        await _navigateToFinalStep(expectedSteps);
        expect(find.text('進階設定'), findsNothing);
      } else {
        // 其他模式應該包含進階設定
        await _navigateToAdvancedStep();
        expect(find.text('進階設定'), findsOneWidget);
      }

      // 清理
      await tester.pumpWidget(Container());
    }
  }

  /**
   * 45. 測試智慧建議功能差異化
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試不同模式下智慧建議功能的複雜度差異
   */
  @test
  void testSmartSuggestionsDifferentiation() async {
    // Arrange
    final mockBudgetService = MockBudgetService();

    // Test Case 1: 精準控制者 - 詳細分析建議
    when(mockBudgetService.getSmartSuggestions(any))
        .thenAnswer((_) async => SmartSuggestionsResponse(
          suggestions: [
            AmountSuggestion(
              amount: 3000.0,
              reason: '基於過去6個月的支出分析',
              confidence: 0.92,
              details: '包含季節性調整和通膨因子',
            ),
          ],
        ));

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(userMode: UserMode.preciseController),
        ),
      ),
    );

    await _navigateToAmountStep();
    await tester.tap(find.byKey(Key('smart_suggestion_button')));
    await tester.pumpAndSettle();

    expect(find.text('詳細分析'), findsOneWidget);
    expect(find.text('信心度: 92%'), findsOneWidget);

    // Test Case 2: 潛在覺醒者 - 簡化建議
    when(mockBudgetService.getSmartSuggestions(any))
        .thenAnswer((_) async => SmartSuggestionsResponse(
          suggestions: [
            AmountSuggestion(
              amount: 3000.0,
              reason: '建議金額',
              confidence: 0.8,
            ),
          ],
        ));

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(userMode: UserMode.potentialAwakener),
        ),
      ),
    );

    await _navigateToAmountStep();
    await tester.tap(find.byKey(Key('smart_suggestion_button')));
    await tester.pumpAndSettle();

    expect(find.text('建議金額'), findsOneWidget);
    expect(find.text('詳細分析'), findsNothing); // 不顯示複雜資訊
    expect(find.text('信心度'), findsNothing); // 不顯示信心度
  }

  List<BudgetTemplate> _createMockTemplates() {
    return [
      BudgetTemplate(
        id: 'template_001',
        name: '餐飲預算',
        description: '日常餐飲支出管理',
        budgetType: BudgetType.category,
        defaultAmount: 3000.0,
        categories: ['2003'],
        isPopular: true,
      ),
      BudgetTemplate(
        id: 'template_002',
        name: '交通預算',
        description: '通勤和出行費用',
        budgetType: BudgetType.category,
        defaultAmount: 2000.0,
        categories: ['2004'],
        isPopular: true,
      ),
      BudgetTemplate(
        id: 'template_003',
        name: '娛樂預算',
        description: '休閒娛樂支出',
        budgetType: BudgetType.category,
        defaultAmount: 1500.0,
        categories: ['2005'],
        isPopular: false,
      ),
    ];
  }

  Future<void> _navigateToAmountStep() async {
    await tester.enterText(find.byKey(Key('budget_name_field')), '測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
  }

  Future<void> _navigateToAdvancedStep() async {
    for (int i = 0; i < 5; i++) {
      await tester.tap(find.byKey(Key('next_button')));
      await tester.pumpAndSettle();
    }
  }

  Future<void> _navigateToFinalStep(int totalSteps) async {
    for (int i = 0; i < totalSteps - 1; i++) {
      await tester.tap(find.byKey(Key('next_button')));
      await tester.pumpAndSettle();
    }
  }
}
```

---

## 7.0 API整合測試（API Integration Tests）

### 7.1 BudgetService整合測試

#### 7.1.1 BudgetServiceIntegrationTest
```dart
/**
 * 46. 對應 7.1：預算服務API整合測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試與BudgetService的完整API整合功能
 */
class BudgetServiceIntegrationTest {
  late MockBudgetService mockBudgetService;
  late CreateBudgetProvider provider;

  @setUp
  void setUp() {
    mockBudgetService = MockBudgetService();
    provider = CreateBudgetProvider(budgetService: mockBudgetService);
  }

  /**
   * 47. 測試建立預算API調用
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試建立預算時的API請求和回應處理
   */
  @test
  void testCreateBudgetAPICall() async {
    // Arrange
    final createBudgetRequest = CreateBudgetRequest(
      budgetName: '測試預算',
      categoryId: '2003',
      budgetAmount: 5000.0,
      budgetPeriod: 'monthly',
      startDate: DateTime(2025, 1, 1),
      endDate: DateTime(2025, 1, 31),
      description: '測試預算描述',
      budgetType: BudgetType.category,
      autoRollover: false,
    );

    final expectedResponse = BudgetResponse(
      success: true,
      budgetId: 'budget_001',
      budgetName: '測試預算',
      budgetAmount: 5000.0,
      currentSpent: 0.0,
      remainingAmount: 5000.0,
      usagePercentage: 0.0,
      budgetPeriod: 'monthly',
      startDate: DateTime(2025, 1, 1),
      endDate: DateTime(2025, 1, 31),
      status: BudgetStatus.active,
    );

    when(mockBudgetService.createBudget(any))
        .thenAnswer((_) async => expectedResponse);

    // Act
    await provider.createBudget(createBudgetRequest);

    // Assert
    verify(mockBudgetService.createBudget(argThat(
      allOf([
        isA<CreateBudgetRequest>(),
        predicate<CreateBudgetRequest>((req) => req.budgetName == '測試預算'),
        predicate<CreateBudgetRequest>((req) => req.budgetAmount == 5000.0),
        predicate<CreateBudgetRequest>((req) => req.categoryId == '2003'),
      ])
    ))).called(1);

    expect(provider.createdBudget, isNotNull);
    expect(provider.createdBudget!.budgetId, equals('budget_001'));
    expect(provider.createdBudget!.budgetName, equals('測試預算'));
    expect(provider.isLoading, isFalse);
    expect(provider.error, isNull);
  }

  /**
   * 48. 測試驗證預算名稱API
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試預算名稱唯一性驗證的API調用
   */
  @test
  void testValidateBudgetNameAPI() async {
    // Arrange
    final validateRequest = ValidateNameRequest(
      name: '餐飲預算',
      ledgerId: 'ledger_001',
    );

    final validateResponse = ValidateNameResponse(
      isValid: false,
      suggestions: ['餐飲預算_2025', '餐飲支出預算'],
    );

    when(mockBudgetService.validateBudgetName(any))
        .thenAnswer((_) async => validateResponse);

    // Act
    await provider.validateBudgetName('餐飲預算', 'ledger_001');

    // Assert
    verify(mockBudgetService.validateBudgetName(argThat(
      allOf([
        isA<ValidateNameRequest>(),
        predicate<ValidateNameRequest>((req) => req.name == '餐飲預算'),
        predicate<ValidateNameRequest>((req) => req.ledgerId == 'ledger_001'),
      ])
    ))).called(1);

    expect(provider.nameValidation, isNotNull);
    expect(provider.nameValidation!.isValid, isFalse);
    expect(provider.nameValidation!.suggestions, contains('餐飲預算_2025'));
  }

  /**
   * 49. 測試取得預算範本API
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試載入預算範本的API調用
   */
  @test
  void testGetBudgetTemplatesAPI() async {
    // Arrange
    final mockTemplates = [
      BudgetTemplate(
        id: 'template_001',
        name: '餐飲預算範本',
        description: '適合餐飲支出管理',
        budgetType: BudgetType.category,
        defaultAmount: 3000.0,
        categories: ['2003'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
      BudgetTemplate(
        id: 'template_002',
        name: '交通預算範本',
        description: '適合交通費用管理',
        budgetType: BudgetType.category,
        defaultAmount: 2000.0,
        categories: ['2004'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
    ];

    when(mockBudgetService.getBudgetTemplates(any))
        .thenAnswer((_) async => mockTemplates);

    // Act
    await provider.loadBudgetTemplates('ledger_001');

    // Assert
    verify(mockBudgetService.getBudgetTemplates('ledger_001')).called(1);
    expect(provider.templates.length, equals(2));
    expect(provider.templates.first.name, equals('餐飲預算範本'));
    expect(provider.templates.last.name, equals('交通預算範本'));
  }

  /**
   * 50. 測試儲存草稿API
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試儲存預算建立草稿的API調用
   */
  @test
  void testSaveDraftAPI() async {
    // Arrange
    final draftData = SaveDraftRequest(
      draftId: 'draft_001',
      name: '草稿預算',
      type: BudgetType.category,
      amount: 3000.0,
      startDate: DateTime(2025, 1, 1).toIso8601String(),
      endDate: DateTime(2025, 1, 31).toIso8601String(),
    );

    when(mockBudgetService.saveDraft(any))
        .thenAnswer((_) async => true);

    // Act
    await provider.saveDraft(draftData);

    // Assert
    verify(mockBudgetService.saveDraft(argThat(
      allOf([
        isA<SaveDraftRequest>(),
        predicate<SaveDraftRequest>((req) => req.name == '草稿預算'),
        predicate<SaveDraftRequest>((req) => req.amount == 3000.0),
      ])
    ))).called(1);

    expect(provider.isDraftSaved, isTrue);
  }

  /**
   * 51. 測試API錯誤處理
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試API請求失敗時的錯誤處理機制
   */
  @test
  void testAPIErrorHandling() async {
    // Arrange
    final createBudgetRequest = CreateBudgetRequest(
      budgetName: '錯誤測試預算',
      categoryId: '2003',
      budgetAmount: 5000.0,
      budgetPeriod: 'monthly',
      startDate: DateTime(2025, 1, 1),
      endDate: DateTime(2025, 1, 31),
      budgetType: BudgetType.category,
      autoRollover: false,
    );

    when(mockBudgetService.createBudget(any))
        .thenThrow(BudgetServiceException('網路連線失敗'));

    // Act
    await provider.createBudget(createBudgetRequest);

    // Assert
    expect(provider.error, isNotNull);
    expect(provider.error, contains('網路連線失敗'));
    expect(provider.createdBudget, isNull);
    expect(provider.isLoading, isFalse);

    verify(mockBudgetService.createBudget(any)).called(1);
  }

  /**
   * 52. 測試網路重試機制
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試網路請求失敗時的自動重試機制
   */
  @test
  void testNetworkRetryMechanism() async {
    // Arrange
    final createBudgetRequest = CreateBudgetRequest(
      budgetName: '重試測試預算',
      categoryId: '2003',
      budgetAmount: 5000.0,
      budgetPeriod: 'monthly',
      startDate: DateTime(2025, 1, 1),
      endDate: DateTime(2025, 1, 31),
      budgetType: BudgetType.category,
      autoRollover: false,
    );

    // 前兩次調用失敗，第三次成功
    when(mockBudgetService.createBudget(any))
        .thenThrow(BudgetServiceException('網路暫時不可用'))
        .thenThrow(BudgetServiceException('伺服器忙碌中'))
        .thenAnswer((_) async => BudgetResponse(
          success: true,
          budgetId: 'budget_retry_001',
          budgetName: '重試測試預算',
          budgetAmount: 5000.0,
          currentSpent: 0.0,
          remainingAmount: 5000.0,
          usagePercentage: 0.0,
          budgetPeriod: 'monthly',
          startDate: DateTime(2025, 1, 1),
          endDate: DateTime(2025, 1, 31),
          status: BudgetStatus.active,
        ));

    // Act
    await provider.createBudgetWithRetry(createBudgetRequest, maxRetries: 3);

    // Assert
    verify(mockBudgetService.createBudget(any)).called(3);
    expect(provider.createdBudget, isNotNull);
    expect(provider.createdBudget!.budgetId, equals('budget_retry_001'));
    expect(provider.error, isNull);
  }
}
```

---

## 8.0 使用者互動測試（User Interaction Tests）

### 8.1 觸控操作測試

#### 8.1.1 TouchInteractionTest
```dart
/**
 * 53. 對應 8.1：觸控互動操作測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試建立預算頁面的各種觸控操作功能
 */
class TouchInteractionTest {

  /**
   * 54. 測試步驟切換觸控操作
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試精靈步驟間的觸控導航功能
   */
  @test
  void testStepNavigationTouch() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    // Act & Assert - 測試下一步按鈕
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    expect(find.text('選擇預算類型'), findsOneWidget);

    // 測試上一步按鈕
    await tester.tap(find.byKey(Key('back_button')));
    await tester.pumpAndSettle();

    expect(find.text('預算名稱'), findsOneWidget);

    // 測試步驟指示器點擊跳轉
    await tester.tap(find.byKey(Key('step_indicator_3')));
    await tester.pumpAndSettle();

    expect(find.text('設定預算金額'), findsOneWidget);
  }

  /**
   * 55. 測試表單輸入觸控操作
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試表單欄位的觸控輸入和選擇功能
   */
  @test
  void testFormInputTouch() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.transformChallenger),
      ),
    );

    // Act & Assert - 測試文字輸入框
    await tester.tap(find.byKey(Key('budget_name_field')));
    await tester.pumpAndSettle();

    // 檢查鍵盤是否顯示（透過檢查焦點）
    final nameField = tester.widget<TextField>(find.byKey(Key('budget_name_field')));
    expect(nameField.focusNode?.hasFocus, isTrue);

    // 測試輸入文字
    await tester.enterText(find.byKey(Key('budget_name_field')), '觸控測試預算');
    expect(find.text('觸控測試預算'), findsOneWidget);

    // 導航到預算類型選擇
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 測試選項卡片點擊
    await tester.tap(find.byKey(Key('category_budget_card')));
    await tester.pumpAndSettle();

    // 檢查選項是否被選中
    final selectedCard = tester.widget<Card>(find.byKey(Key('category_budget_card')));
    expect(selectedCard.color, isNot(equals(Colors.white)));
  }

  /**
   * 56. 測試手勢操作
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試滑動、拖拽等手勢操作功能
   */
  @test
  void testGestureOperations() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.potentialAwakener),
      ),
    );

    // 導航到金額設定步驟
    await _navigateToAmountStep();

    // Act & Assert - 測試滑動調整金額
    final slider = find.byKey(Key('amount_slider'));
    expect(slider, findsOneWidget);

    // 拖拽滑桿
    await tester.drag(slider, const Offset(100, 0));
    await tester.pumpAndSettle();

    // 檢查金額是否更新
    final amountField = tester.widget<TextField>(find.byKey(Key('budget_amount_field')));
    expect(double.tryParse(amountField.controller?.text.replaceAll(',', '') ?? '0'), 
           greaterThan(0));

    // 測試長按顯示快捷選項
    await tester.longPress(find.byKey(Key('budget_amount_field')));
    await tester.pumpAndSettle();

    expect(find.text('快速金額'), findsOneWidget);
    expect(find.text('1,000'), findsOneWidget);
    expect(find.text('3,000'), findsOneWidget);
    expect(find.text('5,000'), findsOneWidget);
  }

  /**
   * 57. 測試多點觸控處理
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試多指操作的處理和防誤觸機制
   */
  @test
  void testMultiTouchHandling() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.preciseController),
      ),
    );

    // Act - 同時點擊多個按鈕
    final nextButton = find.byKey(Key('next_button'));
    final backButton = find.byKey(Key('back_button'));

    // 模擬同時觸控（實際上會被順序處理）
    await tester.tap(nextButton);
    await tester.tap(backButton);
    await tester.pumpAndSettle();

    // Assert - 檢查只有一個操作生效
    expect(find.text('選擇預算類型'), findsOneWidget); // 只有next生效

    // 測試防誤觸機制
    await tester.tap(nextButton);
    await tester.pump(Duration(milliseconds: 100)); // 快速連續點擊
    await tester.tap(nextButton);
    await tester.pumpAndSettle();

    // 應該只前進一步
    expect(find.text('設定預算金額'), findsOneWidget);
  }

  /**
   * 58. 測試無障礙觸控支援
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試無障礙設計的觸控操作支援
   */
  @test
  void testAccessibilityTouchSupport() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    // Act & Assert - 檢查語意標籤
    expect(find.bySemanticsLabel('預算名稱輸入框'), findsOneWidget);
    expect(find.bySemanticsLabel('下一步按鈕'), findsOneWidget);
    expect(find.bySemanticsLabel('上一步按鈕'), findsOneWidget);

    // 測試可訪問性操作
    await tester.tapBySemanticsLabel('預算名稱輸入框');
    await tester.pumpAndSettle();

    final nameField = tester.widget<TextField>(find.byKey(Key('budget_name_field')));
    expect(nameField.focusNode?.hasFocus, isTrue);

    // 測試鍵盤導航
    await tester.sendKeyEvent(LogicalKeyboardKey.tab);
    await tester.pumpAndSettle();

    // 檢查焦點是否移動到下一個可聚焦元素
    final nextButton = tester.widget<ElevatedButton>(find.byKey(Key('next_button')));
    expect(nextButton.focusNode?.hasFocus, isTrue);
  }

  Future<void> _navigateToAmountStep() async {
    await tester.enterText(find.byKey(Key('budget_name_field')), '測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();
  }
}
```

### 8.2 導航流程測試

#### 8.2.1 NavigationFlowTest
```dart
/**
 * 59. 對應 8.2：導航流程測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試建立預算頁面的導航流程和頁面跳轉
 */
class NavigationFlowTest {

  /**
   * 60. 測試成功建立後的導航
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試預算建立成功後導航到預算詳情頁面
   */
  @test
  void testSuccessfulCreationNavigation() async {
    // Arrange
    final mockNavigator = MockNavigatorObserver();
    final mockBudgetService = MockBudgetService();

    when(mockBudgetService.createBudget(any))
        .thenAnswer((_) async => BudgetResponse(
          success: true,
          budgetId: 'budget_001',
          budgetName: '成功測試預算',
          budgetAmount: 5000.0,
          currentSpent: 0.0,
          remainingAmount: 5000.0,
          usagePercentage: 0.0,
          budgetPeriod: 'monthly',
          startDate: DateTime.now(),
          endDate: DateTime.now().add(Duration(days: 30)),
          status: BudgetStatus.active,
        ));

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(userMode: UserMode.preciseController),
        ),
        navigatorObservers: [mockNavigator],
        routes: {
          '/budget-details': (context) => const BudgetDetailsPage(),
          '/budget-overview': (context) => const BudgetOverviewPage(),
        },
      ),
    );

    // Act - 完成整個建立流程
    await _completeCreationFlow();

    // 點擊建立按鈕
    await tester.tap(find.byKey(Key('create_budget_button')));
    await tester.pumpAndSettle();

    // Assert
    verify(mockNavigator.didPush(any, any));
    expect(find.byType(BudgetDetailsPage), findsOneWidget);
  }

  /**
   * 61. 測試取消建立的導航
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試取消預算建立時的導航行為
   */
  @test
  void testCancelCreationNavigation() async {
    // Arrange
    final mockNavigator = MockNavigatorObserver();

    await tester.pumpWidget(
      MaterialApp(
        home: const BudgetOverviewPage(),
        navigatorObservers: [mockNavigator],
        routes: {
          '/create-budget': (context) => CreateBudgetPage(
            userMode: UserMode.habitTracker,
          ),
        },
      ),
    );

    // 導航到建立預算頁面
    await tester.tap(find.text('建立預算'));
    await tester.pumpAndSettle();

    expect(find.byType(CreateBudgetPage), findsOneWidget);

    // Act - 點擊取消按鈕
    await tester.tap(find.byKey(Key('cancel_button')));
    await tester.pumpAndSettle();

    // 確認取消對話框
    expect(find.text('確定要取消建立預算嗎？'), findsOneWidget);
    await tester.tap(find.text('確定'));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(BudgetOverviewPage), findsOneWidget);
    expect(find.byType(CreateBudgetPage), findsNothing);
  }

  /**
   * 62. 測試深度連結導航
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試透過深度連結直接開啟特定範本的建立流程
   */
  @test
  void testDeepLinkNavigation() async {
    // Arrange
    const templateId = 'template_001';
    const ledgerId = 'ledger_001';

    final mockBudgetService = MockBudgetService();
    when(mockBudgetService.getBudgetTemplates(any))
        .thenAnswer((_) async => [
          BudgetTemplate(
            id: templateId,
            name: '深度連結範本',
            description: '透過深度連結開啟',
            budgetType: BudgetType.category,
            defaultAmount: 3000.0,
            categories: ['2003'],
            alertConfig: AlertConfig.defaultConfig(),
          ),
        ]);

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(
            templateId: templateId,
            ledgerId: ledgerId,
            userMode: UserMode.transformChallenger,
          ),
        ),
      ),
    );

    // Act & Assert
    await tester.pumpAndSettle();

    // 檢查範本是否已自動套用
    expect(find.text('深度連結範本'), findsOneWidget);
    expect(find.text('3,000'), findsOneWidget);

    // 檢查表單是否已預填
    final nameField = tester.widget<TextField>(find.byKey(Key('budget_name_field')));
    expect(nameField.controller?.text, equals('深度連結範本'));
  }

  /**
   * 63. 測試返回鍵處理
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試Android返回鍵和iOS滑動返回的處理
   */
  @test
  void testBackButtonHandling() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.potentialAwakener),
      ),
    );

    // 導航到第三步
    await _navigateToStep(3);

    // Act - 模擬Android返回鍵
    await tester.binding.defaultBinaryMessenger.handlePlatformMessage(
      'flutter/navigation',
      const StandardMethodCodec().encodeMethodCall(
        const MethodCall('routePopped', <String, dynamic>{
          'location': '/create-budget',
          'state': null,
        }),
      ),
      (data) {},
    );

    await tester.pumpAndSettle();

    // Assert - 應該返回到第二步而非完全退出
    expect(find.text('選擇預算類型'), findsOneWidget);

    // 在第一步時返回鍵應該顯示確認對話框
    await tester.tap(find.byKey(Key('back_button')));
    await tester.pumpAndSettle();

    await tester.binding.defaultBinaryMessenger.handlePlatformMessage(
      'flutter/navigation',
      const StandardMethodCodec().encodeMethodCall(
        const MethodCall('routePopped', <String, dynamic>{
          'location': '/create-budget',
          'state': null,
        }),
      ),
      (data) {},
    );

    await tester.pumpAndSettle();

    expect(find.text('確定要離開建立預算頁面嗎？'), findsOneWidget);
  }

  Future<void> _completeCreationFlow() async {
    // 步驟1: 基本資訊
    await tester.enterText(find.byKey(Key('budget_name_field')), '完整測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟2: 預算類型
    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟3: 金額設定
    await tester.enterText(find.byKey(Key('budget_amount_field')), '5000');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟4: 時間範圍
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟5: 分類選擇
    await tester.tap(find.byKey(Key('category_2003')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟6: 進階設定（跳過）
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 步驟7: 預覽確認
    expect(find.text('預算設定預覽'), findsOneWidget);
  }

  Future<void> _navigateToStep(int targetStep) async {
    for (int i = 1; i < targetStep; i++) {
      await tester.tap(find.byKey(Key('next_button')));
      await tester.pumpAndSettle();
    }
  }
}
```

---

## 9.0 效能與快取測試（Performance and Cache Tests）

### 9.1 載入效能測試

#### 9.1.1 LoadPerformanceTest
```dart
/**
 * 64. 對應 9.1：載入效能測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 20:15:00
 * @description 測試建立預算頁面的載入效能和響應速度
 */
class LoadPerformanceTest {

  /**
   * 65. 測試頁面初始載入效能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試建立預算頁面的初始載入時間和資源使用
   */
  @test
  void testInitialLoadPerformance() async {
    // Arrange
    final stopwatch = Stopwatch();
    final mockBudgetService = MockBudgetService();

    // 模擬API回應時間
    when(mockBudgetService.getBudgetTemplates(any))
        .thenAnswer((_) async {
          await Future.delayed(const Duration(milliseconds: 500));
          return _createMockTemplates();
        });

    when(mockBudgetService.getCategories(any))
        .thenAnswer((_) async {
          await Future.delayed(const Duration(milliseconds: 300));
          return _createMockCategories();
        });

    // Act
    stopwatch.start();

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: CreateBudgetPage(userMode: UserMode.preciseController),
        ),
      ),
    );

    await tester.pumpAndSettle();
    stopwatch.stop();

    // Assert
    expect(stopwatch.elapsedMilliseconds, lessThan(2000)); // 載入時間 < 2秒
    expect(find.byType(CircularProgressIndicator), findsNothing); // 載入完成
    expect(find.text('預算名稱'), findsOneWidget); // 頁面已完整顯示
  }

  /**
   * 66. 測試步驟切換效能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試精靈步驟間切換的響應時間
   */
  @test
  void testStepTransitionPerformance() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.habitTracker),
      ),
    );

    // 預填第一步驟資料
    await tester.enterText(find.byKey(Key('budget_name_field')), '效能測試預算');

    // Act & Assert - 測量每個步驟切換時間
    final transitionTimes = <int>[];

    for (int step = 1; step < 7; step++) {
      final stopwatch = Stopwatch()..start();

      await tester.tap(find.byKey(Key('next_button')));
      await tester.pumpAndSettle();

      stopwatch.stop();
      transitionTimes.add(stopwatch.elapsedMilliseconds);

      expect(stopwatch.elapsedMilliseconds, lessThan(500), 
             reason: 'Step $step transition should be < 500ms');
    }

    // 檢查平均切換時間
    final avgTransitionTime = transitionTimes.reduce((a, b) => a + b) / transitionTimes.length;
    expect(avgTransitionTime, lessThan(300), 
           reason: 'Average transition time should be < 300ms');
  }

  /**
   * 67. 測試大量範本載入效能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試載入大量預算範本時的效能表現
   */
  @test
  void testLargeTemplateLoadPerformance() async {
    // Arrange
    final largeTemplateList = List.generate(50, (index) => 
      BudgetTemplate(
        id: 'template_$index',
        name: '範本 $index',
        description: '測試範本描述 $index',
        budgetType: BudgetType.values[index % 3],
        defaultAmount: (index + 1) * 1000.0,
        categories: ['200${(index % 5) + 1}'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
    );

    final mockBudgetService = MockBudgetService();
    when(mockBudgetService.getBudgetTemplates(any))
        .thenAnswer((_) async => largeTemplateList);

    // Act
    final stopwatch = Stopwatch()..start();

    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: BudgetTemplateSelector(
            templates: largeTemplateList,
            userMode: UserMode.transformChallenger,
          ),
        ),
      ),
    );

    await tester.pumpAndSettle();
    stopwatch.stop();

    // Assert
    expect(stopwatch.elapsedMilliseconds, lessThan(3000)); // 大量範本載入 < 3秒
    expect(find.text('範本 0'), findsOneWidget); // 第一個範本可見
    expect(find.text('範本 49'), findsNothing); // 最後範本不在視窗中（虛擬滾動）

    // 測試滾動效能
    final scrollStopwatch = Stopwatch()..start();
    await tester.fling(find.byType(GridView), const Offset(0, -1000), 5000);
    await tester.pumpAndSettle();
    scrollStopwatch.stop();

    expect(scrollStopwatch.elapsedMilliseconds, lessThan(1000)); // 滾動響應 < 1秒
  }

  /**
   * 68. 測試記憶體使用效能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 20:15:00
   * @description 測試建立預算頁面的記憶體使用是否合理
   */
  @test
  void testMemoryUsagePerformance() async {
    // Arrange
    final initialMemory = _getCurrentMemoryUsage();

    await tester.pumpWidget(
      MaterialApp(
        home: CreateBudgetPage(userMode: UserMode.potentialAwakener),
      ),
    );

    await tester.pumpAndSettle();

    // Act - 完成整個建立流程
    await _completeFullCreationFlow();

    final loadedMemory = _getCurrentMemoryUsage();
    final memoryIncrease = loadedMemory - initialMemory;

    // Assert
    expect(memoryIncrease, lessThan(50 * 1024 * 1024)); // 記憶體增加 < 50MB

    // 測試記憶體是否會在適當時機被釋放
    await tester.pumpWidget(Container()); // 清除頁面
    await tester.pumpAndSettle();

    // 等待垃圾回收
    await Future.delayed(Duration(seconds: 1));

    final finalMemory = _getCurrentMemoryUsage();
    final memoryRetained = finalMemory - initialMemory;

    expect(memoryRetained, lessThan(10 * 1024 * 1024)); // 保留記憶體 < 10MB
  }

  List<BudgetTemplate> _createMockTemplates() {
    return [
      BudgetTemplate(
        id: 'template_001',
        name: '餐飲預算',
        description: '日常餐飲支出',
        budgetType: BudgetType.category,
        defaultAmount: 3000.0,
        categories: ['2003'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
      BudgetTemplate(
        id: 'template_002',
        name: '交通預算',
        description: '通勤和出行',
        budgetType: BudgetType.category,
        defaultAmount: 2000.0,
        categories: ['2004'],
        alertConfig: AlertConfig.defaultConfig(),
      ),
    ];
  }

  List<Category> _createMockCategories() {
    return [
      Category(id: '2003', name: '餐飲費', type: 'expense'),
      Category(id: '2004', name: '交通費', type: 'expense'),
      Category(id: '2005', name: '娛樂費', type: 'expense'),
    ];
  }

  int _getCurrentMemoryUsage() {
    // 實作取得當前記憶體使用量的邏輯
    return ProcessInfo.currentRss;
  }

  Future<void> _completeFullCreationFlow() async {
    // 完整的建立流程以測試記憶體使用
    await tester.enterText(find.byKey(Key('budget_name_field')), '記憶體測試預算');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    await tester.tap(find.byKey(Key('category_budget_option')));
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    await tester.enterText(find.byKey(Key('budget_amount_field')), '5000');
    await tester.tap(find.byKey(Key('next_button')));
    await tester.pumpAndSettle();

    // 繼續完成剩餘步驟...
    for (int i = 0; i < 3; i++) {
      await tester.tap(find.byKey(Key('next_button')));
      await tester.pumpAndSettle();
    }
  }
}
```

---

## 文件維護記錄

| 版本 | 日期 | 修改者 | 修改內容 |
|------|------|--------|----------|
| **v1.0.0** | **2025-01-26** | **LCAS SA Team** | **初版建立：完整P027建立預算頁面TDD規格，涵蓋68個測試函數，包含核心Widget架構、預算建立流程、表單驗證、四模式差異化、API整合、使用者互動、效能快取等完整測試覆蓋範圍** |

---

## 備註

- **版本1.0.0特色**: 完整的建立預算頁面TDD測試規格，確保預算建立功能的品質與效能
- **68個測試函數**: 涵蓋UI元件、業務邏輯、API整合、使用者體驗等全方位測試
- **四模式完整支援**: 針對精準控制者、紀錄習慣者、轉型挑戰者、潛在覺醒者的差異化測試
- **多步驟精靈測試**: 完整的建立流程測試，確保步驟導航和資料驗證正確性
- **API整合驗證**: 完整的BudgetService、ProjectLedgerService、CollaborationService整合測試
- **對應文件**: 配合P027_建立預算頁面_SRS.md規格和8904. BudgetService_預算管理.md API服務
- **相依模組**: 依賴CreateBudgetProvider、BudgetService、CacheManager等核心模組
- **測試策略**: 單元測試、整合測試、UI測試、效能測試的完整覆蓋
- **智慧功能測試**: 包含預算範本、智慧建議、即時驗證等進階功能測試
- **效能重點**: 載入時間、記憶體使用、響應速度、步驟切換效能等關鍵指標
