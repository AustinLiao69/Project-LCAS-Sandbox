# PRD_Flutter_Presentation_Layer

**文件編號**: 7001  
**版本**: v1.0.4  
**建立日期**: 2025-09-09  
**建立者**: LCAS PM Team  
**最後更新**: 2025-09-10  

---

## 目次
1. [模組概述](#10-模組概述module-overview)
2. [功能需求](#20-功能需求functional-requirements)
3. [架構設計](#30-架構設計architecture-design)
4. [模組群詳細規格](#40-模組群詳細規格module-groups-specification)
5. [UI/UX介面設計](#50-uiux介面設計uiux-interface-design)
6. [資料流設計](#60-資料流設計data-flow-design)

---

## 1.0 模組概述（Module Overview）

### 1.1 產品定位
展示層(Presentation Layer, PL)是 LCAS 2.0 系統的前端用戶介面層，負責提供跨平台（iOS/Android）的原生體驗。作為用戶與系統互動的主要介面，確保四模式差異化體驗的完整實現，並透過標準化的 RESTful API 與應用邏輯層(AP layer, APL)進行資料交換。

### 1.2 核心價值主張
- **四模式個人化體驗**：支援 Expert、Inertial、Cultivation、Guiding 四種使用者模式的差異化設計
- **跨平台一致性**：Flutter 框架確保 iOS 和 Android 平台的一致使用體驗
- **響應式設計**：支援手機、平板等多種螢幕尺寸的自適應佈局
- **離線優先架構**：支援離線記帳與數據同步機制

### 1.3 目標使用者
- **Expert模式使用者**：需要完整功能、深度分析、專業控制的進階用戶
- **Inertial模式使用者**：習慣固定流程、簡潔介面、一致體驗的穩定用戶
- **Cultivation模式使用者**：需要習慣養成、激勵機制、進度追蹤的成長用戶
- **Guiding模式使用者**：需要極簡介面、被動引導、最少決策的入門用戶

### 1.4 主要職責與技術定位

主要職責： PL 的主要負責領域為：UI渲染邏輯、互動邏輯、狀態管理邏輯、API整合邏輯。

技術定位： PL 採用 Flutter 跨平台框架，基於 Dart 語言開發，支援：
- Material Design 和 Cupertino 設計語言
- 狀態管理（Provider/Bloc）
- 本地資料存儲（SQLite/Hive）
- RESTful API 整合
- 多語言國際化（i18n）

---

## 2.0 功能需求（Functional Requirements）

基於6021 Screen list文件的40個畫面規格，Presentation Layer 提供完整的用戶介面功能：

### 2.1 進入階段功能群（Epic 1）
基於6021文件 S-101 至 S-108 畫面規格：

#### 2.1.1 APP 啟動與註冊功能
- **APP 啟動頁（S-102）**：品牌展示、版本資訊、載入進度
- **APP 註冊頁（S-103）**：Email 輸入、密碼設定、驗證流程
- **APP 登入頁（S-104）**：帳號密碼、Google 登入、忘記密碼
- **忘記密碼頁（S-105）**：Email 輸入、重設說明、返回登入

#### 2.1.2 模式評估與綁定功能
- **模式評估問卷頁（S-106）**：5 題評估問卷、模式說明、設定確認
- **跨平台綁定頁（S-107）**：LINE OA 介紹、QR Code、綁定確認

### 2.2 記帳功能群（Epic 2）
基於6021文件 S-201 至 S-211 畫面規格：

#### 2.2.1 核心記帳功能
- **APP 記帳主頁（S-202）**：快速記帳按鈕、最近記錄、統計摘要
- **APP 記帳表單頁（S-203）**：金額、科目、帳戶、帳本、備註、重複設定
- **科目選擇頁（S-204）**：收支切換、科目樹狀結構、快速搜尋
- **帳戶選擇頁（S-205）**：帳戶列表、餘額顯示、快速切換

#### 2.2.2 進階記帳功能
- **帳本選擇頁（S-206）**：個人/協作帳本、權限狀態、新增按鈕
- **圖片附加頁（S-207）**：拍照、相冊選擇、圖片預覽、壓縮設定
- **重複設定頁（S-208）**：頻率選擇、結束條件、預覽排程
- **記錄管理頁（S-209）**：記錄列表、篩選搜尋、編輯刪除

#### 2.2.3 記錄管理與統計
- **記錄編輯頁（S-210）**：完整記錄編輯、歷史記錄、刪除確認
- **統計圖表頁（S-211）**：圓餅圖、長條圖、折線圖、時間篩選

### 2.3 管理功能群（Epic 3-6）
基於6021文件 S-301 至 S-308 畫面規格：

#### 2.3.1 帳本管理功能
- **帳本管理主頁（S-301）**：帳本列表、新增按鈕、權限標示
- **建立帳本頁（S-302）**：帳本類型、名稱描述、權限設定
- **協作管理頁（S-303）**：協作者列表、權限管理、邀請功能

#### 2.3.2 帳戶與科目管理
- **帳戶管理主頁（S-304）**：帳戶列表、餘額統計、新增刪除
- **建立帳戶頁（S-305）**：帳戶類型、初始餘額、幣值圖標
- **科目管理主頁（S-306）**：科目樹狀結構、新增編輯、使用統計

#### 2.3.3 預算管理功能
- **預算管理主頁（S-307）**：預算列表、執行狀況、新增按鈕
- **建立預算頁（S-308）**：預算範圍、金額時間、監控設定

### 2.4 分析功能群（Epic 7-9）
基於6021文件 S-401 至 S-406 畫面規格：

#### 2.4.1 報表分析功能
- **報表分析主頁（S-401）**：報表類型、快速生成、模板管理
- **報表設定頁（S-402）**：時間範圍、資料篩選、圖表選擇
- **圖表展示頁（S-403）**：動態圖表、數據鑽取、匯出分享
- **報表下載頁（S-404）**：格式選擇、自訂範圍、分享設定

#### 2.4.2 AI 智慧分析
- **深度分析頁（S-405）**：趨勢分析、異常檢測、AI 建議
- **AI 助理頁（S-406）**：智慧分類、預算建議、異常提醒

### 2.5 系統功能群（Epic 10-15）
基於6021文件 S-501 至 S-507 畫面規格：

#### 2.5.1 激勵與備份功能
- **激勵系統頁（S-501）**：挑戰進度、成就徽章、獎勵記錄
- **資料備份頁（S-502）**：備份設定、恢復選項、同步狀態

#### 2.5.2 系統設定功能
- **安全設定頁（S-503）**：應用鎖、隱私模式、驗證設定
- **通知設定頁（S-504）**：提醒類型、時間設定、頻率管理
- **個人設定頁（S-505）**：個人資料、主題語言、偏好設定

#### 2.5.3 幫助與回報功能
- **幫助中心頁（S-506）**：操作教學、FAQ、客服聯繫
- **社群回報頁（S-507）**：錯誤回報、功能建議、系統狀態

---

## 3.0 架構設計（Architecture Design）

### 3.1 整體架構
Presentation layer 採用分層架構設計，確保清晰的職責分離與高度可維護性：

```
LCAS 2.0 Presentation layer Architecture
├── 展示層 (Presentation Layer)
│   ├── 頁面層 (Pages Layer)
│   │   ├── 進入階段頁面群 (Entry Pages Group)
│   │   ├── 記帳功能頁面群 (Bookkeeping Pages Group)
│   │   ├── 管理功能頁面群 (Management Pages Group)
│   │   ├── 分析功能頁面群 (Analytics Pages Group)
│   │   └── 系統功能頁面群 (System Pages Group)
│   ├── 組件層 (Components Layer)
│   │   ├── 四模式差異化組件 (Mode-specific Components)
│   │   ├── 共用UI組件 (Shared UI Components)
│   │   └── 業務邏輯組件 (Business Logic Components)
│   └── 主題層 (Theme Layer)
│       ├── Expert模式主題 (Expert Mode Theme)
│       ├── Inertial模式主題 (Inertial Mode Theme)
│       ├── Cultivation模式主題 (Cultivation Mode Theme)
│       └── Guiding模式主題 (Guiding Mode Theme)
├── 業務邏輯層 (Business Logic Layer)
│   ├── 狀態管理 (State Management)
│   │   ├── 認證狀態管理 (Auth State Management)
│   │   ├── 記帳狀態管理 (Bookkeeping State Management)
│   │   ├── 模式狀態管理 (Mode State Management)
│   │   └── 系統狀態管理 (System State Management)
│   └── 服務層 (Services Layer)
│       ├── API服務 (API Services)
│       ├── 本地儲存服務 (Local Storage Services)
│       ├── 通知服務 (Notification Services)
│       └── 同步服務 (Sync Services)
├── 資料層 (Data Layer)
│   ├── 遠端資料源 (Remote Data Source)
│   │   └── RESTful API Client
│   ├── 本地資料源 (Local Data Source)
│   │   ├── SQLite Database
│   │   └── SharedPreferences
│   └── 快取層 (Cache Layer)
│       ├── 記憶體快取 (Memory Cache)
│       └── 持久快取 (Persistent Cache)
└── 核心層 (Core Layer)
    ├── 配置管理 (Configuration Management)
    ├── 錯誤處理 (Error Handling)
    ├── 網路管理 (Network Management)
    └── 工具類 (Utilities)
```

### 3.2 四模式架構設計

#### 3.2.1 模式識別機制
```dart
// 模式識別與切換架構
enum UserMode {
  expert,     // 專家模式
  inertial,   // 慣性模式
  cultivation, // 養成模式
  guiding     // 引導模式
}

class ModeController {
  UserMode currentMode;
  void switchMode(UserMode newMode);
  Widget buildModeSpecificUI(UserMode mode);
}
```

#### 3.2.2 差異化組件架構
- **條件渲染組件**：根據用戶模式動態顯示不同UI元素
- **模式適配器**：自動調整功能複雜度與介面佈局
- **主題切換器**：四模式專屬的視覺風格與色彩配置

### 3.3 頁面路由架構

#### 3.3.1 路由結構設計
```dart
// 基於6021 Screen list的完整40個畫面路由架構

// Epic 1: 進入階段畫面群 (S-101 至 S-108)
const String ROUTE_LINE_WELCOME = '/line-welcome';          // S-101 LINE OA 歡迎頁
const String ROUTE_APP_START = '/start';                    // S-102 APP 啟動頁
const String ROUTE_REGISTER = '/register';                  // S-103 APP 註冊頁
const String ROUTE_LOGIN = '/login';                        // S-104 APP 登入頁
const String ROUTE_FORGOT_PASSWORD = '/forgot';             // S-105 忘記密碼頁
const String ROUTE_MODE_ASSESSMENT = '/assessment';         // S-106 模式評估問卷頁
const String ROUTE_PLATFORM_BINDING = '/binding';           // S-107 跨平台綁定頁
const String ROUTE_APP_PROMOTION = '/promotion';            // S-108 APP 下載推廣頁

// Epic 2: 記帳功能畫面群 (S-201 至 S-211)
const String ROUTE_LINE_BOOKKEEPING = '/line-bookkeeping';  // S-201 LINE OA 記帳對話
const String ROUTE_BOOKKEEPING_HOME = '/home';              // S-202 APP 記帳主頁
const String ROUTE_BOOKKEEPING_FORM = '/form';              // S-203 APP 記帳表單頁
const String ROUTE_CATEGORY_SELECTOR = '/category-select';   // S-204 科目選擇頁
const String ROUTE_ACCOUNT_SELECTOR = '/account-select';     // S-205 帳戶選擇頁
const String ROUTE_LEDGER_SELECTOR = '/ledger-select';       // S-206 帳本選擇頁
const String ROUTE_IMAGE_ATTACHMENT = '/attachment';         // S-207 圖片附加頁
const String ROUTE_RECURRING_SETTING = '/recurring';        // S-208 重複設定頁
const String ROUTE_RECORD_MANAGEMENT = '/records';          // S-209 記錄管理頁
const String ROUTE_RECORD_EDIT = '/record-edit';            // S-210 記錄編輯頁
const String ROUTE_STATISTICS_CHART = '/charts';            // S-211 統計圖表頁

// Epic 3-6: 管理功能畫面群 (S-301 至 S-308)
const String ROUTE_LEDGER_MANAGEMENT = '/ledger-management'; // S-301 帳本管理主頁
const String ROUTE_CREATE_LEDGER = '/create-ledger';        // S-302 建立帳本頁
const String ROUTE_COLLABORATION = '/collaboration';         // S-303 協作管理頁
const String ROUTE_ACCOUNT_MANAGEMENT = '/account-management'; // S-304 帳戶管理主頁
const String ROUTE_CREATE_ACCOUNT = '/create-account';       // S-305 建立帳戶頁
const String ROUTE_CATEGORY_MANAGEMENT = '/category-management'; // S-306 科目管理主頁
const String ROUTE_BUDGET_MANAGEMENT = '/budget-management'; // S-307 預算管理主頁
const String ROUTE_CREATE_BUDGET = '/create-budget';        // S-308 建立預算頁

// Epic 7-9: 分析功能畫面群 (S-401 至 S-406)
const String ROUTE_REPORT_ANALYTICS = '/report-analytics';   // S-401 報表分析主頁
const String ROUTE_REPORT_CONFIG = '/report-config';        // S-402 報表設定頁
const String ROUTE_CHART_DISPLAY = '/chart-display';        // S-403圖表展示頁
const String ROUTE_REPORT_DOWNLOAD = '/report-download';    // S-404 報表下載頁
const String ROUTE_DEEP_ANALYTICS = '/deep-analytics';      // S-405 深度分析頁
const String ROUTE_AI_ASSISTANT = '/ai-assistant';          // S-406 AI 助理頁

// Epic 10-15: 系統功能畫面群 (S-501 至 S-507)
const String ROUTE_GAMIFICATION = '/gamification';          // S-501 激勵系統頁
const String ROUTE_DATA_BACKUP = '/backup';                 // S-502 資料備份頁
const String ROUTE_SECURITY_SETTINGS = '/security';         // S-503 安全設定頁
const String ROUTE_NOTIFICATION_SETTINGS = '/notifications'; // S-504 通知設定頁
const String ROUTE_PROFILE_SETTINGS = '/profile';           // S-505 個人設定頁
const String ROUTE_HELP_CENTER = '/help';                   // S-506 幫助中心頁
const String ROUTE_FEEDBACK = '/feedback';                  // S-507 社群回報頁

// 路由群組分類
class AppRoutes {
  // 進入階段路由群
  static const List<String> entryRoutes = [
    ROUTE_LINE_WELCOME,
    ROUTE_APP_START,
    ROUTE_REGISTER,
    ROUTE_LOGIN,
    ROUTE_FORGOT_PASSWORD,
    ROUTE_MODE_ASSESSMENT,
    ROUTE_PLATFORM_BINDING,
    ROUTE_APP_PROMOTION,
  ];

  // 記帳功能路由群
  static const List<String> bookkeepingRoutes = [
    ROUTE_LINE_BOOKKEEPING,
    ROUTE_BOOKKEEPING_HOME,
    ROUTE_BOOKKEEPING_FORM,
    ROUTE_CATEGORY_SELECTOR,
    ROUTE_ACCOUNT_SELECTOR,
    ROUTE_LEDGER_SELECTOR,
    ROUTE_IMAGE_ATTACHMENT,
    ROUTE_RECURRING_SETTING,
    ROUTE_RECORD_MANAGEMENT,
    ROUTE_RECORD_EDIT,
    ROUTE_STATISTICS_CHART,
  ];

  // 管理功能路由群
  static const List<String> managementRoutes = [
    ROUTE_LEDGER_MANAGEMENT,
    ROUTE_CREATE_LEDGER,
    ROUTE_COLLABORATION,
    ROUTE_ACCOUNT_MANAGEMENT,
    ROUTE_CREATE_ACCOUNT,
    ROUTE_CATEGORY_MANAGEMENT,
    ROUTE_BUDGET_MANAGEMENT,
    ROUTE_CREATE_BUDGET,
  ];

  // 分析功能路由群
  static const List<String> analyticsRoutes = [
    ROUTE_REPORT_ANALYTICS,
    ROUTE_REPORT_CONFIG,
    ROUTE_CHART_DISPLAY,
    ROUTE_REPORT_DOWNLOAD,
    ROUTE_DEEP_ANALYTICS,
    ROUTE_AI_ASSISTANT,
  ];

  // 系統功能路由群
  static const List<String> systemRoutes = [
    ROUTE_GAMIFICATION,
    ROUTE_DATA_BACKUP,
    ROUTE_SECURITY_SETTINGS,
    ROUTE_NOTIFICATION_SETTINGS,
    ROUTE_PROFILE_SETTINGS,
    ROUTE_HELP_CENTER,
    ROUTE_FEEDBACK,
  ];

  // 所有路由列表（共40個）
  static const List<String> allRoutes = [
    ...entryRoutes,
    ...bookkeepingRoutes,
    ...managementRoutes,
    ...analyticsRoutes,
    ...systemRoutes,
  ];
}
```

#### 3.3.2 導航控制邏輯
- **模式基礎導航**：根據用戶模式調整導航流程
- **權限控制導航**：基於用戶權限的頁面存取控制
- **深層連結支援**：支援外部應用的深層連結導航

### 3.4 狀態管理架構

#### 3.4.1 Provider 模式架構
```dart
// 主要狀態提供者
class AuthProvider extends ChangeNotifier {
  // 認證狀態管理
}

class BookkeepingProvider extends ChangeNotifier {
  // 記帳狀態管理
}

class ModeProvider extends ChangeNotifier {
  // 四模式狀態管理
}
```

#### 3.4.2 本地狀態與全域狀態分離
- **全域狀態**：用戶認證、模式設定、系統配置
- **頁面狀態**：表單輸入、載入狀態、錯誤處理
- **組件狀態**：UI互動、動畫效果、臨時資料

#### 3.4.3 錯誤狀態管理機制
基於8088文件第6章錯誤處理規範，實現統一的錯誤狀態管理：

```dart
// 錯誤狀態管理器
class ErrorStateManager extends ChangeNotifier {
  Map<String, ApiError> _errors = {};
  
  // 處理API錯誤（基於8088文件6.2節錯誤碼分類）
  void handleApiError(String apiPath, dynamic error) {
    final apiError = ApiError.fromException(error);
    _errors[apiPath] = apiError;
    notifyListeners();
  }
  
  // 清除特定API的錯誤狀態
  void clearError(String apiPath) {
    _errors.remove(apiPath);
    notifyListeners();
  }
  
  // 檢查是否有錯誤
  bool hasError(String apiPath) => _errors.containsKey(apiPath);
  
  // 取得錯誤詳情
  ApiError? getError(String apiPath) => _errors[apiPath];
}

// API錯誤類別（遵循8088文件6.1節錯誤回應格式）
class ApiError {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final String requestId;
  final Map<String, dynamic>? details;
  
  ApiError({
    required this.code,
    required this.message,
    this.field,
    required this.timestamp,
    required this.requestId,
    this.details,
  });
  
  factory ApiError.fromException(dynamic error) {
    // 解析錯誤並轉換為標準格式
    return ApiError(
      code: error.response?.data['error']['code'] ?? 'UNKNOWN_ERROR',
      message: error.response?.data['error']['message'] ?? '未知錯誤',
      field: error.response?.data['error']['field'],
      timestamp: DateTime.now(),
      requestId: error.response?.data['error']['requestId'] ?? '',
      details: error.response?.data['error']['details'],
    );
  }
}
```

#### 3.4.4 離線狀態處理邏輯
```dart
// 離線狀態管理器
class OfflineStateManager extends ChangeNotifier {
  bool _isOnline = true;
  List<PendingOperation> _pendingOperations = [];
  
  bool get isOnline => _isOnline;
  List<PendingOperation> get pendingOperations => _pendingOperations;
  
  // 處理離線狀態
  void setOfflineMode(bool offline) {
    _isOnline = !offline;
    notifyListeners();
  }
  
  // 添加待同步操作
  void addPendingOperation(PendingOperation operation) {
    _pendingOperations.add(operation);
    notifyListeners();
  }
  
  // 同步待處理操作
  Future<void> syncPendingOperations() async {
    if (!_isOnline) return;
    
    final operations = List<PendingOperation>.from(_pendingOperations);
    _pendingOperations.clear();
    
    for (final operation in operations) {
      try {
        await operation.execute();
      } catch (e) {
        // 失敗的操作重新加入待同步列表
        _pendingOperations.add(operation);
      }
    }
    notifyListeners();
  }
}
```

#### 3.4.5 狀態持久化機制
```dart
// 狀態持久化管理器
class StatePersistenceManager {
  static const String _userModeKey = 'user_mode';
  static const String _authTokenKey = 'auth_token';
  static const String _offlineDataKey = 'offline_data';
  
  // 保存關鍵狀態到本地存儲
  static Future<void> saveState(String key, dynamic value) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(key, jsonEncode(value));
  }
  
  // 從本地存儲恢復狀態
  static Future<T?> restoreState<T>(String key) async {
    final prefs = await SharedPreferences.getInstance();
    final value = prefs.getString(key);
    if (value != null) {
      return jsonDecode(value) as T;
    }
    return null;
  }
  
  // 清除指定狀態
  static Future<void> clearState(String key) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(key);
  }
}

### 3.5 API消費規範

#### 3.5.1 API消費原則
- **嚴格遵循8020文件**：僅使用132個已定義的API端點
- **不自創任何API**：所有API呼叫必須對應8020文件第3章畫面功能對應
- **封裝HTTP邏輯**：提供型別安全的API客戶端封裝
- **專注UI職責**：處理使用者互動、頁面導航、狀態管理

#### 3.5.2 API客戶端服務命名
所有API客戶端服務均應使用 `_service.dart` 作為檔案後綴，例如 `auth_service.dart`、`transaction_service.dart`。

#### 3.5.3 安全性規範實現
基於8088文件第11章安全性規範，實現以下安全機制：

```dart
// API客戶端安全基類（遵循8088文件11.1-11.4節）
abstract class SecureApiService {
  final ApiClient apiClient;
  
  SecureApiService(this.apiClient);
  
  // 認證機制（8088文件11.1節）
  Map<String, String> _getSecureHeaders() {
    return {
      'Authorization': 'Bearer ${TokenManager.getToken()}',
      'X-User-Mode': ModeManager.getCurrentMode(),
      'X-Request-ID': generateUUID(),
      'Content-Type': 'application/json; charset=utf-8',
    };
  }
  
  // 請求前資料驗證（8088文件11.2節）
  bool validateRequestData(Map<String, dynamic> data) {
    // 實現輸入驗證邏輯
    for (final entry in data.entries) {
      if (!_isValidField(entry.key, entry.value)) {
        throw ValidationException('Invalid field: ${entry.key}');
      }
    }
    return true;
  }
  
  // 敏感資料處理（8088文件11.3節）
  Map<String, dynamic> sanitizeData(Map<String, dynamic> data) {
    final sanitized = Map<String, dynamic>.from(data);
    
    // 清理敏感欄位
    _sanitizeField(sanitized, 'password');
    _sanitizeField(sanitized, 'pin');
    _sanitizeField(sanitized, 'cardNumber');
    
    return sanitized;
  }
  
  // 欄位驗證輔助方法
  bool _isValidField(String key, dynamic value) {
    switch (key) {
      case 'amount':
        return value is num && value > 0 && value <= 999999.99;
      case 'email':
        return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value);
      case 'description':
        return value is String && value.length <= 255;
      default:
        return true;
    }
  }
  
  // 敏感資料清理
  void _sanitizeField(Map<String, dynamic> data, String field) {
    if (data.containsKey(field)) {
      final value = data[field]?.toString() ?? '';
      data[field] = _maskSensitiveData(value);
    }
  }
  
  // 敏感資料遮罩
  String _maskSensitiveData(String value) {
    if (value.length <= 4) return '****';
    return value.substring(0, 2) + '*' * (value.length - 4) + value.substring(value.length - 2);
  }
}

// Token管理器（安全儲存認證資訊）
class TokenManager {
  static const String _tokenKey = 'secure_auth_token';
  static const String _refreshTokenKey = 'secure_refresh_token';
  
  // 安全儲存Token
  static Future<void> saveToken(String token, String refreshToken) async {
    await FlutterSecureStorage().write(key: _tokenKey, value: token);
    await FlutterSecureStorage().write(key: _refreshTokenKey, value: refreshToken);
  }
  
  // 取得Token
  static Future<String?> getToken() async {
    return await FlutterSecureStorage().read(key: _tokenKey);
  }
  
  // 清除Token
  static Future<void> clearTokens() async {
    await FlutterSecureStorage().delete(key: _tokenKey);
    await FlutterSecureStorage().delete(key: _refreshTokenKey);
  }
  
  // 檢查Token有效性
  static Future<bool> isTokenValid() async {
    final token = await getToken();
    if (token == null) return false;
    
    try {
      final payload = JwtDecoder.decode(token);
      final expiry = DateTime.fromMillisecondsSinceEpoch(payload['exp'] * 1000);
      return DateTime.now().isBefore(expiry);
    } catch (e) {
      return false;
    }
  }
}

// 本地資料加密管理器
class LocalDataEncryption {
  static const String _encryptionKey = 'local_data_key';
  
  // 加密敏感本地資料
  static Future<String> encryptData(String data) async {
    final key = await _getOrCreateEncryptionKey();
    final encrypted = Encrypt(key).encrypt(data);
    return encrypted.base64;
  }
  
  // 解密敏感本地資料
  static Future<String> decryptData(String encryptedData) async {
    final key = await _getOrCreateEncryptionKey();
    final encrypted = Encrypted.fromBase64(encryptedData);
    return Encrypt(key).decrypt(encrypted);
  }
  
  // 取得或建立加密金鑰
  static Future<Key> _getOrCreateEncryptionKey() async {
    final storage = FlutterSecureStorage();
    String? keyString = await storage.read(key: _encryptionKey);
    
    if (keyString == null) {
      final key = Key.fromSecureRandom(32);
      await storage.write(key: _encryptionKey, value: key.base64);
      return key;
    }
    
    return Key.fromBase64(keyString);
  }
}
```

#### 3.5.4 網路安全與重試機制
```dart
// 網路狀態檢測與重試機制
class NetworkManager {
  static bool _isOnline = true;
  static int _retryCount = 0;
  static const int _maxRetries = 3;
  static StreamController<NetworkStatus> _networkStatusController = StreamController.broadcast();
  
  // 網路狀態事件流
  static Stream<NetworkStatus> get networkStatusStream => _networkStatusController.stream;
  
  // 檢測網路狀態
  static Future<bool> checkNetworkStatus() async {
    try {
      final result = await InternetConnectionChecker().hasConnection;
      final newStatus = result;
      
      // 狀態變化時發送事件
      if (_isOnline != newStatus) {
        _isOnline = newStatus;
        _networkStatusController.add(newStatus ? NetworkStatus.online : NetworkStatus.offline);
      }
      
      return result;
    } catch (e) {
      if (_isOnline) {
        _isOnline = false;
        _networkStatusController.add(NetworkStatus.offline);
      }
      return false;
    }
  }
  
  // 帶重試機制的API呼叫
  static Future<T> executeWithRetry<T>(Future<T> Function() apiCall) async {
    _retryCount = 0;
    
    while (_retryCount < _maxRetries) {
      try {
        if (!await checkNetworkStatus()) {
          throw NetworkException('No internet connection');
        }
        
        final result = await apiCall();
        _retryCount = 0; // 重置重試計數
        return result;
        
      } catch (e) {
        _retryCount++;
        
        if (_retryCount >= _maxRetries) {
          throw e;
        }
        
        // 智慧重試間隔：指數退避策略
        final retryDelay = _calculateRetryDelay(_retryCount);
        await Future.delayed(retryDelay);
      }
    }
    
    throw Exception('Max retries exceeded');
  }
  
  // 計算重試延遲時間（指數退避 + 隨機抖動）
  static Duration _calculateRetryDelay(int retryCount) {
    final baseDelay = math.pow(2, retryCount - 1).toInt(); // 指數退避：1, 2, 4 秒
    final jitter = math.Random().nextInt(1000); // 0-1000ms 隨機抖動
    return Duration(seconds: baseDelay, milliseconds: jitter);
  }
  
  // 批次API呼叫與失敗處理
  static Future<List<T?>> executeBatchWithRetry<T>(List<Future<T> Function()> apiCalls) async {
    final results = <T?>[];
    final failedCalls = <int>[];
    
    // 第一輪執行
    for (int i = 0; i < apiCalls.length; i++) {
      try {
        final result = await executeWithRetry(apiCalls[i]);
        results.add(result);
      } catch (e) {
        results.add(null);
        failedCalls.add(i);
      }
    }
    
    // 重試失敗的呼叫
    if (failedCalls.isNotEmpty && await checkNetworkStatus()) {
      for (final index in failedCalls) {
        try {
          final result = await executeWithRetry(apiCalls[index]);
          results[index] = result;
        } catch (e) {
          // 記錄持續失敗的API呼叫
          print('Persistent failure for API call at index $index: $e');
        }
      }
    }
    
    return results;
  }
  
  // 網路品質檢測
  static Future<NetworkQuality> assessNetworkQuality() async {
    if (!await checkNetworkStatus()) {
      return NetworkQuality.offline;
    }
    
    try {
      final stopwatch = Stopwatch()..start();
      await http.get(Uri.parse('https://api.lcas.app/health')).timeout(Duration(seconds: 5));
      stopwatch.stop();
      
      final latency = stopwatch.elapsedMilliseconds;
      
      if (latency < 100) return NetworkQuality.excellent;
      if (latency < 300) return NetworkQuality.good;
      if (latency < 1000) return NetworkQuality.fair;
      return NetworkQuality.poor;
      
    } catch (e) {
      return NetworkQuality.poor;
    }
  }
  
  // 根據網路品質調整重試策略
  static Future<T> executeWithAdaptiveRetry<T>(Future<T> Function() apiCall) async {
    final networkQuality = await assessNetworkQuality();
    
    // 根據網路品質調整最大重試次數
    int maxRetries;
    switch (networkQuality) {
      case NetworkQuality.excellent:
      case NetworkQuality.good:
        maxRetries = 3;
        break;
      case NetworkQuality.fair:
        maxRetries = 5;
        break;
      case NetworkQuality.poor:
        maxRetries = 7;
        break;
      case NetworkQuality.offline:
        throw NetworkException('Network is offline');
    }
    
    int retryCount = 0;
    while (retryCount < maxRetries) {
      try {
        return await apiCall();
      } catch (e) {
        retryCount++;
        if (retryCount >= maxRetries) throw e;
        
        // 根據網路品質調整重試間隔
        final delay = _calculateAdaptiveDelay(retryCount, networkQuality);
        await Future.delayed(delay);
      }
    }
    
    throw Exception('Max adaptive retries exceeded');
  }
  
  // 根據網路品質計算適應性延遲
  static Duration _calculateAdaptiveDelay(int retryCount, NetworkQuality quality) {
    int baseSeconds;
    switch (quality) {
      case NetworkQuality.excellent:
        baseSeconds = 1;
        break;
      case NetworkQuality.good:
        baseSeconds = 2;
        break;
      case NetworkQuality.fair:
        baseSeconds = 3;
        break;
      case NetworkQuality.poor:
        baseSeconds = 5;
        break;
      case NetworkQuality.offline:
        baseSeconds = 10;
        break;
    }
    
    return Duration(seconds: baseSeconds * retryCount);
  }
  
  // 取得當前網路狀態
  static bool get isOnline => _isOnline;
  
  // 清理資源
  static void dispose() {
    _networkStatusController.close();
  }
}

// 網路狀態枚舉
enum NetworkStatus {
  online,
  offline
}

// 網路品質枚舉
enum NetworkQuality {
  excellent,  // <100ms
  good,       // 100-300ms
  fair,       // 300-1000ms
  poor,       // >1000ms
  offline
}

// 網路異常類別
class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);
  
  @override
  String toString() => 'NetworkException: $message';
}

// 網路狀態監聽器組件
class NetworkStatusListener extends StatefulWidget {
  final Widget child;
  final Function(NetworkStatus)? onNetworkStatusChanged;
  
  const NetworkStatusListener({
    Key? key,
    required this.child,
    this.onNetworkStatusChanged,
  }) : super(key: key);
  
  @override
  _NetworkStatusListenerState createState() => _NetworkStatusListenerState();
}

class _NetworkStatusListenerState extends State<NetworkStatusListener> {
  StreamSubscription<NetworkStatus>? _subscription;
  
  @override
  void initState() {
    super.initState();
    _subscription = NetworkManager.networkStatusStream.listen((status) {
      if (widget.onNetworkStatusChanged != null) {
        widget.onNetworkStatusChanged!(status);
      }
      
      // 顯示網路狀態提示
      if (status == NetworkStatus.offline) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('網路連線中斷，正在嘗試重新連線...'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 3),
          ),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('網路連線已恢復'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    });
  }
  
  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
```

### 3.6 測試策略架構

#### 3.6.1 單元測試架構
```dart
// 基於6021 Screen list的40個畫面測試架構
class UnitTestArchitecture {
  // 服務層單元測試
  static void testApiServices() {
    group('API Services Unit Tests', () {
      // 基於8020的132個API端點測試
      test('AuthApiService.login should return valid response', () async {
        final service = AuthApiService();
        final result = await service.login(mockLoginRequest);
        expect(result.success, true);
        expect(result.data.token, isNotEmpty);
      });

      test('TransactionApiService.createTransaction should handle validation', () async {
        final service = TransactionApiService();
        final result = await service.createTransaction(invalidTransactionData);
        expect(result.success, false);
        expect(result.error.code, 'VALIDATION_ERROR');
      });
    });
  }

  // 狀態管理單元測試
  static void testStateManagement() {
    group('State Management Unit Tests', () {
      test('ModeProvider should switch modes correctly', () {
        final provider = ModeProvider();
        provider.setMode(UserMode.expert);
        expect(provider.currentMode, UserMode.expert);
      });

      test('ErrorStateManager should handle API errors', () {
        final error = DioError(response: Response(statusCode: 400));
        ErrorStateManager.handleApiError('/transactions', error);
        expect(ErrorStateManager.hasError('/transactions'), true);
      });
    });
  }
}
```

#### 3.6.2 Widget測試策略
```dart
// 基於四模式差異化的Widget測試
class WidgetTestStrategy {
  // 四模式Widget測試
  static void testModeSpecificWidgets() {
    group('Mode-Specific Widget Tests', () {
      testWidgets('TransactionFormScreen should adapt to Expert mode', (tester) async {
        await tester.pumpWidget(createTestApp(
          child: TransactionFormScreen(),
          userMode: UserMode.expert,
        ));

        // 驗證Expert模式特有的UI元素
        expect(find.byType(AdvancedOptionsWidget), findsOneWidget);
        expect(find.text('批次輸入'), findsOneWidget);
      });

      testWidgets('TransactionFormScreen should adapt to Guiding mode', (tester) async {
        await tester.pumpWidget(createTestApp(
          child: TransactionFormScreen(),
          userMode: UserMode.guiding,
        ));

        // 驗證Guiding模式的簡化UI
        expect(find.byType(MinimalFormWidget), findsOneWidget);
        expect(find.text('自動填入'), findsOneWidget);
      });
    });
  }

  // 導航測試
  static void testNavigation() {
    group('Navigation Widget Tests', () {
      testWidgets('Should navigate between page groups correctly', (tester) async {
        await tester.pumpWidget(createTestApp());

        // 測試從記帳主頁到管理功能的導航
        await tester.tap(find.text('帳本管理'));
        await tester.pumpAndSettle();

        expect(find.byType(LedgerManagementScreen), findsOneWidget);
      });
    });
  }
}
```

#### 3.6.3 整合測試規劃
```dart
// 基於8020 API與6021畫面的整合測試
class IntegrationTestPlan {
  // API整合測試
  static void testApiIntegration() {
    group('API Integration Tests', () {
      testWidgets('Complete transaction flow integration', (tester) async {
        // 模擬完整的記帳流程
        await tester.pumpWidget(createTestApp());

        // 1. 進入記帳表單頁面 (S-203)
        await tester.tap(find.byIcon(Icons.add));
        await tester.pumpAndSettle();

        // 2. 填寫記帳資訊
        await tester.enterText(find.byKey(Key('amount_input')), '1500');
        await tester.tap(find.text('食物'));
        await tester.pumpAndSettle();

        // 3. 提交記帳
        await tester.tap(find.text('儲存'));
        await tester.pumpAndSettle();

        // 4. 驗證API調用結果
        verify(mockTransactionApiService.createTransaction(any)).called(1);
        expect(find.text('記帳成功'), findsOneWidget);
      });
    });
  }

  // 跨頁面整合測試
  static void testCrossPageIntegration() {
    group('Cross-Page Integration Tests', () {
      testWidgets('Mode switch should persist across pages', (tester) async {
        await tester.pumpWidget(createTestApp());

        // 切換到Expert模式
        await switchToExpertMode(tester);

        // 導航到不同頁面驗證模式持續性
        await navigateToReportAnalytics(tester);
        expect(find.byType(ExpertReportUI), findsOneWidget);

        await navigateToLedgerManagement(tester);
        expect(find.byType(ExpertLedgerUI), findsOneWidget);
      });
    });
  }
}
```

#### 3.6.4 四模式測試覆蓋策略
```dart
// 針對四模式差異化的完整測試覆蓋
class FourModeTestCoverage {
  // 模式切換測試
  static void testModeSwitching() {
    group('Four Mode Test Coverage', () {
      for (final mode in UserMode.values) {
        group('${mode.toString()} Mode Tests', () {
          testWidgets('All 40 screens should render correctly in $mode', (tester) async {
            for (final route in AppRoutes.allRoutes) {
              await tester.pumpWidget(createTestApp(
                initialRoute: route,
                userMode: mode,
              ));

              // 驗證頁面正常渲染
              expect(find.byType(Scaffold), findsOneWidget);

              // 驗證模式特定的UI元素
              verifyModeSpecificElements(mode, route, tester);
            }
          });

          test('API responses should be filtered correctly for $mode', () async {
            final response = await getMockApiResponse('/transactions/dashboard');
            final filteredResponse = ModeResponseFilter.filter(response, mode);

            verifyModeSpecificData(filteredResponse, mode);
          });
        });
      }
    });
  }

  // 模式間數據一致性測試
  static void testCrossModeDataConsistency() {
    group('Cross-Mode Data Consistency Tests', () {
      test('Core data should remain consistent across modes', () async {
        final coreData = await CoreDataManager.getCoreData();

        for (final mode in UserMode.values) {
          final modeData = await ModeDataSharingHandler.getDataForMode(mode);

          // 核心數據應該在所有模式中保持一致
          expect(modeData['transactions'], equals(coreData['transactions']));
          expect(modeData['accounts'], equals(coreData['accounts']));
          expect(modeData['categories'], equals(coreData['categories']));
        }
      });
    });
  }
}
```

---

## 4.0 頁面群詳細規格（Page Groups Specification）

基於6021 Screen list的40個畫面，將Presentation Layer分為5大頁面群，每個頁面群對應特定的功能範圍與畫面群組：

### 4.1 進入階段頁面群（Entry Page Group）

#### 4.1.1 頁面群職責範圍
**對應畫面**：S-101至S-108（Epic 1: 進入階段畫面群）
**核心功能**：APP啟動、使用者認證、模式評估、跨平台整合

#### 4.1.2 子頁面架構
```dart
// 進入階段頁面群架構
entry_page_group/
├── app_startup/          // APP啟動頁面
│   ├── splash_screen.dart        // S-102 APP啟動頁
│   └── startup_service.dart      // 啟動服務
├── authentication/       // 認證頁面
│   ├── register_screen.dart      // S-103 APP註冊頁
│   ├── login_screen.dart         // S-104 APP登入頁
│   ├── forgot_password_screen.dart // S-105 忘記密碼頁
│   └── auth_service.dart         // 認證API客戶端服務（消費8001 API）
├── user_assessment/      // 模式評估頁面
│   ├── assessment_screen.dart    // S-106 模式評估問卷頁
│   └── assessment_service.dart   // 評估服務
└── platform_binding/     // 跨平台綁定頁面
    ├── line_binding_screen.dart  // S-107 跨平台綁定頁
    └── promotion_screen.dart     // S-108 APP下載推廣頁
```

**重要說明**：
- **auth_service.dart** 等服務檔案是**API消費者**，呼叫8001 AP Layer定義的132個API端點
- **不會定義新的API**，而是封裝對8001 API的呼叫邏輯
- **專注於UI狀態管理**、**頁面導航**、**使用者互動處理**

#### 4.1.3 四模式差異化實現
```dart
// 模式差異化認證介面
class AuthenticationWidget extends StatelessWidget {
  final UserMode userMode;

  @override
  Widget build(BuildContext context) {
    switch (userMode) {
      case UserMode.expert:
        return ExpertAuthUI(
          showAdvancedOptions: true,
          enableSecurityFeatures: true,
        );
      case UserMode.inertial:
        return InertialAuthUI(
          fixedLayout: true,
          consistentFlow: true,
        );
      case UserMode.cultivation:
        return CultivationAuthUI(
          showMotivationText: true,
          progressIndicator: true,
        );
      case UserMode.guiding:
        return GuidingAuthUI(
          minimalForm: true,
          autoFillSuggestions: true,
        );
    }
  }
}
```

### 4.2 記帳核心頁面群（Bookkeeping Core Page Group）

#### 4.2.1 頁面群職責範圍
**對應畫面**：S-201至S-211（Epic 2: 記帳功能畫面群）
**核心功能**：記帳交易UI、統計圖表展示、記錄管理頁面

#### 4.2.2 子頁面架構
```dart
// 記帳核心頁面群架構
bookkeeping_core_page_group/
├── transaction_entry/    // 交易記錄頁面
│   ├── bookkeeping_home_screen.dart     // S-202 APP記帳主頁
│   ├── transaction_form_screen.dart     // S-203 APP記帳表單頁
│   ├── quick_record_widget.dart         // 快速記帳組件
│   ├── transaction_controller.dart      // 記帳頁面控制器
│   └── transaction_service.dart         // 記帳API客戶端（消費8001 /transactions/* API）
├── selection_pages/      // 選擇器頁面
│   ├── category_selector_screen.dart    // S-204 科目選擇頁
│   ├── account_selector_screen.dart     // S-205 帳戶選擇頁
│   ├── ledger_selector_screen.dart      // S-206 帳本選擇頁
│   └── selection_service.dart           // 選擇相關API客戶端
├── advanced_features/    // 進階功能頁面
│   ├── attachment_screen.dart           // S-207 圖片附加頁
│   ├── recurring_setting_screen.dart    // S-208 重複設定頁
│   └── advanced_controller.dart         // 進階功能控制器
├── record_management/    // 記錄管理頁面
│   ├── record_list_screen.dart          // S-209 記錄管理頁
│   ├── record_edit_screen.dart          // S-210 記錄編輯頁
│   └── record_controller.dart           // 記錄管理控制器
└── statistics/          // 統計分析頁面
│   ├── chart_screen.dart                // S-211 統計圖表頁
│   ├── dashboard_widget.dart            // 儀表板組件
│   └── statistics_service.dart          // 統計API客戶端（消費8001 /transactions/statistics API）
```

#### 4.2.3 四模式記帳表單差異
```dart
// 記帳表單四模式適配
class TransactionFormScreen extends StatefulWidget {
  @override
  Widget build(BuildContext context) {
    final userMode = Provider.of<ModeProvider>(context).currentMode;

    return Scaffold(
      body: _buildFormByMode(userMode),
    );
  }

  Widget _buildFormByMode(UserMode mode) {
    switch (mode) {
      case UserMode.expert:
        return ExpertTransactionForm(
          showAllFields: true,
          enableBatchEntry: true,
          advancedValidation: true,
        );
      case UserMode.inertial:
        return InertialTransactionForm(
          stepByStepFlow: true,
          fixedFieldOrder: true,
          consistentLayout: true,
        );
      case UserMode.cultivation:
        return CultivationTransactionForm(
          showHints: true,
          progressTracking: true,
          motivationalMessages: true,
        );
      case UserMode.guiding:
        return GuidingTransactionForm(
          minimalFields: true,
          autoSuggestions: true,
          oneClickComplete: true,
        );
    }
  }
}
```

### 4.3 管理功能頁面群（Management Page Group）

#### 4.3.1 頁面群職責範圍
**對應畫面**：S-301至S-308（Epic 3-6: 管理功能畫面群）
**核心功能**：帳本管理頁面、帳戶管理頁面、科目管理頁面、預算管理頁面

#### 4.3.2 子頁面架構
```dart
// 管理功能頁面群架構
management_page_group/
├── ledger_management/    // 帳本管理頁面
│   ├── ledger_home_screen.dart          // S-301 帳本管理主頁
│   ├── create_ledger_screen.dart        // S-302 建立帳本頁
│   ├── collaboration_screen.dart        // S-303 協作管理頁
│   ├── ledger_controller.dart           // 帳本頁面控制器
│   └── ledger_service.dart              // 帳本API客戶端（消費8001 /ledgers/* API）
├── account_management/   // 帳戶管理頁面
│   ├── account_home_screen.dart         // S-304 帳戶管理主頁
│   ├── create_account_screen.dart       // S-305 建立帳戶頁
│   ├── account_controller.dart          // 帳戶頁面控制器
│   └── account_service.dart             // 帳戶API客戶端（消費8001 /accounts/* API）
├── category_management/  // 科目管理頁面
│   ├── category_home_screen.dart        // S-306 科目管理主頁
│   ├── category_tree_widget.dart        // 科目樹狀結構組件
│   ├── category_controller.dart         // 科目頁面控制器
│   └── category_service.dart            // 科目API客戶端（消費8001 /categories/* API）
└── budget_management/    // 預算管理頁面
│   ├── budget_home_screen.dart          // S-307 預算管理主頁
│   ├── create_budget_screen.dart        // S-308 建立預算頁
│   ├── budget_controller.dart           // 預算頁面控制器
│   └── budget_service.dart              // 預算API客戶端（消費8001 /budgets/* API）
```

#### 4.3.3 協作管理四模式差異
```dart
// 協作管理差異化UI
class CollaborationScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final userMode = context.watch<ModeProvider>().currentMode;

    return Scaffold(
      appBar: AppBar(title: Text('協作管理')),
      body: _buildCollaborationUI(userMode),
    );
  }

  Widget _buildCollaborationUI(UserMode mode) {
    switch (mode) {
      case UserMode.expert:
        return ExpertCollaborationUI(
          granularPermissions: true,
          advancedAuditLog: true,
          batchOperations: true,
        );
      case UserMode.inertial:
        return InertialCollaborationUI(
          simplePermissions: true,
          standardLayout: true,
        );
      case UserMode.cultivation:
        return CultivationCollaborationUI(
          guidedInvitation: true,
          teamworkTips: true,
        );
      case UserMode.guiding:
        return GuidingCollaborationUI(
          basicPermissions: true,
          oneClickInvite: true,
        );
    }
  }
}
```

### 4.4 分析智慧頁面群（Analytics Intelligence Page Group）

#### 4.4.1 頁面群職責範圍
**對應畫面**：S-401至S-406（Epic 7-9: 分析功能畫面群）
**核心功能**：報表分析頁面、深度分析頁面、AI助理頁面

#### 4.4.2 子頁面架構
```dart
// 分析智慧頁面群架構
analytics_intelligence_page_group/
├── report_analytics/     // 報表分析頁面
│   ├── report_home_screen.dart          // S-401 報表分析主頁
│   ├── report_config_screen.dart        // S-402 報表設定頁
│   ├── chart_display_screen.dart        // S-403圖表展示頁
│   ├── report_download_screen.dart      // S-404 報表下載頁
│   ├── report_controller.dart           // 報表頁面控制器
│   └── report_service.dart              // 報表API客戶端（消費8001 /reports/* API）
├── deep_analytics/       // 深度分析頁面
│   ├── insights_screen.dart             // S-405 深度分析頁
│   ├── trend_analysis_widget.dart       // 趨勢分析組件
│   ├── analytics_controller.dart        // 分析頁面控制器
│   └── analytics_service.dart           // 分析API客戶端（消費8001 /analytics/* API）
└── ai_assistant/         // AI助理頁面
│   ├── ai_assistant_screen.dart         // S-406 AI助理頁
│   ├── smart_categorization.dart        // 智慧分類組件
│   ├── budget_advisor.dart              // 預算建議組件
│   ├── ai_controller.dart               // AI頁面控制器
│   └── ai_service.dart                  // AI API客戶端（消費8001 /ai/* API）
```

#### 4.4.3 報表分析四模式適配
```dart
// 報表分析模式適配
class ReportHomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final userMode = context.watch<ModeProvider>().currentMode;

    return Scaffold(
      body: _buildReportInterface(userMode),
    );
  }

  Widget _buildReportInterface(UserMode mode) {
    switch (mode) {
      case UserMode.expert:
        return ExpertReportUI(
          customQueryBuilder: true,
          advancedFilters: true,
          exportFormats: ['PDF', 'Excel', 'CSV', 'JSON'],
        );
      case UserMode.inertial:
        return InertialReportUI(
          predefinedTemplates: true,
          standardCharts: true,
          exportFormats: ['PDF', 'Excel'],
        );
      case UserMode.cultivation:
        return CultivationReportUI(
          progressReports: true,
          goalTracking: true,
          motivationalInsights: true,
        );
      case UserMode.guiding:
        return GuidingReportUI(
          simpleCharts: true,
          autoGenerated: true,
          basicInsights: true,
        );
    }
  }
}
```

### 4.5 系統功能頁面群（System Function Page Group）

#### 4.5.1 頁面群職責範圍
**對應畫面**：S-501至S-507（Epic 10-15: 系統功能畫面群）
**核心功能**：激勵系統頁面、資料管理頁面、系統設定頁面、幫助支援頁面

#### 4.5.2 子頁面架構
```dart
// 系統功能頁面群架構
system_function_page_group/
├── gamification/         // 激勵系統頁面
│   ├── gamification_screen.dart         // S-501 激勵系統頁
│   ├── achievement_widget.dart          // 成就組件
│   ├── challenge_widget.dart            // 挑戰組件
│   ├── gamification_controller.dart     // 激勵頁面控制器
│   └── gamification_service.dart        // 激勵API客戶端（消費8001 /gamification/* API）
├── data_management/      // 資料管理頁面
│   ├── backup_screen.dart               // S-502 資料備份頁
│   ├── data_controller.dart             // 資料管理控制器
│   └── backup_service.dart              // 備份API客戶端（消費8001 /backup/* API）
├── system_settings/      // 系統設定頁面
│   ├── security_screen.dart             // S-503 安全設定頁
│   ├── notification_screen.dart         // S-504 通知設定頁
│   ├── profile_screen.dart              // S-505 個人設定頁
│   ├── settings_controller.dart         // 設定頁面控制器
│   ├── user_service.dart                // 用戶API客戶端（消費8001 /users/* API）
│   └── notification_service.dart        // 通知API客戶端（消費8001 /notifications/* API）
└── help_support/         // 幫助支援頁面
│   ├── help_center_screen.dart          // S-506 幫助中心頁
│   ├── feedback_screen.dart             // S-507 社群回報頁
│   ├── support_controller.dart          // 支援頁面控制器
│   └── system_service.dart              // 系統API客戶端（消費8001 /system/*, /help/* API）
```

#### 4.5.3 激勵系統四模式實現
```dart
// 激勵系統模式差異化
class GamificationScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final userMode = context.watch<ModeProvider>().currentMode;

    return Scaffold(
      appBar: AppBar(title: Text('激勵系統')),
      body: _buildGamificationUI(userMode),
    );
  }

  Widget _buildGamificationUI(UserMode mode) {
    switch (mode) {
      case UserMode.expert:
        return ExpertGamificationUI(
          detailedStats: true,
          customChallenges: true,
          advancedAnalytics: true,
        );
      case UserMode.inertial:
        return InertialGamificationUI(
          simpleAchievements: true,
          consistentRewards: true,
        );
      case UserMode.cultivation:
        return CultivationGamificationUI(
          habitTracking: true,
          progressVisualization: true,
          motivationalContent: true,
          socialFeatures: true,
        );
      case UserMode.guiding:
        return GuidingGamificationUI(
          basicAchievements: true,
          autoRewards: true,
          simpleProgress: true,
        );
    }
  }
}
```

### 4.6 頁面群協調機制

#### 4.6.1 API客戶端統一架構
**重要原則**：所有API客戶端**僅消費8020文件定義的132個API端點**，絕對不自創API

```dart
// 統一的API客戶端基類（嚴格遵循8020文件）
abstract class BaseApiService {
  final ApiClient apiClient;

  BaseApiService(this.apiClient);

  // 所有API呼叫必須對應8020文件第7章API總覽清單的132個端點
  // 展示層職責：UI狀態管理、頁面導航、使用者互動
}

// 認證API客戶端（消費8020文件第7.1節認證服務11個端點）
class AuthApiService extends BaseApiService {
  Future<AuthResponse> register(RegisterRequest request) async {
    return await apiClient.post('/auth/register', request);
  }

  Future<AuthResponse> login(LoginRequest request) async {
    return await apiClient.post('/auth/login', request);
  }
  // ... 其他9個認證端點
}

// 記帳API客戶端（消費8020文件第7.3節記帳交易20個端點）
class TransactionApiService extends BaseApiService {
  Future<List<Transaction>> getTransactions(TransactionQuery query) async {
    return await apiClient.get('/transactions', queryParams: query.toMap());
  }

  Future<Transaction> createTransaction(TransactionData data) async {
    return await apiClient.post('/transactions', data);
  }
  // ... 其他18個記帳端點
}
```

#### 4.6.2 頁面狀態管理架構
```dart
// 全域狀態管理架構
class AppStateManagement {
  // 核心狀態提供者（對應5大頁面群）
  static final providers = [
    ChangeNotifierProvider<ModeProvider>(create: (_) => ModeProvider()),
    ChangeNotifierProvider<AuthProvider>(create: (_) => AuthProvider()),
    ChangeNotifierProvider<BookkeepingProvider>(create: (_) => BookkeepingProvider()),
    ChangeNotifierProvider<ManagementProvider>(create: (_) => ManagementProvider()),
    ChangeNotifierProvider<AnalyticsProvider>(create: (_) => AnalyticsProvider()),
    ChangeNotifierProvider<SystemProvider>(create: (_) => SystemProvider()),
  ];
}
```

#### 4.6.3 四模式全域協調
```dart
// 四模式全域協調器
class ModeCoordinator {
  static Widget adaptWidget(Widget child, UserMode mode) {
    return ModeWrapper(
      mode: mode,
      child: child,
    );
  }

  static ThemeData getThemeByMode(UserMode mode) {
    switch (mode) {
      case UserMode.expert:
        return ExpertTheme.data;
      case UserMode.inertial:
        return InertialTheme.data;
      case UserMode.cultivation:
        return CultivationTheme.data;
      case UserMode.guiding:
        return GuidingTheme.data;
    }
  }
}
```

#### 4.6.4 模式切換觸發時機
```dart
// 模式切換觸發機制
class ModeSwitchTriggerManager {
  // 使用行為追蹤觸發模式建議
  static Future<ModeRecommendation?> analyzeUserBehavior(UserBehaviorData data) async {
    // Expert → Inertial 觸發條件
    if (data.errorRate > 0.15 && data.featureUsageRate < 0.3) {
      return ModeRecommendation(
        suggestedMode: UserMode.inertial,
        reason: "檢測到功能使用複雜度過高，建議切換至慣性模式以提升使用體驗",
        confidence: 0.85
      );
    }
    
    // Inertial → Expert 觸發條件
    if (data.consecutiveDays >= 30 && data.advancedFeatureRequests >= 5) {
      return ModeRecommendation(
        suggestedMode: UserMode.expert,
        reason: "使用熟練度已達專家水準，可嘗試專家模式獲得更多進階功能",
        confidence: 0.75
      );
    }
    
    // Cultivation → Inertial 觸發條件
    if (data.achievementCompletionRate >= 0.8 && data.habitFormationScore >= 85) {
      return ModeRecommendation(
        suggestedMode: UserMode.inertial,
        reason: "記帳習慣已養成，可切換至慣性模式享受穩定體驗",
        confidence: 0.9
      );
    }
    
    // Guiding → Cultivation 觸發條件
    if (data.consecutiveDays >= 7 && data.basicFeatureMastery >= 0.7) {
      return ModeRecommendation(
        suggestedMode: UserMode.cultivation,
        reason: "基本功能已掌握，建議切換至養成模式建立長期記帳習慣",
        confidence: 0.8
      );
    }
    
    return null; // 無需切換建議
  }
  
  // 主動模式優化建議
  static List<ModeOptimizationSuggestion> generateOptimizationSuggestions(UserMode currentMode, UserBehaviorData data) {
    List<ModeOptimizationSuggestion> suggestions = [];
    
    switch (currentMode) {
      case UserMode.expert:
        if (data.customizationUsage < 0.2) {
          suggestions.add(ModeOptimizationSuggestion(
            type: OptimizationType.feature_utilization,
            title: "善用個人化設定",
            description: "您可以自訂科目分類和報表格式，提升記帳效率",
            actionType: ActionType.show_tutorial
          ));
        }
        break;
        
      case UserMode.inertial:
        if (data.routineStabilityScore < 0.6) {
          suggestions.add(ModeOptimizationSuggestion(
            type: OptimizationType.habit_stability,
            title: "建立固定記帳時間",
            description: "設定每日固定時間記帳，有助於養成穩定習慣",
            actionType: ActionType.setup_reminder
          ));
        }
        break;
        
      case UserMode.cultivation:
        if (data.challengeParticipationRate < 0.3) {
          suggestions.add(ModeOptimizationSuggestion(
            type: OptimizationType.engagement_boost,
            title: "參與記帳挑戰",
            description: "加入社群挑戰活動，與其他用戶一起成長",
            actionType: ActionType.join_challenge
          ));
        }
        break;
        
      case UserMode.guiding:
        if (data.errorRate > 0.3) {
          suggestions.add(ModeOptimizationSuggestion(
            type: OptimizationType.guidance_enhancement,
            title: "啟用智慧提示",
            description: "開啟更多操作提示，減少輸入錯誤",
            actionType: ActionType.enable_smart_hints
          ));
        }
        break;
    }
    
    return suggestions;
  }
}

// 使用行為數據類別
class UserBehaviorData {
  final double errorRate;              // 錯誤率
  final double featureUsageRate;       // 功能使用率
  final int consecutiveDays;           // 連續使用天數
  final int advancedFeatureRequests;   // 進階功能請求次數
  final double achievementCompletionRate; // 成就完成率
  final int habitFormationScore;       // 習慣養成分數
  final double basicFeatureMastery;    // 基本功能掌握度
  final double customizationUsage;     // 個人化功能使用率
  final double routineStabilityScore;  // 例行公事穩定性分數
  final double challengeParticipationRate; // 挑戰參與率
  
  UserBehaviorData({
    required this.errorRate,
    required this.featureUsageRate,
    required this.consecutiveDays,
    required this.advancedFeatureRequests,
    required this.achievementCompletionRate,
    required this.habitFormationScore,
    required this.basicFeatureMastery,
    required this.customizationUsage,
    required this.routineStabilityScore,
    required this.challengeParticipationRate,
  });
}

// 模式建議類別
class ModeRecommendation {
  final UserMode suggestedMode;
  final String reason;
  final double confidence;
  
  ModeRecommendation({
    required this.suggestedMode,
    required this.reason,
    required this.confidence,
  });
}

// 模式優化建議類別
class ModeOptimizationSuggestion {
  final OptimizationType type;
  final String title;
  final String description;
  final ActionType actionType;
  
  ModeOptimizationSuggestion({
    required this.type,
    required this.title,
    required this.description,
    required this.actionType,
  });
}

enum OptimizationType {
  feature_utilization,    // 功能利用優化
  habit_stability,        // 習慣穩定性
  engagement_boost,       // 參與度提升
  guidance_enhancement    // 引導強化
}

enum ActionType {
  show_tutorial,         // 顯示教學
  setup_reminder,        // 設置提醒
  join_challenge,        // 加入挑戰
  enable_smart_hints     // 啟用智慧提示
}
```

#### 4.6.4 API呼叫規範
**展示層API呼叫原則**：
1. **嚴格遵循8020文件**：僅使用132個已定義的API端點
2. **不自創任何API**：所有API呼叫必須對應8020文件第3章畫面功能對應
3. **封裝HTTP邏輯**：提供型別安全的API客戶端封裝
4. **專注UI職責**：處理使用者互動、頁面導航、狀態管理