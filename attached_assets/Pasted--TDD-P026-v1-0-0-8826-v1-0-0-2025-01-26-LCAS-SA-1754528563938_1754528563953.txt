
# TDD_P026_預算總覽頁面_v1.0.0

**文件編號**: 8826  
**版本**: v1.0.0  
**建立日期**: 2025-01-26  
**建立者**: LCAS SA Team  
**最後更新**: 2025-01-26 19:32:00 UTC+8

---

## 目次

1. [模組概述](#10-模組概述module-overview)
2. [測試需求分析](#20-測試需求分析test-requirements-analysis)
3. [核心Widget架構](#30-核心widget架構core-widget-architecture)
4. [預算視覺化元件測試](#40-預算視覺化元件測試budget-visualization-component-tests)
5. [預算統計功能測試](#50-預算統計功能測試budget-statistics-function-tests)
6. [四模式差異化測試](#60-四模式差異化測試four-mode-differentiation-tests)
7. [API整合測試](#70-api整合測試api-integration-tests)
8. [使用者互動測試](#80-使用者互動測試user-interaction-tests)
9. [效能與快取測試](#90-效能與快取測試performance-and-cache-tests)

---

## 1.0 模組概述（Module Overview）

### 1.1 產品定位
P026預算總覽頁面TDD規格是LCAS 2.0 Flutter Presentation Layer的預算管理核心界面測試檔案，負責驗證預算視覺化、統計分析、智慧提醒等完整預算總覽功能的正確性與效能表現。

### 1.2 測試覆蓋範圍
- **完整預算展示**: 預算清單、進度指標、狀態視覺化測試
- **智慧分析功能**: 預算趨勢、超支警示、使用建議測試
- **四模式適配**: 精準控制者、紀錄習慣者、轉型挑戰者、潛在覺醒者界面測試
- **API整合驗證**: BudgetService、ReportService、ProjectLedgerService整合測試
- **互動體驗測試**: 觸控操作、導航流程、響應式設計測試

---

## 2.0 測試需求分析（Test Requirements Analysis）

### 2.1 功能性測試需求

#### 2.1.1 核心預算管理功能
- **預算清單顯示**: 所有預算項目的正確載入和顯示
- **進度計算準確性**: 預算使用率、剩餘額度的精確計算
- **狀態指示器**: 正常、警告、超支狀態的視覺化呈現
- **即時數據更新**: 預算資料變更時的即時界面更新

#### 2.1.2 預算視覺化需求
- **進度條顯示**: 準確的預算使用進度視覺化
- **圖表元件**: 餅圖、柱狀圖、趨勢線圖的正確渲染
- **顏色編碼**: 預算狀態對應的色彩方案準確性
- **動畫效果**: 平滑的數據變更動畫表現

#### 2.1.3 智慧分析功能
- **超支預警**: 預算即將或已經超支的警示機制
- **趨勢分析**: 歷史預算使用趨勢的分析展示
- **優化建議**: 基於使用模式的預算優化建議
- **比較分析**: 多期間預算表現的對比分析

### 2.2 非功能性測試需求

#### 2.2.1 效能需求
- **載入時間**: 頁面初始載入時間 ≤ 2秒
- **數據刷新**: 預算數據刷新時間 ≤ 1秒
- **記憶體使用**: 記憶體佔用 ≤ 100MB
- **CPU使用率**: 正常操作下CPU使用率 ≤ 30%

#### 2.2.2 使用者體驗需求
- **響應速度**: 觸控操作響應時間 ≤ 100ms
- **視覺一致性**: 與設計規範的視覺一致性 ≥ 95%
- **可用性評分**: SUS可用性量表評分 ≥ 80分
- **錯誤處理**: 優雅的錯誤處理和使用者提示

---

## 3.0 核心Widget架構（Core Widget Architecture）

### 3.1 主頁面Widget測試

#### 3.1.1 BudgetOverviewPage Widget
```dart
/**
 * 01. 對應 SRS P026：預算總覽頁面主Widget測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算總覽頁面的完整功能和四模式差異化界面
 */
class BudgetOverviewPageTest extends StatelessWidget {
  final ScrollController scrollController;
  final RefreshController refreshController;
  final BudgetOverviewProvider provider;
  final UserMode? userMode;

  const BudgetOverviewPageTest({
    Key? key,
    required this.scrollController,
    required this.refreshController,
    required this.provider,
    this.userMode,
  }) : super(key: key);

  /**
   * 02. 初始化預算總覽頁面並載入預算資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 載入使用者所有預算資料並初始化狀態
   */
  Future<void> _initializeBudgetOverview();

  @override
  Widget build(BuildContext context);

  @override
  bool get wantKeepAlive;

  @override
  void dispose();
}
```

### 3.2 佈局結構層Widget

#### 3.2.1 BudgetOverviewScaffold Widget
```dart
/**
 * 03. 對應 2.2：預算總覽頁面佈局結構Widget
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 提供預算總覽頁面的基礎佈局結構，支援四模式差異化界面
 */
class BudgetOverviewScaffold extends StatelessWidget {
  final ScrollController scrollController;
  final RefreshController refreshController;
  final BudgetOverviewProvider provider;
  final UserMode? userMode;

  const BudgetOverviewScaffold({
    Key? key,
    required this.scrollController,
    required this.refreshController,
    required this.provider,
    this.userMode,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<BudgetOverviewProvider>(
      builder: (context, provider, child) {
        return Scaffold(
          appBar: _buildAppBar(context, provider),
          body: _buildBody(context, provider),
          floatingActionButton: _buildFloatingActionButton(context, provider),
          bottomNavigationBar: _buildBottomNavigation(context),
        );
      },
    );
  }

  /**
   * 04. 建構預算總覽頁面應用程式列
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式建構差異化的應用程式列
   */
  PreferredSizeWidget _buildAppBar(BuildContext context, BudgetOverviewProvider provider);

  /**
   * 05. 建構預算總覽頁面主體內容
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 建構包含預算清單、統計資訊、視覺化圖表的主體內容
   */
  Widget _buildBody(BuildContext context, BudgetOverviewProvider provider);

  /**
   * 06. 建構浮動操作按鈕
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 提供快速建立預算的浮動按鈕
   */
  Widget? _buildFloatingActionButton(BuildContext context, BudgetOverviewProvider provider);
}
```

### 3.3 功能模組層Widget

#### 3.3.1 BudgetSummaryCard Widget
```dart
/**
 * 07. 對應 3.3：預算統計摘要卡片Widget
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 展示預算總體統計資訊和關鍵指標
 */
class BudgetSummaryCard extends StatelessWidget {
  final BudgetSummary summary;
  final UserMode userMode;
  final VoidCallback? onTap;

  const BudgetSummaryCard({
    Key? key,
    required this.summary,
    required this.userMode,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: _getCardElevation(),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(_getBorderRadius()),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(_getBorderRadius()),
        child: Padding(
          padding: _getCardPadding(),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(context),
              const SizedBox(height: 16),
              _buildStatistics(context),
              const SizedBox(height: 12),
              _buildProgressIndicators(context),
            ],
          ),
        ),
      ),
    );
  }

  /**
   * 08. 建構摘要卡片標題區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 顯示總預算統計標題和操作按鈕
   */
  Widget _buildHeader(BuildContext context);

  /**
   * 09. 建構統計數據展示區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 展示預算總額、已使用、剩餘等關鍵數據
   */
  Widget _buildStatistics(BuildContext context);

  /**
   * 10. 建構進度指示器區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 以進度條形式展示預算使用情況
   */
  Widget _buildProgressIndicators(BuildContext context);
}
```

#### 3.3.2 BudgetListView Widget
```dart
/**
 * 11. 對應 3.4：預算清單檢視Widget
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 展示所有預算項目的清單檢視
 */
class BudgetListView extends StatelessWidget {
  final List<BudgetProgress> budgets;
  final UserMode userMode;
  final Function(BudgetProgress)? onBudgetTap;
  final Function(BudgetProgress)? onBudgetEdit;
  final Function(BudgetProgress)? onBudgetDelete;

  const BudgetListView({
    Key? key,
    required this.budgets,
    required this.userMode,
    this.onBudgetTap,
    this.onBudgetEdit,
    this.onBudgetDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    if (budgets.isEmpty) {
      return _buildEmptyState(context);
    }

    return ListView.separated(
      itemCount: budgets.length,
      separatorBuilder: (context, index) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final budget = budgets[index];
        return _buildBudgetItem(context, budget, index);
      },
    );
  }

  /**
   * 12. 建構單一預算項目Widget
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 建構包含預算資訊、進度、操作按鈕的預算項目
   */
  Widget _buildBudgetItem(BuildContext context, BudgetProgress budget, int index);

  /**
   * 13. 建構預算資訊區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 顯示預算名稱、期間、狀態等基本資訊
   */
  Widget _buildBudgetInfo(BuildContext context, BudgetProgress budget);

  /**
   * 14. 建構預算進度區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 以進度條和數值顯示預算使用進度
   */
  Widget _buildBudgetProgress(BuildContext context, BudgetProgress budget);

  /**
   * 15. 建構空狀態Widget
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 當沒有預算資料時顯示的空狀態界面
   */
  Widget _buildEmptyState(BuildContext context);
}
```

---

## 4.0 預算視覺化元件測試（Budget Visualization Component Tests）

### 4.1 預算進度圖表測試

#### 4.1.1 BudgetProgressChart Widget測試
```dart
/**
 * 16. 對應 4.1：預算進度圓形圖表Widget測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算使用進度的圓形圖表展示功能
 */
class BudgetProgressChartTest extends StatefulWidget {
  final BudgetProgress budgetProgress;
  final double size;
  final UserMode userMode;

  const BudgetProgressChartTest({
    Key? key,
    required this.budgetProgress,
    this.size = 120.0,
    required this.userMode,
  }) : super(key: key);

  @override
  State<BudgetProgressChartTest> createState() => _BudgetProgressChartTestState();
}

class _BudgetProgressChartTestState extends State<BudgetProgressChartTest>
    with TickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _progressAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
  }

  /**
   * 17. 設定進度動畫控制器
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 初始化進度條動畫效果和控制器
   */
  void _setupAnimations();

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _progressAnimation,
      builder: (context, child) {
        return SizedBox(
          width: widget.size,
          height: widget.size,
          child: Stack(
            alignment: Alignment.center,
            children: [
              _buildProgressCircle(context),
              _buildCenterContent(context),
            ],
          ),
        );
      },
    );
  }

  /**
   * 18. 建構進度圓圈Widget
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 繪製顯示預算使用進度的圓形進度條
   */
  Widget _buildProgressCircle(BuildContext context);

  /**
   * 19. 建構中央內容Widget
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 在圓形進度條中央顯示百分比和金額資訊
   */
  Widget _buildCenterContent(BuildContext context);
}
```

### 4.2 預算趨勢圖表測試

#### 4.2.1 BudgetTrendChart Widget測試
```dart
/**
 * 20. 對應 4.2：預算趨勢線圖表Widget測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算使用趨勢的線圖表展示功能
 */
class BudgetTrendChartTest extends StatelessWidget {
  final List<DailySpending> dailyData;
  final double height;
  final UserMode userMode;

  const BudgetTrendChartTest({
    Key? key,
    required this.dailyData,
    this.height = 200.0,
    required this.userMode,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      height: height,
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildChartHeader(context),
          const SizedBox(height: 12),
          Expanded(
            child: _buildTrendChart(context),
          ),
          _buildChartLegend(context),
        ],
      ),
    );
  }

  /**
   * 21. 建構圖表標題區域
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 顯示趨勢圖表的標題和時間範圍
   */
  Widget _buildChartHeader(BuildContext context);

  /**
   * 22. 建構趨勢線圖表
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 繪製預算使用趨勢的線圖表
   */
  Widget _buildTrendChart(BuildContext context);

  /**
   * 23. 建構圖表圖例
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 顯示趨勢圖表的顏色圖例說明
   */
  Widget _buildChartLegend(BuildContext context);
}
```

---

## 5.0 預算統計功能測試（Budget Statistics Function Tests）

### 5.1 統計計算測試

#### 5.1.1 BudgetCalculator測試
```dart
/**
 * 24. 對應 5.1：預算統計計算器測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算相關統計數據的計算準確性
 */
class BudgetCalculatorTest {
  
  /**
   * 25. 計算預算使用百分比
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 計算預算的使用百分比，確保計算準確性
   */
  static double calculateUsagePercentage(double spent, double budget) {
    if (budget <= 0) return 0.0;
    return (spent / budget * 100).clamp(0.0, 999.9);
  }

  /**
   * 26. 計算剩餘預算金額
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 計算預算的剩餘金額
   */
  static double calculateRemainingAmount(double budget, double spent) {
    return (budget - spent).clamp(0.0, double.infinity);
  }

  /**
   * 27. 判斷預算狀態
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用情況判斷預算的當前狀態
   */
  static BudgetStatus determineBudgetStatus(double spent, double budget, DateTime endDate) {
    final now = DateTime.now();
    
    if (now.isAfter(endDate)) {
      return BudgetStatus.expired;
    }
    
    final usagePercentage = calculateUsagePercentage(spent, budget);
    
    if (usagePercentage >= 100) {
      return BudgetStatus.exceeded;
    } else if (usagePercentage >= 80) {
      return BudgetStatus.warning;
    } else {
      return BudgetStatus.normal;
    }
  }

  /**
   * 28. 計算日均支出
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 計算預算期間內的日均支出金額
   */
  static double calculateDailyAverage(double totalSpent, int daysPassed) {
    if (daysPassed <= 0) return 0.0;
    return totalSpent / daysPassed;
  }

  /**
   * 29. 預測預算結束時總支出
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 基於當前支出趨勢預測預算結束時的總支出
   */
  static double projectTotalSpending(
    double currentSpent,
    int daysPassed,
    int totalDays,
  ) {
    if (daysPassed <= 0 || totalDays <= 0) return currentSpent;
    final dailyAverage = calculateDailyAverage(currentSpent, daysPassed);
    final remainingDays = totalDays - daysPassed;
    return currentSpent + (dailyAverage * remainingDays);
  }
}
```

### 5.2 預算警示測試

#### 5.2.1 BudgetAlertManager測試
```dart
/**
 * 30. 對應 5.2：預算警示管理器測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算警示的觸發條件和通知機制
 */
class BudgetAlertManagerTest {

  /**
   * 31. 檢查是否需要觸發警示
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據預算狀態檢查是否需要觸發相應警示
   */
  static List<AlertInfo> checkAlerts(BudgetProgress budget) {
    final alerts = <AlertInfo>[];
    final usagePercentage = budget.usagePercentage;
    final projectedOverage = budget.projectedTotal - budget.budgetAmount;
    
    // 超支警示
    if (usagePercentage >= 100) {
      alerts.add(AlertInfo(
        type: AlertType.critical,
        title: '預算已超支',
        message: '${budget.budgetName} 已超出預算 ${(usagePercentage - 100).toStringAsFixed(1)}%',
        action: AlertAction.showBudgetDetails,
      ));
    }
    // 即將超支警示
    else if (usagePercentage >= 80) {
      alerts.add(AlertInfo(
        type: AlertType.warning,
        title: '預算即將超支',
        message: '${budget.budgetName} 已使用 ${usagePercentage.toStringAsFixed(1)}% 預算',
        action: AlertAction.showSpendingTrend,
      ));
    }
    
    // 預測超支警示
    if (projectedOverage > 0 && usagePercentage < 100) {
      alerts.add(AlertInfo(
        type: AlertType.info,
        title: '預測將超支',
        message: '根據目前支出趨勢，${budget.budgetName} 可能超支 ${projectedOverage.toStringAsFixed(0)} 元',
        action: AlertAction.showProjection,
      ));
    }
    
    return alerts;
  }

  /**
   * 32. 格式化警示訊息
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式格式化警示訊息內容
   */
  static String formatAlertMessage(AlertInfo alert, UserMode userMode) {
    switch (userMode) {
      case UserMode.preciseController:
        return '${alert.message}\n建議檢視詳細支出記錄並調整預算分配。';
      case UserMode.habitTracker:
        return '${alert.message}\n讓我們一起調整支出習慣吧！';
      case UserMode.transformChallenger:
        return '${alert.message}\n這是調整理財策略的好機會！';
      case UserMode.potentialAwakener:
        return '${alert.message}\n簡單調整一下支出就好。';
    }
  }
}
```

---

## 6.0 四模式差異化測試（Four Mode Differentiation Tests）

### 6.1 界面適配測試

#### 6.1.1 UserModeAdapter測試
```dart
/**
 * 33. 對應 6.1：使用者模式介面適配器測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試四種使用者模式的介面差異化適配
 */
class UserModeAdapterTest {

  /**
   * 34. 取得模式對應的主色調
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式返回對應的主色調配置
   */
  static Color getPrimaryColor(UserMode mode) {
    switch (mode) {
      case UserMode.preciseController:
        return const Color(0xFF1976D2); // 深藍色 - 專業穩重
      case UserMode.habitTracker:
        return const Color(0xFF4CAF50); // 綠色 - 健康活力
      case UserMode.transformChallenger:
        return const Color(0xFFFF9800); // 橙色 - 積極進取
      case UserMode.potentialAwakener:
        return const Color(0xFF9C27B0); // 紫色 - 溫和引導
    }
  }

  /**
   * 35. 取得模式對應的卡片樣式
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式返回對應的卡片設計樣式
   */
  static CardStyle getCardStyle(UserMode mode) {
    switch (mode) {
      case UserMode.preciseController:
        return CardStyle(
          elevation: 2.0,
          borderRadius: 8.0,
          padding: const EdgeInsets.all(16.0),
          showBorder: true,
        );
      case UserMode.habitTracker:
        return CardStyle(
          elevation: 4.0,
          borderRadius: 16.0,
          padding: const EdgeInsets.all(20.0),
          showBorder: false,
        );
      case UserMode.transformChallenger:
        return CardStyle(
          elevation: 6.0,
          borderRadius: 12.0,
          padding: const EdgeInsets.all(18.0),
          showBorder: false,
        );
      case UserMode.potentialAwakener:
        return CardStyle(
          elevation: 8.0,
          borderRadius: 20.0,
          padding: const EdgeInsets.all(24.0),
          showBorder: false,
        );
    }
  }

  /**
   * 36. 取得模式對應的字型樣式
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式返回對應的字型大小和樣式
   */
  static TextStyle getTitleStyle(UserMode mode, BuildContext context) {
    final baseStyle = Theme.of(context).textTheme.titleMedium!;
    
    switch (mode) {
      case UserMode.preciseController:
        return baseStyle.copyWith(
          fontSize: 16,
          fontWeight: FontWeight.w600,
        );
      case UserMode.habitTracker:
        return baseStyle.copyWith(
          fontSize: 18,
          fontWeight: FontWeight.w500,
        );
      case UserMode.transformChallenger:
        return baseStyle.copyWith(
          fontSize: 20,
          fontWeight: FontWeight.w700,
        );
      case UserMode.potentialAwakener:
        return baseStyle.copyWith(
          fontSize: 22,
          fontWeight: FontWeight.w400,
        );
    }
  }

  /**
   * 37. 取得模式對應的按鈕樣式
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式返回對應的按鈕設計樣式
   */
  static ButtonStyle getButtonStyle(UserMode mode) {
    switch (mode) {
      case UserMode.preciseController:
        return ElevatedButton.styleFrom(
          minimumSize: const Size(88, 36),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
          textStyle: const TextStyle(fontSize: 14),
        );
      case UserMode.habitTracker:
        return ElevatedButton.styleFrom(
          minimumSize: const Size(120, 44),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          textStyle: const TextStyle(fontSize: 16),
        );
      case UserMode.transformChallenger:
        return ElevatedButton.styleFrom(
          minimumSize: const Size(140, 48),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        );
      case UserMode.potentialAwakener:
        return ElevatedButton.styleFrom(
          minimumSize: const Size(160, 56),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(28)),
          textStyle: const TextStyle(fontSize: 20),
        );
    }
  }
}
```

### 6.2 功能差異化測試

#### 6.2.1 FeatureVisibilityManager測試
```dart
/**
 * 38. 對應 6.2：功能可見性管理器測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試不同使用者模式下功能的可見性和可用性
 */
class FeatureVisibilityManagerTest {

  /**
   * 39. 檢查進階功能是否可見
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式判斷進階預算功能是否顯示
   */
  static bool isAdvancedFeatureVisible(UserMode mode, String feature) {
    final advancedFeatures = {
      UserMode.preciseController: [
        'budget_analysis',
        'custom_alerts',
        'detailed_reports',
        'budget_categories',
        'spending_forecasts',
        'budget_templates',
        'bulk_operations',
      ],
      UserMode.habitTracker: [
        'budget_analysis',
        'habit_tracking',
        'visual_reports',
        'spending_insights',
        'goal_setting',
      ],
      UserMode.transformChallenger: [
        'goal_challenges',
        'progress_tracking',
        'motivational_alerts',
        'achievement_system',
        'spending_challenges',
      ],
      UserMode.potentialAwakener: [
        'simple_overview',
        'basic_alerts',
        'easy_creation',
      ],
    };

    return advancedFeatures[mode]?.contains(feature) ?? false;
  }

  /**
   * 40. 取得模式對應的功能配置
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 根據使用者模式返回功能配置清單
   */
  static FeatureConfig getFeatureConfig(UserMode mode) {
    switch (mode) {
      case UserMode.preciseController:
        return FeatureConfig(
          showDetailedStats: true,
          showAdvancedCharts: true,
          showCustomAlerts: true,
          showBulkOperations: true,
          maxBudgetsPerPage: 20,
          chartAnimationDuration: 300,
        );
      case UserMode.habitTracker:
        return FeatureConfig(
          showDetailedStats: true,
          showAdvancedCharts: true,
          showCustomAlerts: false,
          showBulkOperations: false,
          maxBudgetsPerPage: 15,
          chartAnimationDuration: 600,
        );
      case UserMode.transformChallenger:
        return FeatureConfig(
          showDetailedStats: true,
          showAdvancedCharts: false,
          showCustomAlerts: true,
          showBulkOperations: false,
          maxBudgetsPerPage: 12,
          chartAnimationDuration: 800,
        );
      case UserMode.potentialAwakener:
        return FeatureConfig(
          showDetailedStats: false,
          showAdvancedCharts: false,
          showCustomAlerts: false,
          showBulkOperations: false,
          maxBudgetsPerPage: 8,
          chartAnimationDuration: 1000,
        );
    }
  }
}
```

---

## 7.0 API整合測試（API Integration Tests）

### 7.1 BudgetService整合測試

#### 7.1.1 BudgetServiceIntegrationTest
```dart
/**
 * 41. 對應 7.1：預算服務API整合測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試與BudgetService的完整API整合功能
 */
class BudgetServiceIntegrationTest {
  late MockBudgetService mockBudgetService;
  late BudgetOverviewProvider provider;

  @setUp
  void setUp() {
    mockBudgetService = MockBudgetService();
    provider = BudgetOverviewProvider(budgetService: mockBudgetService);
  }

  /**
   * 42. 測試載入預算總覽資料
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試從API載入完整預算總覽資料的流程
   */
  @test
  void testLoadBudgetOverview() async {
    // Arrange
    final mockResponse = BudgetProgressResponse(
      success: true,
      budgets: [
        BudgetProgress(
          budgetId: 'budget_001',
          budgetName: '餐飲預算',
          budgetAmount: 5000.0,
          currentSpent: 3200.0,
          remainingAmount: 1800.0,
          usagePercentage: 64.0,
          daysRemaining: 15,
          dailyAverageSpent: 106.7,
          projectedTotal: 4800.0,
          trend: BudgetTrend.onTrack,
          dailyBreakdown: [],
        ),
      ],
      summary: BudgetSummary(
        totalBudgets: 1,
        activeBudgets: 1,
        exceededBudgets: 0,
        totalBudgetAmount: 5000.0,
        totalSpent: 3200.0,
        overallUsagePercentage: 64.0,
      ),
    );

    when(mockBudgetService.getBudgetProgress(any))
        .thenAnswer((_) async => mockResponse);

    // Act
    await provider.loadBudgetOverview();

    // Assert
    expect(provider.budgets.length, equals(1));
    expect(provider.summary.totalBudgets, equals(1));
    expect(provider.summary.overallUsagePercentage, equals(64.0));
    expect(provider.isLoading, isFalse);
    expect(provider.error, isNull);
    
    verify(mockBudgetService.getBudgetProgress(any)).called(1);
  }

  /**
   * 43. 測試預算資料刷新
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試下拉刷新預算資料的功能
   */
  @test
  void testRefreshBudgetData() async {
    // Arrange
    final refreshedResponse = BudgetProgressResponse(
      success: true,
      budgets: [
        BudgetProgress(
          budgetId: 'budget_001',
          budgetName: '餐飲預算',
          budgetAmount: 5000.0,
          currentSpent: 3500.0, // 更新後的支出
          remainingAmount: 1500.0,
          usagePercentage: 70.0,
          daysRemaining: 14,
          dailyAverageSpent: 116.7,
          projectedTotal: 4950.0,
          trend: BudgetTrend.onTrack,
          dailyBreakdown: [],
        ),
      ],
      summary: BudgetSummary(
        totalBudgets: 1,
        activeBudgets: 1,
        exceededBudgets: 0,
        totalBudgetAmount: 5000.0,
        totalSpent: 3500.0, // 更新後的總支出
        overallUsagePercentage: 70.0,
      ),
    );

    when(mockBudgetService.getBudgetProgress(any))
        .thenAnswer((_) async => refreshedResponse);

    // Act
    await provider.refreshBudgetData();

    // Assert
    expect(provider.budgets.first.currentSpent, equals(3500.0));
    expect(provider.budgets.first.usagePercentage, equals(70.0));
    expect(provider.summary.totalSpent, equals(3500.0));
    expect(provider.summary.overallUsagePercentage, equals(70.0));
    
    verify(mockBudgetService.getBudgetProgress(any)).called(1);
  }

  /**
   * 44. 測試API錯誤處理
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試API請求失敗時的錯誤處理機制
   */
  @test
  void testApiErrorHandling() async {
    // Arrange
    when(mockBudgetService.getBudgetProgress(any))
        .thenThrow(BudgetServiceException('網路連線失敗'));

    // Act
    await provider.loadBudgetOverview();

    // Assert
    expect(provider.error, isNotNull);
    expect(provider.error, contains('網路連線失敗'));
    expect(provider.budgets, isEmpty);
    expect(provider.isLoading, isFalse);
    
    verify(mockBudgetService.getBudgetProgress(any)).called(1);
  }
}
```

### 7.2 快取機制測試

#### 7.2.1 BudgetCacheTest
```dart
/**
 * 45. 對應 7.2：預算資料快取機制測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算資料的本地快取和同步機制
 */
class BudgetCacheTest {
  late MockCacheManager mockCacheManager;
  late BudgetOverviewProvider provider;

  @setUp
  void setUp() {
    mockCacheManager = MockCacheManager();
    provider = BudgetOverviewProvider(
      budgetService: MockBudgetService(),
      cacheManager: mockCacheManager,
    );
  }

  /**
   * 46. 測試快取資料載入
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試從本地快取載入預算資料
   */
  @test
  void testLoadFromCache() async {
    // Arrange
    final cachedData = {
      'budgets': [
        {
          'budgetId': 'budget_001',
          'budgetName': '交通預算',
          'budgetAmount': 2000.0,
          'currentSpent': 1200.0,
          'usagePercentage': 60.0,
        }
      ],
      'summary': {
        'totalBudgets': 1,
        'totalSpent': 1200.0,
        'overallUsagePercentage': 60.0,
      },
    };

    when(mockCacheManager.get('budget_overview'))
        .thenAnswer((_) async => cachedData);

    // Act
    await provider.loadFromCache();

    // Assert
    expect(provider.budgets.length, equals(1));
    expect(provider.budgets.first.budgetName, equals('交通預算'));
    expect(provider.budgets.first.currentSpent, equals(1200.0));
    expect(provider.summary.totalBudgets, equals(1));
    
    verify(mockCacheManager.get('budget_overview')).called(1);
  }

  /**
   * 47. 測試快取資料更新
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試將新的預算資料儲存到快取
   */
  @test
  void testUpdateCache() async {
    // Arrange
    final newBudgetData = BudgetProgressResponse(
      success: true,
      budgets: [
        BudgetProgress(
          budgetId: 'budget_002',
          budgetName: '購物預算',
          budgetAmount: 3000.0,
          currentSpent: 2100.0,
          remainingAmount: 900.0,
          usagePercentage: 70.0,
          daysRemaining: 12,
          dailyAverageSpent: 140.0,
          projectedTotal: 3360.0,
          trend: BudgetTrend.overSpending,
          dailyBreakdown: [],
        ),
      ],
      summary: BudgetSummary(
        totalBudgets: 1,
        activeBudgets: 1,
        exceededBudgets: 0,
        totalBudgetAmount: 3000.0,
        totalSpent: 2100.0,
        overallUsagePercentage: 70.0,
      ),
    );

    when(mockCacheManager.put(any, any, expiry: any))
        .thenAnswer((_) async => {});

    // Act
    await provider.updateCache(newBudgetData);

    // Assert
    verify(mockCacheManager.put(
      'budget_overview',
      any,
      expiry: Duration(minutes: 5),
    )).called(1);
  }

  /**
   * 48. 測試快取過期處理
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試快取資料過期時的處理邏輯
   */
  @test
  void testCacheExpiry() async {
    // Arrange
    when(mockCacheManager.get('budget_overview'))
        .thenAnswer((_) async => null); // 模擬快取過期

    when(mockCacheManager.isExpired('budget_overview'))
        .thenAnswer((_) async => true);

    // Act
    final cacheExists = await provider.checkCacheValidity();

    // Assert
    expect(cacheExists, isFalse);
    verify(mockCacheManager.get('budget_overview')).called(1);
    verify(mockCacheManager.isExpired('budget_overview')).called(1);
  }
}
```

---

## 8.0 使用者互動測試（User Interaction Tests）

### 8.1 觸控操作測試

#### 8.1.1 TouchInteractionTest
```dart
/**
 * 49. 對應 8.1：觸控互動操作測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算總覽頁面的各種觸控操作功能
 */
class TouchInteractionTest extends StatelessWidget {

  /**
   * 50. 測試預算項目點擊
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試點擊預算項目時的導航和回調功能
   */
  @test
  void testBudgetItemTap() async {
    // Arrange
    final mockNavigation = MockNavigationService();
    final testBudget = BudgetProgress(
      budgetId: 'budget_test',
      budgetName: '測試預算',
      budgetAmount: 1000.0,
      currentSpent: 600.0,
      remainingAmount: 400.0,
      usagePercentage: 60.0,
      daysRemaining: 20,
      dailyAverageSpent: 20.0,
      projectedTotal: 1200.0,
      trend: BudgetTrend.onTrack,
      dailyBreakdown: [],
    );

    await tester.pumpWidget(
      MaterialApp(
        home: BudgetListView(
          budgets: [testBudget],
          userMode: UserMode.habitTracker,
          onBudgetTap: (budget) {
            mockNavigation.navigateTo('/budget-details/${budget.budgetId}');
          },
        ),
      ),
    );

    // Act
    await tester.tap(find.text('測試預算'));
    await tester.pump();

    // Assert
    verify(mockNavigation.navigateTo('/budget-details/budget_test')).called(1);
  }

  /**
   * 51. 測試下拉刷新
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試下拉刷新預算資料的手勢操作
   */
  @test
  void testPullToRefresh() async {
    // Arrange
    final mockProvider = MockBudgetOverviewProvider();
    when(mockProvider.refreshBudgetData()).thenAnswer((_) async => {});

    await tester.pumpWidget(
      MaterialApp(
        home: ChangeNotifierProvider<BudgetOverviewProvider>.value(
          value: mockProvider,
          child: BudgetOverviewPage(userMode: UserMode.preciseController),
        ),
      ),
    );

    // Act
    await tester.fling(
      find.byType(RefreshIndicator),
      const Offset(0, 300),
      1000,
    );
    await tester.pump();
    await tester.pump(const Duration(seconds: 1));

    // Assert
    verify(mockProvider.refreshBudgetData()).called(1);
  }

  /**
   * 52. 測試長按操作
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試長按預算項目時的操作選單功能
   */
  @test
  void testLongPressActions() async {
    // Arrange
    final testBudget = BudgetProgress(
      budgetId: 'budget_longpress',
      budgetName: '長按測試預算',
      budgetAmount: 2000.0,
      currentSpent: 1500.0,
      remainingAmount: 500.0,
      usagePercentage: 75.0,
      daysRemaining: 10,
      dailyAverageSpent: 75.0,
      projectedTotal: 2250.0,
      trend: BudgetTrend.overSpending,
      dailyBreakdown: [],
    );

    await tester.pumpWidget(
      MaterialApp(
        home: BudgetListView(
          budgets: [testBudget],
          userMode: UserMode.transformChallenger,
          onBudgetEdit: (budget) => print('編輯: ${budget.budgetName}'),
          onBudgetDelete: (budget) => print('刪除: ${budget.budgetName}'),
        ),
      ),
    );

    // Act
    await tester.longPress(find.text('長按測試預算'));
    await tester.pump();

    // Assert
    expect(find.text('編輯'), findsOneWidget);
    expect(find.text('刪除'), findsOneWidget);
    expect(find.text('複製'), findsOneWidget);
  }

  /**
   * 53. 測試滑動手勢
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試滑動預算項目時的快速操作功能
   */
  @test
  void testSwipeGestures() async {
    // Arrange
    final testBudget = BudgetProgress(
      budgetId: 'budget_swipe',
      budgetName: '滑動測試預算',
      budgetAmount: 1500.0,
      currentSpent: 900.0,
      remainingAmount: 600.0,
      usagePercentage: 60.0,
      daysRemaining: 15,
      dailyAverageSpent: 30.0,
      projectedTotal: 1350.0,
      trend: BudgetTrend.onTrack,
      dailyBreakdown: [],
    );

    bool editCalled = false;
    bool deleteCalled = false;

    await tester.pumpWidget(
      MaterialApp(
        home: BudgetListView(
          budgets: [testBudget],
          userMode: UserMode.preciseController,
          onBudgetEdit: (budget) => editCalled = true,
          onBudgetDelete: (budget) => deleteCalled = true,
        ),
      ),
    );

    // Act - 向左滑動顯示編輯
    await tester.fling(
      find.text('滑動測試預算'),
      const Offset(-300, 0),
      1000,
    );
    await tester.pump();

    // Assert
    expect(find.text('編輯'), findsOneWidget);
    
    // Act - 點擊編輯按鈕
    await tester.tap(find.text('編輯'));
    await tester.pump();

    // Assert
    expect(editCalled, isTrue);
  }
}
```

### 8.2 導航流程測試

#### 8.2.1 NavigationFlowTest
```dart
/**
 * 54. 對應 8.2：導航流程測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算總覽頁面的導航流程和頁面跳轉
 */
class NavigationFlowTest {

  /**
   * 55. 測試導航到預算詳情
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試從預算總覽導航到預算詳情頁面
   */
  @test
  void testNavigateToBudgetDetails() async {
    // Arrange
    final mockNavigator = MockNavigatorObserver();
    
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetOverviewPage(userMode: UserMode.habitTracker),
        navigatorObservers: [mockNavigator],
        routes: {
          '/budget-details': (context) => const BudgetDetailsPage(),
        },
      ),
    );

    // Act
    await tester.tap(find.text('餐飲預算'));
    await tester.pumpAndSettle();

    // Assert
    verify(mockNavigator.didPush(any, any));
    expect(find.byType(BudgetDetailsPage), findsOneWidget);
  }

  /**
   * 56. 測試導航到建立預算
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試從預算總覽導航到建立預算頁面
   */
  @test
  void testNavigateToCreateBudget() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetOverviewPage(userMode: UserMode.transformChallenger),
        routes: {
          '/create-budget': (context) => const CreateBudgetPage(),
        },
      ),
    );

    // Act
    await tester.tap(find.byType(FloatingActionButton));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(CreateBudgetPage), findsOneWidget);
  }

  /**
   * 57. 測試返回上一頁
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試從預算總覽返回到首頁的導航
   */
  @test
  void testNavigateBack() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: const HomePage(),
        routes: {
          '/budget-overview': (context) => BudgetOverviewPage(
            userMode: UserMode.potentialAwakener,
          ),
        },
      ),
    );

    // 先導航到預算總覽
    await tester.tap(find.text('預算管理'));
    await tester.pumpAndSettle();
    
    expect(find.byType(BudgetOverviewPage), findsOneWidget);

    // Act - 點擊返回按鈕
    await tester.tap(find.byType(BackButton));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(HomePage), findsOneWidget);
    expect(find.byType(BudgetOverviewPage), findsNothing);
  }
}
```

---

## 9.0 效能與快取測試（Performance and Cache Tests）

### 9.1 載入效能測試

#### 9.1.1 LoadPerformanceTest
```dart
/**
 * 58. 對應 9.1：載入效能測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試預算總覽頁面的載入效能和響應速度
 */
class LoadPerformanceTest {

  /**
   * 59. 測試頁面初始載入時間
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試預算總覽頁面的初始載入時間是否符合要求
   */
  @test
  void testInitialLoadTime() async {
    // Arrange
    final stopwatch = Stopwatch();
    final mockBudgetService = MockBudgetService();
    
    // 模擬API回應時間
    when(mockBudgetService.getBudgetProgress(any))
        .thenAnswer((_) async {
          await Future.delayed(const Duration(milliseconds: 800));
          return _createMockBudgetResponse();
        });

    // Act
    stopwatch.start();
    
    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: BudgetOverviewPage(userMode: UserMode.preciseController),
        ),
      ),
    );

    await tester.pumpAndSettle();
    stopwatch.stop();

    // Assert
    expect(stopwatch.elapsedMilliseconds, lessThan(2000)); // 載入時間 < 2秒
    expect(find.byType(CircularProgressIndicator), findsNothing); // 載入完成
  }

  /**
   * 60. 測試大量預算項目載入效能
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試載入大量預算項目時的效能表現
   */
  @test
  void testLargeBudgetListPerformance() async {
    // Arrange
    final largeBudgetList = List.generate(100, (index) => 
      BudgetProgress(
        budgetId: 'budget_$index',
        budgetName: '預算項目 $index',
        budgetAmount: (index + 1) * 1000.0,
        currentSpent: (index + 1) * 600.0,
        remainingAmount: (index + 1) * 400.0,
        usagePercentage: 60.0,
        daysRemaining: 30 - (index % 30),
        dailyAverageSpent: (index + 1) * 20.0,
        projectedTotal: (index + 1) * 1200.0,
        trend: BudgetTrend.values[index % 3],
        dailyBreakdown: [],
      ),
    );

    final mockResponse = BudgetProgressResponse(
      success: true,
      budgets: largeBudgetList,
      summary: BudgetSummary(
        totalBudgets: 100,
        activeBudgets: 85,
        exceededBudgets: 15,
        totalBudgetAmount: 5050000.0,
        totalSpent: 3030000.0,
        overallUsagePercentage: 60.0,
      ),
    );

    final mockBudgetService = MockBudgetService();
    when(mockBudgetService.getBudgetProgress(any))
        .thenAnswer((_) async => mockResponse);

    // Act
    final stopwatch = Stopwatch()..start();
    
    await tester.pumpWidget(
      MaterialApp(
        home: Provider<BudgetService>.value(
          value: mockBudgetService,
          child: BudgetOverviewPage(userMode: UserMode.habitTracker),
        ),
      ),
    );

    await tester.pumpAndSettle();
    stopwatch.stop();

    // Assert
    expect(stopwatch.elapsedMilliseconds, lessThan(3000)); // 大量資料載入 < 3秒
    expect(find.text('預算項目 0'), findsOneWidget); // 第一個項目可見
    expect(find.text('預算項目 99'), findsNothing); // 最後項目不在視窗中（虛擬滾動）
  }

  /**
   * 61. 測試記憶體使用量
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試預算總覽頁面的記憶體使用是否合理
   */
  @test
  void testMemoryUsage() async {
    // Arrange
    final initialMemory = _getCurrentMemoryUsage();
    
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetOverviewPage(userMode: UserMode.transformChallenger),
      ),
    );

    await tester.pumpAndSettle();

    // Act
    final loadedMemory = _getCurrentMemoryUsage();
    final memoryIncrease = loadedMemory - initialMemory;

    // Assert
    expect(memoryIncrease, lessThan(100 * 1024 * 1024)); // 記憶體增加 < 100MB
  }

  int _getCurrentMemoryUsage() {
    // 實作取得當前記憶體使用量的邏輯
    return ProcessInfo.currentRss;
  }

  BudgetProgressResponse _createMockBudgetResponse() {
    return BudgetProgressResponse(
      success: true,
      budgets: [
        BudgetProgress(
          budgetId: 'budget_perf_test',
          budgetName: '效能測試預算',
          budgetAmount: 5000.0,
          currentSpent: 3000.0,
          remainingAmount: 2000.0,
          usagePercentage: 60.0,
          daysRemaining: 20,
          dailyAverageSpent: 100.0,
          projectedTotal: 5000.0,
          trend: BudgetTrend.onTrack,
          dailyBreakdown: [],
        ),
      ],
      summary: BudgetSummary(
        totalBudgets: 1,
        activeBudgets: 1,
        exceededBudgets: 0,
        totalBudgetAmount: 5000.0,
        totalSpent: 3000.0,
        overallUsagePercentage: 60.0,
      ),
    );
  }
}
```

### 9.2 響應速度測試

#### 9.2.1 ResponseTimeTest
```dart
/**
 * 62. 對應 9.2：響應速度測試
 * @version 2025-01-26-V1.0.0
 * @date 2025-01-26 19:32:00
 * @description 測試使用者操作的響應速度和動畫流暢性
 */
class ResponseTimeTest {

  /**
   * 63. 測試觸控響應時間
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試使用者觸控操作的響應時間
   */
  @test
  void testTouchResponseTime() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetOverviewPage(userMode: UserMode.habitTracker),
      ),
    );

    // Act & Assert
    final stopwatch = Stopwatch();
    
    stopwatch.start();
    await tester.tap(find.byType(FloatingActionButton));
    await tester.pump(const Duration(milliseconds: 16)); // 一個幀的時間
    stopwatch.stop();

    expect(stopwatch.elapsedMilliseconds, lessThan(100)); // 響應時間 < 100ms
  }

  /**
   * 64. 測試動畫流暢性
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試頁面動畫的流暢性（60fps）
   */
  @test
  void testAnimationSmoothness() async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: BudgetOverviewPage(userMode: UserMode.potentialAwakener),
      ),
    );

    // Act - 觸發進度動畫
    await tester.pump();
    
    // 測量動畫幀率
    final frameTimings = <Duration>[];
    var lastFrameTime = DateTime.now();
    
    for (int i = 0; i < 30; i++) { // 測量30幀
      await tester.pump(const Duration(milliseconds: 16)); // 60fps = 16.67ms per frame
      final currentTime = DateTime.now();
      frameTimings.add(currentTime.difference(lastFrameTime));
      lastFrameTime = currentTime;
    }

    // Assert
    final avgFrameTime = frameTimings
        .map((d) => d.inMicroseconds)
        .reduce((a, b) => a + b) / frameTimings.length;
    
    expect(avgFrameTime, lessThan(20000)); // 平均幀時間 < 20ms (50fps)
  }

  /**
   * 65. 測試滾動流暢性
   * @version 2025-01-26-V1.0.0
   * @date 2025-01-26 19:32:00
   * @description 測試預算清單滾動的流暢性
   */
  @test
  void testScrollSmoothness() async {
    // Arrange
    final largeBudgetList = List.generate(50, (index) => 
      BudgetProgress(
        budgetId: 'scroll_budget_$index',
        budgetName: '滾動測試預算 $index',
        budgetAmount: 1000.0,
        currentSpent: 600.0,
        remainingAmount: 400.0,
        usagePercentage: 60.0,
        daysRemaining: 30,
        dailyAverageSpent: 20.0,
        projectedTotal: 1200.0,
        trend: BudgetTrend.onTrack,
        dailyBreakdown: [],
      ),
    );

    await tester.pumpWidget(
      MaterialApp(
        home: BudgetListView(
          budgets: largeBudgetList,
          userMode: UserMode.preciseController,
        ),
      ),
    );

    // Act
    final scrollable = find.byType(Scrollable);
    await tester.fling(scrollable, const Offset(0, -3000), 5000);
    
    // 測量滾動動畫期間的幀率
    final frameTimings = <Duration>[];
    var lastFrameTime = DateTime.now();
    
    while (tester.hasRunningAnimations) {
      await tester.pump(const Duration(milliseconds: 16));
      final currentTime = DateTime.now();
      frameTimings.add(currentTime.difference(lastFrameTime));
      lastFrameTime = currentTime;
      
      if (frameTimings.length > 100) break; // 限制測量幀數
    }

    // Assert
    final droppedFrames = frameTimings.where((timing) => 
      timing.inMilliseconds > 32 // > 2 frames at 60fps
    ).length;
    
    expect(droppedFrames, lessThan(frameTimings.length * 0.1)); // 掉幀率 < 10%
  }
}
```

---

## 文件維護記錄

| 版本 | 日期 | 修改者 | 修改內容 |
|------|------|--------|----------|
| **v1.0.0** | **2025-01-26** | **LCAS SA Team** | **初版建立：完整P026預算總覽頁面TDD規格，涵蓋65個測試函數，包含核心Widget架構、預算視覺化元件、統計功能、四模式差異化、API整合、使用者互動、效能快取等完整測試覆蓋範圍** |

---

## 備註

- **版本1.0.0特色**: 完整的預算總覽頁面TDD測試規格，確保預算管理功能的品質與效能
- **65個測試函數**: 涵蓋UI元件、業務邏輯、API整合、使用者體驗等全方位測試
- **四模式完整支援**: 針對精準控制者、紀錄習慣者、轉型挑戰者、潛在覺醒者的差異化測試
- **效能測試重點**: 載入時間、記憶體使用、響應速度、動畫流暢性等關鍵效能指標
- **API整合驗證**: 完整的BudgetService、ReportService、ProjectLedgerService整合測試
- **對應文件**: 配合P026_預算總覽頁面_SRS.md規格和8904. BudgetService_預算管理.md API服務
- **相依模組**: 依賴BudgetOverviewProvider、BudgetService、CacheManager等核心模組
- **測試策略**: 單元測試、整合測試、UI測試、效能測試的完整覆蓋

