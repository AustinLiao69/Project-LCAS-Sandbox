
# 8200. LLD範本

**版本**: 1.0.0  
**建立日期**: 2025-08-27  
**最後更新**: 2025-08-27  
**建立者**: SA  
**適用對象**: 81號資料夾 API 規格實作

---

## 目次 (Table of Contents)

### 1. [概述](#1-概述)
### 2. [技術架構設計](#2-技術架構設計)
   - 2.1 [API Gateway 架構](#21-api-gateway-架構)
   - 2.2 [四模式處理機制](#22-四模式處理機制)
   - 2.3 [BL層整合設計](#23-bl層整合設計)
### 3. [實作規範](#3-實作規範)
   - 3.1 [路由設計模式](#31-路由設計模式)
   - 3.2 [中介軟體架構](#32-中介軟體架構)
   - 3.3 [錯誤處理機制](#33-錯誤處理機制)

---

## 1. 概述

### 1.1 文件目的

本 LLD 範本專門服務於 81 號資料夾的 API 規格實作，提供標準化的 Low-Level Design 指導，確保所有 APL 層實作都遵循統一的架構模式與技術標準。

### 1.2 設計原則

**基於 8020 文件的 132 個 API 端點**：
- 嚴格遵循 8088 API 設計規範
- 支援四模式差異化處理
- 確保 APL 到 BL 層的無縫整合
- 提供可擴展的架構設計

---

## 2. 技術架構設計

### 2.1 API Gateway 架構

#### 2.1.1 整體架構模式

```javascript
// API Gateway 核心架構
class APIGateway {
  constructor() {
    this.router = new Router();
    this.middlewares = new MiddlewareStack();
    this.blConnector = new BLConnector();
    this.modeProcessor = new UserModeProcessor();
  }

  // 統一請求處理流程
  async processRequest(req, res, next) {
    try {
      // 1. 認證與授權檢查
      await this.authenticateRequest(req);
      
      // 2. 四模式識別與設定
      const userMode = await this.modeProcessor.identifyMode(req);
      req.userMode = userMode;
      
      // 3. 請求驗證與轉換
      const validatedData = await this.validateRequest(req);
      
      // 4. BL層調用
      const result = await this.blConnector.execute(
        req.route.blModule,
        req.route.blFunction,
        validatedData
      );
      
      // 5. 四模式回應處理
      const response = await this.modeProcessor.formatResponse(
        result,
        userMode
      );
      
      // 6. 標準回應格式
      res.json(this.formatStandardResponse(response));
      
    } catch (error) {
      next(error);
    }
  }
}
```

#### 2.1.2 路由註冊機制

```javascript
// 統一路由註冊
class RouteRegistry {
  constructor() {
    this.routes = new Map();
  }

  // 基於 8020 文件的 API 端點註冊
  registerAPIEndpoints() {
    // 認證服務 (8101) - 11個端點
    this.register('POST', '/auth/register', {
      blModule: 'AM',
      blFunction: 'registerUser',
      validation: 'AuthRegistrationSchema',
      modes: ['Expert', 'Inertial', 'Cultivation', 'Guiding']
    });

    // 記帳交易服務 (8103) - 20個端點
    this.register('POST', '/transactions/quick', {
      blModule: 'LBK',
      blFunction: 'quickBookkeeping',
      validation: 'QuickTransactionSchema',
      modes: ['Expert', 'Inertial', 'Cultivation', 'Guiding']
    });

    // ... 其他 132 個端點註冊
  }

  register(method, path, config) {
    const key = `${method}:${path}`;
    this.routes.set(key, {
      ...config,
      createdAt: new Date(),
      version: '1.0.0'
    });
  }
}
```

### 2.2 四模式處理機制

#### 2.2.1 模式識別器

```javascript
class UserModeProcessor {
  constructor() {
    this.modeConfigs = this.loadModeConfigurations();
  }

  // 動態模式識別
  async identifyMode(req) {
    // 1. Header 檢查
    if (req.headers['x-user-mode']) {
      return req.headers['x-user-mode'];
    }

    // 2. 用戶設定查詢
    const userProfile = await this.getUserProfile(req.user.id);
    return userProfile.userMode || 'Inertial';
  }

  // 四模式回應格式化
  async formatResponse(data, userMode) {
    const modeConfig = this.modeConfigs[userMode];
    
    switch (userMode) {
      case 'Expert':
        return this.formatExpertResponse(data, modeConfig);
      
      case 'Inertial':
        return this.formatInertialResponse(data, modeConfig);
      
      case 'Cultivation':
        return this.formatCultivationResponse(data, modeConfig);
      
      case 'Guiding':
        return this.formatGuidingResponse(data, modeConfig);
      
      default:
        return this.formatInertialResponse(data, modeConfig);
    }
  }

  // Expert 模式：完整資訊
  formatExpertResponse(data, config) {
    return {
      ...data,
      metadata: {
        ...data.metadata,
        detailedAnalytics: data.analytics,
        advancedOptions: data.options,
        technicalDetails: data.technical
      }
    };
  }

  // Cultivation 模式：激勵資訊
  formatCultivationResponse(data, config) {
    return {
      ...data,
      achievements: data.gamification?.achievements,
      progress: data.gamification?.progress,
      motivationalContent: data.gamification?.motivation
    };
  }

  // Guiding 模式：極簡資訊
  formatGuidingResponse(data, config) {
    return {
      success: data.success,
      data: this.simplifyDataForGuiding(data.data),
      message: data.simpleMessage || data.message
    };
  }
}
```

### 2.3 BL層整合設計

#### 2.3.1 BL連接器架構

```javascript
class BLConnector {
  constructor() {
    this.moduleMap = this.loadBLModuleMapping();
    this.connectionPool = new ConnectionPool();
  }

  // 基於 8025 API-BL mapping 的模組映射
  loadBLModuleMapping() {
    return {
      // 認證相關 API -> AM 模組
      'auth': {
        module: 'AM',
        functions: {
          'register': 'registerUser',
          'login': 'authenticateUser',
          'refresh': 'refreshToken'
        }
      },

      // 記帳相關 API -> LBK + BK 模組
      'transactions': {
        module: 'LBK',
        functions: {
          'quick': 'quickBookkeeping',
          'create': 'createTransaction',
          'list': 'getTransactions'
        },
        fallback: 'BK' // 複雜邏輯回退到 BK 模組
      },

      // 帳本管理 API -> MLS 模組
      'ledgers': {
        module: 'MLS',
        functions: {
          'create': 'createLedger',
          'list': 'getLedgers',
          'collaborate': 'manageLedgerCollaboration'
        }
      }

      // ... 其他模組映射
    };
  }

  // 統一 BL 調用介面
  async execute(moduleName, functionName, data) {
    try {
      const module = this.getModule(moduleName);
      const result = await module[functionName](data);
      
      return {
        success: true,
        data: result,
        metadata: {
          module: moduleName,
          function: functionName,
          timestamp: new Date().toISOString(),
          requestId: data.requestId
        }
      };
      
    } catch (error) {
      throw new BLIntegrationError(
        `BL模組調用失敗: ${moduleName}.${functionName}`,
        error
      );
    }
  }

  getModule(moduleName) {
    switch (moduleName) {
      case 'AM': return require('../13. Replit_Module code_BL/2009. AM.js');
      case 'LBK': return require('../13. Replit_Module code_BL/2015. LBK.js');
      case 'BK': return require('../13. Replit_Module code_BL/2001. BK.js');
      case 'MLS': return require('../13. Replit_Module code_BL/2051. MLS.js');
      // ... 其他模組
      default:
        throw new Error(`未知的BL模組: ${moduleName}`);
    }
  }
}
```

---

## 3. 實作規範

### 3.1 路由設計模式

#### 3.1.1 RESTful 路由結構

```javascript
// 遵循 8088 規範的路由設計
class RESTfulRouter {
  constructor() {
    this.baseRouter = express.Router();
    this.setupMiddlewares();
    this.setupRoutes();
  }

  setupRoutes() {
    // 認證服務路由 (對應 8101 規格)
    this.baseRouter.post('/auth/register', 
      this.validateRequest('AuthRegister'),
      this.modeAwareHandler('AM', 'registerUser')
    );

    this.baseRouter.post('/auth/login',
      this.validateRequest('AuthLogin'),
      this.modeAwareHandler('AM', 'authenticateUser')
    );

    // 記帳服務路由 (對應 8103 規格)
    this.baseRouter.post('/transactions/quick',
      this.requireAuth(),
      this.validateRequest('QuickTransaction'),
      this.modeAwareHandler('LBK', 'quickBookkeeping')
    );

    this.baseRouter.get('/transactions',
      this.requireAuth(),
      this.validateQuery('TransactionQuery'),
      this.modeAwareHandler('BK', 'getTransactions')
    );
  }

  // 模式感知的處理器
  modeAwareHandler(blModule, blFunction) {
    return async (req, res, next) => {
      try {
        const processor = new RequestProcessor(req.userMode);
        const result = await processor.execute(blModule, blFunction, req.validatedData);
        
        res.json(this.formatResponse(result, req.userMode));
      } catch (error) {
        next(error);
      }
    };
  }
}
```

#### 3.1.2 動態路由生成

```javascript
// 基於 8020 文件自動生成路由
class RouteGenerator {
  static generateFromAPISpec(apiSpec) {
    const routes = [];
    
    // 解析 8101-8113 YAML 規格
    apiSpec.services.forEach(service => {
      service.endpoints.forEach(endpoint => {
        const route = {
          method: endpoint.method,
          path: endpoint.path,
          handler: this.createHandler(endpoint),
          middlewares: this.createMiddlewares(endpoint),
          validation: this.createValidation(endpoint)
        };
        
        routes.push(route);
      });
    });
    
    return routes;
  }

  static createHandler(endpoint) {
    return async (req, res, next) => {
      const context = {
        service: endpoint.service,
        operation: endpoint.operationId,
        userMode: req.userMode,
        blMapping: endpoint.blMapping
      };
      
      const handler = new EndpointHandler(context);
      await handler.process(req, res, next);
    };
  }
}
```

### 3.2 中介軟體架構

#### 3.2.1 中介軟體堆疊

```javascript
class MiddlewareStack {
  constructor() {
    this.middlewares = [];
    this.setupCoreMiddlewares();
  }

  setupCoreMiddlewares() {
    // 1. 請求日誌
    this.use(this.requestLogger());
    
    // 2. CORS 處理
    this.use(this.corsHandler());
    
    // 3. 安全標頭
    this.use(this.securityHeaders());
    
    // 4. 速率限制
    this.use(this.rateLimiter());
    
    // 5. 用戶模式識別
    this.use(this.userModeIdentifier());
    
    // 6. 請求驗證
    this.use(this.requestValidator());
  }

  // 用戶模式識別中介軟體
  userModeIdentifier() {
    return async (req, res, next) => {
      try {
        const modeProcessor = new UserModeProcessor();
        req.userMode = await modeProcessor.identifyMode(req);
        
        // 設定模式相關的請求上下文
        req.modeContext = {
          mode: req.userMode,
          capabilities: this.getModeCapabilities(req.userMode),
          responseFormat: this.getModeResponseFormat(req.userMode)
        };
        
        next();
      } catch (error) {
        next(error);
      }
    };
  }

  // 統一請求驗證
  requestValidator() {
    return (req, res, next) => {
      const validator = new RequestValidator(req.userMode);
      
      try {
        req.validatedData = validator.validate(req);
        next();
      } catch (validationError) {
        res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: validationError.message,
            field: validationError.field,
            timestamp: new Date().toISOString(),
            requestId: req.id
          }
        });
      }
    };
  }
}
```

### 3.3 錯誤處理機制

#### 3.3.1 統一錯誤處理器

```javascript
class UnifiedErrorHandler {
  static handle(error, req, res, next) {
    const errorResponse = this.createErrorResponse(error, req);
    
    // 記錄錯誤日誌
    this.logError(error, req);
    
    // 回應錯誤
    res.status(errorResponse.statusCode).json(errorResponse.body);
  }

  static createErrorResponse(error, req) {
    const baseResponse = {
      success: false,
      error: {
        timestamp: new Date().toISOString(),
        requestId: req.id,
        userMode: req.userMode
      }
    };

    // 遵循 8088 規範的錯誤格式
    if (error instanceof ValidationError) {
      return {
        statusCode: 400,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'VALIDATION_ERROR',
            message: error.message,
            field: error.field,
            details: error.details
          }
        }
      };
    }

    if (error instanceof AuthenticationError) {
      return {
        statusCode: 401,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'UNAUTHORIZED',
            message: '未授權存取'
          }
        }
      };
    }

    if (error instanceof BLIntegrationError) {
      return {
        statusCode: 500,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'INTERNAL_SERVER_ERROR',
            message: '業務邏輯處理錯誤'
          }
        }
      };
    }

    // 預設錯誤處理
    return {
      statusCode: 500,
      body: {
        ...baseResponse,
        error: {
          ...baseResponse.error,
          code: 'INTERNAL_SERVER_ERROR',
          message: '系統內部錯誤'
        }
      }
    };
  }
}
```