
# 8200. LLD範本

**版本**: 1.0.0  
**建立日期**: 2025-01-28  
**最後更新**: 2025-01-28  
**建立者**: SA  
**適用對象**: 81號資料夾 API 規格實作

---

## 目次 (Table of Contents)

### 1. [概述](#1-概述)
### 2. [技術架構設計](#2-技術架構設計)
   - 2.1 [API Gateway 架構](#21-api-gateway-架構)
   - 2.2 [四模式處理機制](#22-四模式處理機制)
   - 2.3 [BL層整合設計](#23-bl層整合設計)
### 3. [實作規範](#3-實作規範)
   - 3.1 [路由設計模式](#31-路由設計模式)
   - 3.2 [中介軟體架構](#32-中介軟體架構)
   - 3.3 [錯誤處理機制](#33-錯誤處理機制)
### 4. [技術決策記錄](#4-技術決策記錄)
### 5. [效能與安全性考量](#5-效能與安全性考量)
### 6. [測試與驗證策略](#6-測試與驗證策略)
### 7. [開發指導原則](#7-開發指導原則)

---

## 1. 概述

### 1.1 文件目的

本 LLD 範本專門服務於 81 號資料夾的 API 規格實作，提供標準化的 Low-Level Design 指導，確保所有 APL 層實作都遵循統一的架構模式與技術標準。

### 1.2 設計原則

**基於 8020 文件的 132 個 API 端點**：
- 嚴格遵循 8088 API 設計規範
- 支援四模式差異化處理
- 確保 APL 到 BL 層的無縫整合
- 提供可擴展的架構設計

### 1.3 範本使用方式

```
範本使用流程：
1. 選擇對應的 API 服務（8101-8113）
2. 套用本範本結構
3. 填入具體技術實作細節
4. 確保符合四模式處理需求
5. 驗證與 BL 層模組的整合
```

---

## 2. 技術架構設計

### 2.1 API Gateway 架構

#### 2.1.1 整體架構模式

```javascript
// API Gateway 核心架構
class APIGateway {
  constructor() {
    this.router = new Router();
    this.middlewares = new MiddlewareStack();
    this.blConnector = new BLConnector();
    this.modeProcessor = new UserModeProcessor();
  }

  // 統一請求處理流程
  async processRequest(req, res, next) {
    try {
      // 1. 認證與授權檢查
      await this.authenticateRequest(req);
      
      // 2. 四模式識別與設定
      const userMode = await this.modeProcessor.identifyMode(req);
      req.userMode = userMode;
      
      // 3. 請求驗證與轉換
      const validatedData = await this.validateRequest(req);
      
      // 4. BL層調用
      const result = await this.blConnector.execute(
        req.route.blModule,
        req.route.blFunction,
        validatedData
      );
      
      // 5. 四模式回應處理
      const response = await this.modeProcessor.formatResponse(
        result,
        userMode
      );
      
      // 6. 標準回應格式
      res.json(this.formatStandardResponse(response));
      
    } catch (error) {
      next(error);
    }
  }
}
```

#### 2.1.2 路由註冊機制

```javascript
// 統一路由註冊
class RouteRegistry {
  constructor() {
    this.routes = new Map();
  }

  // 基於 8020 文件的 API 端點註冊
  registerAPIEndpoints() {
    // 認證服務 (8101) - 11個端點
    this.register('POST', '/auth/register', {
      blModule: 'AM',
      blFunction: 'registerUser',
      validation: 'AuthRegistrationSchema',
      modes: ['Expert', 'Inertial', 'Cultivation', 'Guiding']
    });

    // 記帳交易服務 (8103) - 20個端點
    this.register('POST', '/transactions/quick', {
      blModule: 'LBK',
      blFunction: 'quickBookkeeping',
      validation: 'QuickTransactionSchema',
      modes: ['Expert', 'Inertial', 'Cultivation', 'Guiding']
    });

    // ... 其他 132 個端點註冊
  }

  register(method, path, config) {
    const key = `${method}:${path}`;
    this.routes.set(key, {
      ...config,
      createdAt: new Date(),
      version: '1.0.0'
    });
  }
}
```

### 2.2 四模式處理機制

#### 2.2.1 模式識別器

```javascript
class UserModeProcessor {
  constructor() {
    this.modeConfigs = this.loadModeConfigurations();
  }

  // 動態模式識別
  async identifyMode(req) {
    // 1. Header 檢查
    if (req.headers['x-user-mode']) {
      return req.headers['x-user-mode'];
    }

    // 2. 用戶設定查詢
    const userProfile = await this.getUserProfile(req.user.id);
    return userProfile.userMode || 'Inertial';
  }

  // 四模式回應格式化
  async formatResponse(data, userMode) {
    const modeConfig = this.modeConfigs[userMode];
    
    switch (userMode) {
      case 'Expert':
        return this.formatExpertResponse(data, modeConfig);
      
      case 'Inertial':
        return this.formatInertialResponse(data, modeConfig);
      
      case 'Cultivation':
        return this.formatCultivationResponse(data, modeConfig);
      
      case 'Guiding':
        return this.formatGuidingResponse(data, modeConfig);
      
      default:
        return this.formatInertialResponse(data, modeConfig);
    }
  }

  // Expert 模式：完整資訊
  formatExpertResponse(data, config) {
    return {
      ...data,
      metadata: {
        ...data.metadata,
        detailedAnalytics: data.analytics,
        advancedOptions: data.options,
        technicalDetails: data.technical
      }
    };
  }

  // Cultivation 模式：激勵資訊
  formatCultivationResponse(data, config) {
    return {
      ...data,
      achievements: data.gamification?.achievements,
      progress: data.gamification?.progress,
      motivationalContent: data.gamification?.motivation
    };
  }

  // Guiding 模式：極簡資訊
  formatGuidingResponse(data, config) {
    return {
      success: data.success,
      data: this.simplifyDataForGuiding(data.data),
      message: data.simpleMessage || data.message
    };
  }
}
```

### 2.3 BL層整合設計

#### 2.3.1 BL連接器架構

```javascript
class BLConnector {
  constructor() {
    this.moduleMap = this.loadBLModuleMapping();
    this.connectionPool = new ConnectionPool();
  }

  // 基於 8025 API-BL mapping 的模組映射
  loadBLModuleMapping() {
    return {
      // 認證相關 API -> AM 模組
      'auth': {
        module: 'AM',
        functions: {
          'register': 'registerUser',
          'login': 'authenticateUser',
          'refresh': 'refreshToken'
        }
      },

      // 記帳相關 API -> LBK + BK 模組
      'transactions': {
        module: 'LBK',
        functions: {
          'quick': 'quickBookkeeping',
          'create': 'createTransaction',
          'list': 'getTransactions'
        },
        fallback: 'BK' // 複雜邏輯回退到 BK 模組
      },

      // 帳本管理 API -> MLS 模組
      'ledgers': {
        module: 'MLS',
        functions: {
          'create': 'createLedger',
          'list': 'getLedgers',
          'collaborate': 'manageLedgerCollaboration'
        }
      }

      // ... 其他模組映射
    };
  }

  // 統一 BL 調用介面
  async execute(moduleName, functionName, data) {
    try {
      const module = this.getModule(moduleName);
      const result = await module[functionName](data);
      
      return {
        success: true,
        data: result,
        metadata: {
          module: moduleName,
          function: functionName,
          timestamp: new Date().toISOString(),
          requestId: data.requestId
        }
      };
      
    } catch (error) {
      throw new BLIntegrationError(
        `BL模組調用失敗: ${moduleName}.${functionName}`,
        error
      );
    }
  }

  getModule(moduleName) {
    switch (moduleName) {
      case 'AM': return require('../13. Replit_Module code_BL/2009. AM.js');
      case 'LBK': return require('../13. Replit_Module code_BL/2015. LBK.js');
      case 'BK': return require('../13. Replit_Module code_BL/2001. BK.js');
      case 'MLS': return require('../13. Replit_Module code_BL/2051. MLS.js');
      // ... 其他模組
      default:
        throw new Error(`未知的BL模組: ${moduleName}`);
    }
  }
}
```

---

## 3. 實作規範

### 3.1 路由設計模式

#### 3.1.1 RESTful 路由結構

```javascript
// 遵循 8088 規範的路由設計
class RESTfulRouter {
  constructor() {
    this.baseRouter = express.Router();
    this.setupMiddlewares();
    this.setupRoutes();
  }

  setupRoutes() {
    // 認證服務路由 (對應 8101 規格)
    this.baseRouter.post('/auth/register', 
      this.validateRequest('AuthRegister'),
      this.modeAwareHandler('AM', 'registerUser')
    );

    this.baseRouter.post('/auth/login',
      this.validateRequest('AuthLogin'),
      this.modeAwareHandler('AM', 'authenticateUser')
    );

    // 記帳服務路由 (對應 8103 規格)
    this.baseRouter.post('/transactions/quick',
      this.requireAuth(),
      this.validateRequest('QuickTransaction'),
      this.modeAwareHandler('LBK', 'quickBookkeeping')
    );

    this.baseRouter.get('/transactions',
      this.requireAuth(),
      this.validateQuery('TransactionQuery'),
      this.modeAwareHandler('BK', 'getTransactions')
    );
  }

  // 模式感知的處理器
  modeAwareHandler(blModule, blFunction) {
    return async (req, res, next) => {
      try {
        const processor = new RequestProcessor(req.userMode);
        const result = await processor.execute(blModule, blFunction, req.validatedData);
        
        res.json(this.formatResponse(result, req.userMode));
      } catch (error) {
        next(error);
      }
    };
  }
}
```

#### 3.1.2 動態路由生成

```javascript
// 基於 8020 文件自動生成路由
class RouteGenerator {
  static generateFromAPISpec(apiSpec) {
    const routes = [];
    
    // 解析 8101-8113 YAML 規格
    apiSpec.services.forEach(service => {
      service.endpoints.forEach(endpoint => {
        const route = {
          method: endpoint.method,
          path: endpoint.path,
          handler: this.createHandler(endpoint),
          middlewares: this.createMiddlewares(endpoint),
          validation: this.createValidation(endpoint)
        };
        
        routes.push(route);
      });
    });
    
    return routes;
  }

  static createHandler(endpoint) {
    return async (req, res, next) => {
      const context = {
        service: endpoint.service,
        operation: endpoint.operationId,
        userMode: req.userMode,
        blMapping: endpoint.blMapping
      };
      
      const handler = new EndpointHandler(context);
      await handler.process(req, res, next);
    };
  }
}
```

### 3.2 中介軟體架構

#### 3.2.1 中介軟體堆疊

```javascript
class MiddlewareStack {
  constructor() {
    this.middlewares = [];
    this.setupCoreMiddlewares();
  }

  setupCoreMiddlewares() {
    // 1. 請求日誌
    this.use(this.requestLogger());
    
    // 2. CORS 處理
    this.use(this.corsHandler());
    
    // 3. 安全標頭
    this.use(this.securityHeaders());
    
    // 4. 速率限制
    this.use(this.rateLimiter());
    
    // 5. 用戶模式識別
    this.use(this.userModeIdentifier());
    
    // 6. 請求驗證
    this.use(this.requestValidator());
  }

  // 用戶模式識別中介軟體
  userModeIdentifier() {
    return async (req, res, next) => {
      try {
        const modeProcessor = new UserModeProcessor();
        req.userMode = await modeProcessor.identifyMode(req);
        
        // 設定模式相關的請求上下文
        req.modeContext = {
          mode: req.userMode,
          capabilities: this.getModeCapabilities(req.userMode),
          responseFormat: this.getModeResponseFormat(req.userMode)
        };
        
        next();
      } catch (error) {
        next(error);
      }
    };
  }

  // 統一請求驗證
  requestValidator() {
    return (req, res, next) => {
      const validator = new RequestValidator(req.userMode);
      
      try {
        req.validatedData = validator.validate(req);
        next();
      } catch (validationError) {
        res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: validationError.message,
            field: validationError.field,
            timestamp: new Date().toISOString(),
            requestId: req.id
          }
        });
      }
    };
  }
}
```

### 3.3 錯誤處理機制

#### 3.3.1 統一錯誤處理器

```javascript
class UnifiedErrorHandler {
  static handle(error, req, res, next) {
    const errorResponse = this.createErrorResponse(error, req);
    
    // 記錄錯誤日誌
    this.logError(error, req);
    
    // 回應錯誤
    res.status(errorResponse.statusCode).json(errorResponse.body);
  }

  static createErrorResponse(error, req) {
    const baseResponse = {
      success: false,
      error: {
        timestamp: new Date().toISOString(),
        requestId: req.id,
        userMode: req.userMode
      }
    };

    // 遵循 8088 規範的錯誤格式
    if (error instanceof ValidationError) {
      return {
        statusCode: 400,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'VALIDATION_ERROR',
            message: error.message,
            field: error.field,
            details: error.details
          }
        }
      };
    }

    if (error instanceof AuthenticationError) {
      return {
        statusCode: 401,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'UNAUTHORIZED',
            message: '未授權存取'
          }
        }
      };
    }

    if (error instanceof BLIntegrationError) {
      return {
        statusCode: 500,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'INTERNAL_SERVER_ERROR',
            message: '業務邏輯處理錯誤'
          }
        }
      };
    }

    // 預設錯誤處理
    return {
      statusCode: 500,
      body: {
        ...baseResponse,
        error: {
          ...baseResponse.error,
          code: 'INTERNAL_SERVER_ERROR',
          message: '系統內部錯誤'
        }
      }
    };
  }
}
```

---

## 4. 技術決策記錄

### 4.1 架構決策

| 決策編號 | 決策內容 | 原因 | 影響 |
|----------|----------|------|------|
| TD-001 | 採用 Express.js 作為 API 框架 | 輕量、靈活、生態豐富 | 開發效率高，社群支援佳 |
| TD-002 | 實作四模式動態回應處理 | 支援差異化使用者體驗 | 增加複雜度，提升彈性 |
| TD-003 | 採用中介軟體模式處理通用邏輯 | 關注點分離，代碼重用 | 提升可維護性 |
| TD-004 | 使用統一的 BL 連接器 | 標準化後端整合 | 降低耦合度，提升穩定性 |

### 4.2 技術選型

```javascript
// 核心技術堆疊
const TechStack = {
  framework: 'Express.js 4.18+',
  validation: 'Joi 17.0+',
  authentication: 'jsonwebtoken 9.0+',
  documentation: 'OpenAPI 3.0.3',
  testing: 'Jest 29.0+',
  monitoring: 'Winston 3.8+',
  caching: 'Node-cache 5.1+'
};

// 開發工具鏈
const DevTools = {
  linting: 'ESLint',
  formatting: 'Prettier',
  typeChecking: 'JSDoc',
  bundling: 'Native Node.js',
  deployment: 'Replit'
};
```

---

## 5. 效能與安全性考量

### 5.1 效能最佳化

#### 5.1.1 回應快取策略

```javascript
class ResponseCache {
  constructor() {
    this.cache = new NodeCache({ stdTTL: 300 }); // 5分鐘預設TTL
    this.modeSpecificTTL = {
      'Expert': 60,      // 1分鐘
      'Inertial': 300,   // 5分鐘
      'Cultivation': 180, // 3分鐘
      'Guiding': 600     // 10分鐘
    };
  }

  // 模式感知的快取
  async getCachedResponse(key, userMode) {
    const cacheKey = `${key}:${userMode}`;
    return this.cache.get(cacheKey);
  }

  setCachedResponse(key, userMode, data) {
    const cacheKey = `${key}:${userMode}`;
    const ttl = this.modeSpecificTTL[userMode] || 300;
    
    this.cache.set(cacheKey, data, ttl);
  }
}
```

#### 5.1.2 批次處理機制

```javascript
class BatchProcessor {
  constructor() {
    this.batchSize = 50;
    this.batchTimeout = 1000; // 1秒
    this.pendingRequests = new Map();
  }

  // 批次處理 BL 調用
  async batchBLCall(requests) {
    const batches = this.createBatches(requests);
    const results = [];

    for (const batch of batches) {
      const batchResults = await Promise.all(
        batch.map(req => this.processSingleRequest(req))
      );
      results.push(...batchResults);
    }

    return results;
  }
}
```

### 5.2 安全性實作

#### 5.2.1 認證與授權

```javascript
class SecurityManager {
  static validateJWT(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      return { valid: true, user: decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  static checkPermissions(user, resource, action) {
    const permissions = user.permissions || [];
    const requiredPermission = `${resource}:${action}`;
    
    return permissions.includes(requiredPermission) || 
           permissions.includes(`${resource}:*`) ||
           permissions.includes('*:*');
  }

  // 速率限制
  static rateLimiter() {
    return rateLimit({
      windowMs: 15 * 60 * 1000, // 15分鐘
      max: 1000, // 每個IP最多1000次請求
      message: {
        success: false,
        error: {
          code: 'RATE_LIMIT_EXCEEDED',
          message: '請求頻率過高，請稍後再試'
        }
      }
    });
  }
}
```

---

## 6. 測試與驗證策略

### 6.1 單元測試模式

```javascript
// 測試範例：API 端點測試
describe('認證服務 API 測試', () => {
  let app;
  let mockBL;

  beforeEach(() => {
    mockBL = {
      AM: {
        registerUser: jest.fn(),
        authenticateUser: jest.fn()
      }
    };
    
    app = createTestApp(mockBL);
  });

  describe('POST /auth/register', () => {
    it('應該成功註冊用戶 (Expert模式)', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'SecurePass123',
        userMode: 'Expert'
      };

      mockBL.AM.registerUser.mockResolvedValue({
        userId: 'user-123',
        email: userData.email
      });

      const response = await request(app)
        .post('/auth/register')
        .set('X-User-Mode', 'Expert')
        .send(userData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.userId).toBe('user-123');
      expect(mockBL.AM.registerUser).toHaveBeenCalledWith(userData);
    });

    it('應該回傳驗證錯誤 (無效Email)', async () => {
      const invalidData = {
        email: 'invalid-email',
        password: 'SecurePass123'
      };

      const response = await request(app)
        .post('/auth/register')
        .send(invalidData)
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('VALIDATION_ERROR');
      expect(response.body.error.field).toBe('email');
    });
  });
});
```

### 6.2 整合測試策略

```javascript
// BL 整合測試
describe('APL-BL 整合測試', () => {
  it('應該正確調用 LBK 模組進行快速記帳', async () => {
    const quickBookingData = {
      input: '午餐 150',
      userId: 'user-123',
      ledgerId: 'ledger-456'
    };

    const response = await request(app)
      .post('/transactions/quick')
      .set('Authorization', 'Bearer valid-token')
      .set('X-User-Mode', 'Cultivation')
      .send(quickBookingData)
      .expect(200);

    // 驗證回應格式符合四模式要求
    expect(response.body.data.achievement).toBeDefined(); // Cultivation 特有
    expect(response.body.metadata.userMode).toBe('Cultivation');
  });
});
```

---

## 7. 開發指導原則

### 7.1 代碼規範

```javascript
// 標準 API 端點實作模式
class APIEndpoint {
  constructor(config) {
    this.blModule = config.blModule;
    this.blFunction = config.blFunction;
    this.validation = config.validation;
    this.modes = config.modes || ['Inertial'];
  }

  // 標準處理流程
  async handle(req, res, next) {
    try {
      // 1. 前處理
      await this.preProcess(req);
      
      // 2. 業務邏輯調用
      const result = await this.executeBL(req.validatedData);
      
      // 3. 後處理
      const response = await this.postProcess(result, req.userMode);
      
      // 4. 回應
      res.json(response);
      
    } catch (error) {
      next(error);
    }
  }

  async preProcess(req) {
    // 模式驗證
    if (!this.modes.includes(req.userMode)) {
      throw new UnsupportedModeError(
        `此 API 不支援 ${req.userMode} 模式`
      );
    }
  }

  async executeBL(data) {
    const blConnector = new BLConnector();
    return await blConnector.execute(
      this.blModule,
      this.blFunction,
      data
    );
  }

  async postProcess(result, userMode) {
    const processor = new ResponseProcessor(userMode);
    return processor.format(result);
  }
}
```

### 7.2 最佳實踐

1. **遵循 8088 規範**：所有 API 實作必須嚴格遵循設計規範
2. **四模式支援**：每個端點都需要考慮四模式的差異化處理
3. **錯誤處理**：使用統一的錯誤處理機制
4. **效能監控**：實作請求追蹤與效能監控
5. **安全第一**：所有輸入都必須驗證，所有輸出都必須過濾

### 7.3 部署檢查清單

- [ ] API 端點功能完整
- [ ] 四模式處理正確
- [ ] BL 整合無誤
- [ ] 錯誤處理完善
- [ ] 效能測試通過
- [ ] 安全檢查完成
- [ ] 文件更新完整

---

**範本版本**: 1.0.0  
**適用範圍**: 81號資料夾所有 API 規格  
**維護者**: LCAS SA Team  
**最後更新**: 2025-01-28
