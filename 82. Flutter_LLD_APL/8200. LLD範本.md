
# 8200. LLD範本

**版本**: 1.2.0  
**建立日期**: 2025-08-27  
**最後更新**: 2025-08-27  
**建立者**: SA  
**適用對象**: 81號資料夾 API 規格實作

---

## 目次 (Table of Contents)

### 1. [文件目的與適用範圍](#1-文件目的與適用範圍)
### 2. [系統架構設計](#2-系統架構設計)
   - 2.1 [整體架構圖](#21-整體架構圖)
   - 2.2 [API Gateway 設計](#22-api-gateway-設計)
   - 2.3 [四模式處理架構](#23-四模式處理架構)
   - 2.4 [BL層整合架構](#24-bl層整合架構)

### 3. [核心模組設計](#3-核心模組設計)
   - 3.1 [路由管理模組](#31-路由管理模組)
   - 3.2 [認證授權模組](#32-認證授權模組)
   - 3.3 [請求處理模組](#33-請求處理模組)
   - 3.4 [回應格式化模組](#34-回應格式化模組)
   - 3.5 [錯誤處理模組](#35-錯誤處理模組)

### 4. [API端點實作規範](#4-api端點實作規範)
   - 4.1 [認證服務端點](#41-認證服務端點)
   - 4.2 [記帳交易端點](#42-記帳交易端點)
   - 4.3 [帳本管理端點](#43-帳本管理端點)
   - 4.4 [其他服務端點](#44-其他服務端點)

### 5. [函數規格定義](#5-函數規格定義)
   - 5.1 [核心處理函數](#51-核心處理函數)
   - 5.2 [輔助工具函數](#52-輔助工具函數)
   - 5.3 [中介軟體函數](#53-中介軟體函數)
   - 5.4 [錯誤處理函數](#54-錯誤處理函數)

### 6. [資料流程與驗證](#6-資料流程與驗證)
   - 6.1 [請求資料驗證](#61-請求資料驗證)
   - 6.2 [BL層調用流程](#62-bl層調用流程)
   - 6.3 [回應資料處理](#63-回應資料處理)

### 7. [效能與安全性設計](#7-效能與安全性設計)
   - 7.1 [快取機制](#71-快取機制)
   - 7.2 [速率限制](#72-速率限制)
   - 7.3 [安全防護](#73-安全防護)

### 8. [測試策略](#8-測試策略)
### 9. [部署與監控](#9-部署與監控)
### 10. [附錄](#10-附錄)

---

## 1. 文件目的與適用範圍

### 1.1 LLD範本目的
- 提供APL層實作的標準化指導
- 確保132個API端點的一致性實作
- 建立可複製的開發模式
- 支援四模式差異化處理

### 1.2 適用範圍
- 81號資料夾的所有API規格實作
- APL層的技術架構設計
- API端點的具體實作指導
- BL層整合的標準流程

### 1.3 使用方式
- **開發團隊**：依據此範本建立具體LLD文件
- **架構師**：確保整體架構一致性
- **QA團隊**：作為測試設計的參考依據

---

## 2. 系統架構設計

### 2.1 整體架構圖
```
[Frontend] ↔ [APL Layer] ↔ [BL Layer] ↔ [DL Layer]
             ├─ API Gateway
             ├─ Route Manager
             ├─ Auth Module
             ├─ Mode Processor
             └─ Error Handler
```

### 2.2 API Gateway 設計
#### 2.2.1 核心組件
- **RouteManager**: 路由註冊與分發
- **MiddlewareStack**: 中介軟體管理
- **BLConnector**: BL層調用介面
- **ResponseFormatter**: 回應格式化器

#### 2.2.2 請求處理流程
1. **接收請求** → 路由解析
2. **認證授權** → Token驗證
3. **模式識別** → 四模式判斷
4. **資料驗證** → 請求參數檢查
5. **BL層調用** → 業務邏輯處理
6. **回應格式化** → 依模式調整回應
7. **回傳結果** → 標準格式輸出

### 2.3 四模式處理架構
#### 2.3.1 模式識別機制
- Header檢查：`X-User-Mode`
- 用戶設定查詢
- 預設值處理

#### 2.3.2 差異化處理策略
- **Expert**: 完整資料 + 進階功能
- **Inertial**: 標準資料 + 基本功能  
- **Cultivation**: 引導資料 + 激勵機制
- **Guiding**: 極簡資料 + 最少選項

### 2.4 BL層整合架構
#### 2.4.1 模組映射表
```
API Service → BL Module
auth/*      → AM
transactions/* → LBK/BK
ledgers/*   → MLS
accounts/*  → MLS
budgets/*   → BM
reports/*   → MRA
```

#### 2.4.2 調用介面設計
- 統一調用方法
- 錯誤處理機制
- 結果標準化

### 2.2 四模式處理機制

#### 2.2.1 模式識別器

```javascript
class UserModeProcessor {
  constructor() {
    this.modeConfigs = this.loadModeConfigurations();
  }

  // 動態模式識別
  async identifyMode(req) {
    // 1. Header 檢查
    if (req.headers['x-user-mode']) {
      return req.headers['x-user-mode'];
    }

    // 2. 用戶設定查詢
    const userProfile = await this.getUserProfile(req.user.id);
    return userProfile.userMode || 'Inertial';
  }

  // 四模式回應格式化
  async formatResponse(data, userMode) {
    const modeConfig = this.modeConfigs[userMode];
    
    switch (userMode) {
      case 'Expert':
        return this.formatExpertResponse(data, modeConfig);
      
      case 'Inertial':
        return this.formatInertialResponse(data, modeConfig);
      
      case 'Cultivation':
        return this.formatCultivationResponse(data, modeConfig);
      
      case 'Guiding':
        return this.formatGuidingResponse(data, modeConfig);
      
      default:
        return this.formatInertialResponse(data, modeConfig);
    }
  }

  // Expert 模式：完整資訊
  formatExpertResponse(data, config) {
    return {
      ...data,
      metadata: {
        ...data.metadata,
        detailedAnalytics: data.analytics,
        advancedOptions: data.options,
        technicalDetails: data.technical
      }
    };
  }

  // Cultivation 模式：激勵資訊
  formatCultivationResponse(data, config) {
    return {
      ...data,
      achievements: data.gamification?.achievements,
      progress: data.gamification?.progress,
      motivationalContent: data.gamification?.motivation
    };
  }

  // Guiding 模式：極簡資訊
  formatGuidingResponse(data, config) {
    return {
      success: data.success,
      data: this.simplifyDataForGuiding(data.data),
      message: data.simpleMessage || data.message
    };
  }
}
```

### 2.3 BL層整合設計

#### 2.3.1 BL連接器架構

```javascript
class BLConnector {
  constructor() {
    this.moduleMap = this.loadBLModuleMapping();
    this.connectionPool = new ConnectionPool();
  }

  // 基於 8025 API-BL mapping 的模組映射
  loadBLModuleMapping() {
    return {
      // 認證相關 API -> AM 模組
      'auth': {
        module: 'AM',
        functions: {
          'register': 'registerUser',
          'login': 'authenticateUser',
          'refresh': 'refreshToken'
        }
      },

      // 記帳相關 API -> LBK + BK 模組
      'transactions': {
        module: 'LBK',
        functions: {
          'quick': 'quickBookkeeping',
          'create': 'createTransaction',
          'list': 'getTransactions'
        },
        fallback: 'BK' // 複雜邏輯回退到 BK 模組
      },

      // 帳本管理 API -> MLS 模組
      'ledgers': {
        module: 'MLS',
        functions: {
          'create': 'createLedger',
          'list': 'getLedgers',
          'collaborate': 'manageLedgerCollaboration'
        }
      }

      // ... 其他模組映射
    };
  }

  // 統一 BL 調用介面
  async execute(moduleName, functionName, data) {
    try {
      const module = this.getModule(moduleName);
      const result = await module[functionName](data);
      
      return {
        success: true,
        data: result,
        metadata: {
          module: moduleName,
          function: functionName,
          timestamp: new Date().toISOString(),
          requestId: data.requestId
        }
      };
      
    } catch (error) {
      throw new BLIntegrationError(
        `BL模組調用失敗: ${moduleName}.${functionName}`,
        error
      );
    }
  }

  getModule(moduleName) {
    switch (moduleName) {
      case 'AM': return require('../13. Replit_Module code_BL/2009. AM.js');
      case 'LBK': return require('../13. Replit_Module code_BL/2015. LBK.js');
      case 'BK': return require('../13. Replit_Module code_BL/2001. BK.js');
      case 'MLS': return require('../13. Replit_Module code_BL/2051. MLS.js');
      // ... 其他模組
      default:
        throw new Error(`未知的BL模組: ${moduleName}`);
    }
  }
}
```

---

## 3. 核心函數設計

### 3.1 API端點處理函數

#### 3.1.1 認證服務處理函數

```javascript
/**
 * 01. 處理用戶註冊請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 POST /auth/register 註冊請求，整合AM模組功能
 */
function APL_handleUserRegistration(req, res, next)
```
- **功能**: 處理用戶註冊流程
- **輸入參數**: 
  ```javascript
  req.body = {
    email: "user@example.com",
    password: "securePassword123",
    confirmPassword: "securePassword123",
    acceptTerms: true
  }
  ```
- **與其他模組互動**:
  - `AM.registerUser()` - 呼叫AM模組註冊功能
  - `APL_validateRegistrationData()` - 驗證註冊資料
  - `APL_formatRegistrationResponse()` - 格式化回應
- **回傳值**: 
  ```javascript
  {
    success: true/false,
    data: {
      userId: "uuid",
      email: "user@example.com",
      verificationSent: true,
      needsAssessment: true
    }
  }
  ```

```javascript
/**
 * 02. 處理用戶登入請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 POST /auth/login 登入請求，整合AM模組驗證
 */
function APL_handleUserLogin(req, res, next)
```
- **功能**: 處理用戶登入驗證
- **輸入參數**: 
  ```javascript
  req.body = {
    email: "user@example.com",
    password: "securePassword123",
    rememberMe: true
  }
  ```
- **與其他模組互動**:
  - `AM.authenticateUser()` - 呼叫AM模組驗證
  - `APL_generateJWTToken()` - 生成JWT Token
  - `APL_formatLoginResponse()` - 格式化登入回應

#### 3.1.2 記帳交易處理函數

```javascript
/**
 * 03. 處理LINE OA快速記帳請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 POST /transactions/quick 快速記帳，整合LBK模組
 */
function APL_handleQuickBookkeeping(req, res, next)
```
- **功能**: 處理LINE OA快速記帳
- **輸入參數**: 
  ```javascript
  req.body = {
    input: "午餐 150",
    userId: "user-uuid-12345",
    ledgerId: "ledger-uuid-001"
  }
  ```
- **與其他模組互動**:
  - `LBK.processQuickBookkeeping()` - 呼叫LBK模組快速記帳
  - `APL_validateQuickBookkeepingInput()` - 驗證輸入
  - `APL_formatQuickBookkeepingResponse()` - 依四模式格式化回應

```javascript
/**
 * 04. 處理完整記帳請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 POST /transactions 完整記帳，整合BK模組
 */
function APL_handleCreateTransaction(req, res, next)
```
- **功能**: 處理完整的交易記錄建立
- **與其他模組互動**:
  - `BK.createTransaction()` - 呼叫BK模組記帳
  - `APL_validateTransactionData()` - 驗證交易資料
  - `APL_handleRecurringTransaction()` - 處理重複設定

```javascript
/**
 * 05. 處理交易查詢請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 GET /transactions 交易查詢，整合BK模組
 */
function APL_handleGetTransactions(req, res, next)
```
- **功能**: 處理交易記錄查詢與篩選
- **與其他模組互動**:
  - `BK.getTransactions()` - 呼叫BK模組查詢
  - `APL_buildQueryFilters()` - 建立查詢條件
  - `APL_formatTransactionList()` - 依四模式格式化列表

#### 3.1.3 帳本管理處理函數

```javascript
/**
 * 06. 處理帳本建立請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 POST /ledgers 建立帳本，整合MLS模組
 */
function APL_handleCreateLedger(req, res, next)
```
- **功能**: 處理帳本建立
- **與其他模組互動**:
  - `MLS.createLedger()` - 呼叫MLS模組建立帳本
  - `CM.setupCollaboration()` - 設定協作功能

```javascript
/**
 * 07. 處理帳本查詢請求
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 處理 GET /ledgers 帳本查詢，整合MLS模組
 */
function APL_handleGetLedgers(req, res, next)
```

### 3.2 輔助處理函數

```javascript
/**
 * 08. 四模式回應格式化
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 根據用戶模式格式化API回應內容
 */
function APL_formatResponseByUserMode(data, userMode, apiType)
```
- **功能**: 統一的四模式回應處理
- **處理邏輯**:
  - Expert: 完整資料 + 進階選項
  - Inertial: 標準資料 + 固定選項
  - Cultivation: 引導資料 + 進度追蹤
  - Guiding: 簡化資料 + 最少選項

```javascript
/**
 * 09. 請求資料驗證
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 統一的請求資料驗證機制
 */
function APL_validateRequestData(data, schema, apiType)
```

```javascript
/**
 * 10. BL模組調用統一介面
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 統一的Business Layer模組調用介面
 */
function APL_callBLModule(moduleName, functionName, data, processId)
```

```javascript
/**
 * 11. 統一錯誤處理
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 統一的API錯誤處理和回應格式化
 */
function APL_handleError(error, req, res, next)
```

```javascript
/**
 * 12. JWT Token 驗證
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 驗證請求中的JWT Token有效性
 */
function APL_verifyJWTToken(req, res, next)
```

```javascript
/**
 * 13. 用戶模式識別
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 從請求中識別用戶的操作模式
 */
function APL_identifyUserMode(req, res, next)
```

```javascript
/**
 * 14. API速率限制
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 實作API調用速率限制
 */
function APL_rateLimiter(req, res, next)
```

```javascript
/**
 * 15. 請求日誌記錄
 * @version 2025-08-27-V1.0.0
 * @date 2025-08-27 12:00:00
 * @description 記錄API請求的詳細日誌
 */
function APL_logRequest(req, res, next)
```

## 4. 實作規範

### 4.1 路由設計模式

#### 3.1.1 RESTful 路由結構

```javascript
// 遵循 8088 規範的路由設計
class RESTfulRouter {
  constructor() {
    this.baseRouter = express.Router();
    this.setupMiddlewares();
    this.setupRoutes();
  }

  setupRoutes() {
    // 認證服務路由 (對應 8101 規格)
    this.baseRouter.post('/auth/register', 
      this.validateRequest('AuthRegister'),
      this.modeAwareHandler('AM', 'registerUser')
    );

    this.baseRouter.post('/auth/login',
      this.validateRequest('AuthLogin'),
      this.modeAwareHandler('AM', 'authenticateUser')
    );

    // 記帳服務路由 (對應 8103 規格)
    this.baseRouter.post('/transactions/quick',
      this.requireAuth(),
      this.validateRequest('QuickTransaction'),
      this.modeAwareHandler('LBK', 'quickBookkeeping')
    );

    this.baseRouter.get('/transactions',
      this.requireAuth(),
      this.validateQuery('TransactionQuery'),
      this.modeAwareHandler('BK', 'getTransactions')
    );
  }

  // 模式感知的處理器
  modeAwareHandler(blModule, blFunction) {
    return async (req, res, next) => {
      try {
        const processor = new RequestProcessor(req.userMode);
        const result = await processor.execute(blModule, blFunction, req.validatedData);
        
        res.json(this.formatResponse(result, req.userMode));
      } catch (error) {
        next(error);
      }
    };
  }
}
```

#### 3.1.2 動態路由生成

```javascript
// 基於 8020 文件自動生成路由
class RouteGenerator {
  static generateFromAPISpec(apiSpec) {
    const routes = [];
    
    // 解析 8101-8113 YAML 規格
    apiSpec.services.forEach(service => {
      service.endpoints.forEach(endpoint => {
        const route = {
          method: endpoint.method,
          path: endpoint.path,
          handler: this.createHandler(endpoint),
          middlewares: this.createMiddlewares(endpoint),
          validation: this.createValidation(endpoint)
        };
        
        routes.push(route);
      });
    });
    
    return routes;
  }

  static createHandler(endpoint) {
    return async (req, res, next) => {
      const context = {
        service: endpoint.service,
        operation: endpoint.operationId,
        userMode: req.userMode,
        blMapping: endpoint.blMapping
      };
      
      const handler = new EndpointHandler(context);
      await handler.process(req, res, next);
    };
  }
}
```

### 3.2 中介軟體架構

#### 3.2.1 中介軟體堆疊

```javascript
class MiddlewareStack {
  constructor() {
    this.middlewares = [];
    this.setupCoreMiddlewares();
  }

  setupCoreMiddlewares() {
    // 1. 請求日誌
    this.use(this.requestLogger());
    
    // 2. CORS 處理
    this.use(this.corsHandler());
    
    // 3. 安全標頭
    this.use(this.securityHeaders());
    
    // 4. 速率限制
    this.use(this.rateLimiter());
    
    // 5. 用戶模式識別
    this.use(this.userModeIdentifier());
    
    // 6. 請求驗證
    this.use(this.requestValidator());
  }

  // 用戶模式識別中介軟體
  userModeIdentifier() {
    return async (req, res, next) => {
      try {
        const modeProcessor = new UserModeProcessor();
        req.userMode = await modeProcessor.identifyMode(req);
        
        // 設定模式相關的請求上下文
        req.modeContext = {
          mode: req.userMode,
          capabilities: this.getModeCapabilities(req.userMode),
          responseFormat: this.getModeResponseFormat(req.userMode)
        };
        
        next();
      } catch (error) {
        next(error);
      }
    };
  }

  // 統一請求驗證
  requestValidator() {
    return (req, res, next) => {
      const validator = new RequestValidator(req.userMode);
      
      try {
        req.validatedData = validator.validate(req);
        next();
      } catch (validationError) {
        res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: validationError.message,
            field: validationError.field,
            timestamp: new Date().toISOString(),
            requestId: req.id
          }
        });
      }
    };
  }
}
```

### 3.3 錯誤處理機制

#### 3.3.1 統一錯誤處理器

```javascript
class UnifiedErrorHandler {
  static handle(error, req, res, next) {
    const errorResponse = this.createErrorResponse(error, req);
    
    // 記錄錯誤日誌
    this.logError(error, req);
    
    // 回應錯誤
    res.status(errorResponse.statusCode).json(errorResponse.body);
  }

  static createErrorResponse(error, req) {
    const baseResponse = {
      success: false,
      error: {
        timestamp: new Date().toISOString(),
        requestId: req.id,
        userMode: req.userMode
      }
    };

    // 遵循 8088 規範的錯誤格式
    if (error instanceof ValidationError) {
      return {
        statusCode: 400,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'VALIDATION_ERROR',
            message: error.message,
            field: error.field,
            details: error.details
          }
        }
      };
    }

    if (error instanceof AuthenticationError) {
      return {
        statusCode: 401,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'UNAUTHORIZED',
            message: '未授權存取'
          }
        }
      };
    }

    if (error instanceof BLIntegrationError) {
      return {
        statusCode: 500,
        body: {
          ...baseResponse,
          error: {
            ...baseResponse.error,
            code: 'INTERNAL_SERVER_ERROR',
            message: '業務邏輯處理錯誤'
          }
        }
      };
    }

    // 預設錯誤處理
    return {
      statusCode: 500,
      body: {
        ...baseResponse,
        error: {
          ...baseResponse.error,
          code: 'INTERNAL_SERVER_ERROR',
          message: '系統內部錯誤'
        }
      }
    };
  }
}
```