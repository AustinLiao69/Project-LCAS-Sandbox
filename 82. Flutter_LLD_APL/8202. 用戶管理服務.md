
# 8202. 用戶管理服務 LLD

**版本**: 1.0.0  
**建立日期**: 2025-09-02  
**最後更新**: 2025-09-02  
**建立者**: SA  
**來源文件**: 8102. 用戶管理服務 API 規格.yaml

---

## 目次 (Table of Contents)

### 1. [概述](#1-概述)
### 2. [類別設計](#2-類別設計)
### 3. [核心函數規格](#3-核心函數規格)
### 4. [資料模型設計](#4-資料模型設計)
### 5. [API端點實作映射](#5-api端點實作映射)
### 6. [四模式差異化策略](#6-四模式差異化策略)
### 7. [安全與驗證設計](#7-安全與驗證設計)
### 8. [錯誤處理設計](#8-錯誤處理設計)
### 9. [測試設計策略](#9-測試設計策略)

---

## 1. 概述

### 1.1 模組目的
本LLD文件為PG提供完整的用戶管理服務編程介面規格，基於8102文件API規格，實現用戶資料管理、模式評估與切換、安全設定、使用行為追蹤與個人化推薦等核心功能。

### 1.2 技術架構
```
UserController
    ├─ depends on ──→ UserService
    ├─ depends on ──→ AssessmentService  
    ├─ depends on ──→ SecurityService
    ├─ depends on ──→ UserModeAdapter
    └─ depends on ──→ BehaviorTrackingService
```

### 1.3 設計原則
- **嚴格遵循8088規範**：HTTP狀態碼、回應格式、錯誤處理
- **完全符合8020規範**：API清單對應與命名慣例
- **精確實作8102規格**：所有端點與功能完整覆蓋
- **四模式差異化**：每個API支援Expert、Inertial、Cultivation、Guiding模式

---

## 2. 類別設計

### 2.1 UserController 類別

```dart
/**
 * 01. 用戶管理控制器
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserController {
  final UserService _userService;
  final AssessmentService _assessmentService;
  final SecurityService _securityService;
  final UserModeAdapter _modeAdapter;
  final BehaviorTrackingService _behaviorService;

  UserController({
    required UserService userService,
    required AssessmentService assessmentService,
    required SecurityService securityService,
    required UserModeAdapter modeAdapter,
    required BehaviorTrackingService behaviorService,
  }) : _userService = userService,
       _assessmentService = assessmentService,
       _securityService = securityService,
       _modeAdapter = modeAdapter,
       _behaviorService = behaviorService;
}
```

### 2.2 UserService 類別

```dart
/**
 * 02. 用戶核心服務
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserService {
  final FirestoreService _firestoreService;
  final ValidationService _validationService;

  UserService({
    required FirestoreService firestoreService,
    required ValidationService validationService,
  }) : _firestoreService = firestoreService,
       _validationService = validationService;
}
```

### 2.3 AssessmentService 類別

```dart
/**
 * 03. 模式評估服務
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class AssessmentService {
  final QuestionnaireRepository _questionnaireRepo;
  final ModeCalculationEngine _calculationEngine;

  AssessmentService({
    required QuestionnaireRepository questionnaireRepo,
    required ModeCalculationEngine calculationEngine,
  }) : _questionnaireRepo = questionnaireRepo,
       _calculationEngine = calculationEngine;
}
```

---

## 3. 核心函數規格

### 3.1 用戶資料管理函數

```dart
/**
 * 04. 取得用戶個人資料 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<UserProfileData>> getUserProfile({
  required String userId,
  required UserMode userMode,
}) async {
  try {
    // 參數驗證
    if (userId.isEmpty) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: '用戶ID不能為空',
        field: 'userId',
        statusCode: 400,
      );
    }

    // 取得用戶基本資料
    final userDoc = await _firestoreService.getDocument('users', userId);
    if (userDoc == null) {
      return ApiResponse.error(
        code: 'RESOURCE_NOT_FOUND',
        message: '用戶不存在',
        field: 'userId',
        statusCode: 404,
      );
    }

    // 根據模式調整回應內容
    final profileData = await _modeAdapter.adaptUserProfile(
      userDoc: userDoc,
      userMode: userMode,
    );

    return ApiResponse.success(
      data: profileData,
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: userMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '系統暫時無法處理請求',
      statusCode: 500,
    );
  }
}
```

```dart
/**
 * 05. 更新用戶個人資料 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<UpdateProfileResult>> updateUserProfile({
  required String userId,
  required UpdateProfileRequest request,
  required UserMode userMode,
}) async {
  try {
    // 參數驗證
    final validationResult = await _validationService.validateProfileUpdate(request);
    if (!validationResult.isValid) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: validationResult.message,
        field: validationResult.field,
        statusCode: 400,
        details: {'validation': validationResult.errors},
      );
    }

    // 檢查用戶存在性
    final userExists = await _userService.userExists(userId);
    if (!userExists) {
      return ApiResponse.error(
        code: 'RESOURCE_NOT_FOUND',
        message: '用戶不存在',
        statusCode: 404,
      );
    }

    // 根據模式檢查可編輯欄位
    final allowedFields = _modeAdapter.getAllowedEditableFields(userMode);
    final filteredData = _filterUpdateData(request.toMap(), allowedFields);

    // 執行更新
    await _firestoreService.updateDocument('users', userId, {
      ...filteredData,
      'updatedAt': FieldValue.serverTimestamp(),
    });

    return ApiResponse.success(
      data: UpdateProfileResult(
        message: '個人資料更新成功',
        updatedAt: DateTime.now(),
        appliedChanges: filteredData.keys.toList(),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: userMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '更新失敗，請稍後再試',
      statusCode: 500,
    );
  }
}
```

### 3.2 模式評估函數

```dart
/**
 * 06. 取得模式評估問卷 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<AssessmentQuestions>> getAssessmentQuestions() async {
  try {
    final questionnaire = await _questionnaireRepo.getCurrentQuestionnaire();
    
    return ApiResponse.success(
      data: AssessmentQuestions(
        questionnaire: QuestionnaireData(
          id: questionnaire.id,
          version: questionnaire.version,
          title: 'LCAS 2.0 使用者模式評估',
          description: '透過 5 道題目了解您的記帳習慣，為您推薦最適合的使用模式',
          estimatedTime: 3,
          questions: questionnaire.questions,
        ),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: UserMode.Expert, // 評估前預設值
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '無法載入評估問卷',
      statusCode: 500,
    );
  }
}
```

```dart
/**
 * 07. 提交模式評估結果 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<AssessmentResult>> submitAssessment({
  required String userId,
  required AssessmentSubmission submission,
}) async {
  try {
    // 驗證問卷ID
    final questionnaire = await _questionnaireRepo.getQuestionnaire(submission.questionnaireId);
    if (questionnaire == null) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: '無效的問卷ID',
        field: 'questionnaireId',
        statusCode: 400,
      );
    }

    // 驗證答案完整性
    final validationResult = _validateAnswers(questionnaire, submission.answers);
    if (!validationResult.isValid) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: validationResult.message,
        field: 'answers',
        statusCode: 400,
      );
    }

    // 計算推薦模式
    final calculation = await _calculationEngine.calculateRecommendedMode(
      questionnaire: questionnaire,
      answers: submission.answers,
    );

    // 更新用戶模式
    await _userService.updateUserMode(
      userId: userId,
      newMode: calculation.recommendedMode,
      assessmentId: submission.questionnaireId,
    );

    return ApiResponse.success(
      data: AssessmentResult(
        result: ModeRecommendation(
          recommendedMode: calculation.recommendedMode,
          confidence: calculation.confidence,
          scores: calculation.scores,
          explanation: calculation.explanation,
          modeCharacteristics: calculation.characteristics,
        ),
        applied: true,
        previousMode: await _userService.getPreviousMode(userId),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: calculation.recommendedMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '評估處理失敗',
      statusCode: 500,
    );
  }
}
```

### 3.3 偏好設定函數

```dart
/**
 * 08. 更新用戶偏好設定 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<PreferencesUpdateResult>> updatePreferences({
  required String userId,
  required UserPreferences preferences,
  required UserMode userMode,
}) async {
  try {
    // 驗證用戶權限
    final hasPermission = await _securityService.checkUserPermission(
      userId: userId,
      action: 'UPDATE_PREFERENCES',
    );
    
    if (!hasPermission) {
      return ApiResponse.error(
        code: 'FORBIDDEN',
        message: '您沒有權限執行此操作',
        statusCode: 403,
      );
    }

    // 根據模式過濾可設定項目
    final allowedPreferences = _modeAdapter.filterPreferences(
      preferences: preferences,
      userMode: userMode,
    );

    // 驗證偏好設定值
    final validationResult = await _validationService.validatePreferences(allowedPreferences);
    if (!validationResult.isValid) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: validationResult.message,
        statusCode: 400,
        details: {'validation': validationResult.errors},
      );
    }

    // 更新偏好設定
    await _userService.updatePreferences(
      userId: userId,
      preferences: allowedPreferences,
    );

    return ApiResponse.success(
      data: PreferencesUpdateResult(
        message: '偏好設定已更新',
        updatedAt: DateTime.now(),
        appliedChanges: allowedPreferences.getChangedFields(),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: userMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '偏好設定更新失敗',
      statusCode: 500,
    );
  }
}
```

### 3.4 安全設定函數

```dart
/**
 * 09. 更新安全設定 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<SecurityUpdateResult>> updateSecuritySettings({
  required String userId,
  required SecuritySettings settings,
  required UserMode userMode,
}) async {
  try {
    // PIN碼加密處理
    if (settings.appLock?.pinCode != null) {
      settings = settings.copyWith(
        appLock: settings.appLock!.copyWith(
          pinCode: await _securityService.encryptPin(settings.appLock!.pinCode!),
        ),
      );
    }

    // 驗證安全設定
    final validationResult = await _securityService.validateSecuritySettings(settings);
    if (!validationResult.isValid) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: validationResult.message,
        statusCode: 400,
      );
    }

    // 檢查業務邏輯
    final businessValidation = await _securityService.validateBusinessLogic(
      userId: userId,
      settings: settings,
    );
    
    if (!businessValidation.isValid) {
      return ApiResponse.error(
        code: 'BUSINESS_LOGIC_ERROR',
        message: businessValidation.message,
        statusCode: 422,
      );
    }

    // 更新安全設定
    await _securityService.updateSecuritySettings(
      userId: userId,
      settings: settings,
    );

    // 計算安全等級
    final securityLevel = _securityService.calculateSecurityLevel(settings);

    return ApiResponse.success(
      data: SecurityUpdateResult(
        message: '安全設定已更新',
        securityLevel: securityLevel,
        updatedSettings: settings.getUpdatedFields(),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: userMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '安全設定更新失敗',
      statusCode: 500,
    );
  }
}
```

```dart
/**
 * 10. PIN碼驗證 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<PinVerificationResult>> verifyPin({
  required String userId,
  required String pinCode,
  required PinOperation operation,
  DeviceInfo? deviceInfo,
}) async {
  try {
    // PIN碼格式驗證
    if (pinCode.length < 4 || pinCode.length > 6) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: 'PIN碼長度必須為4-6位數',
        field: 'pinCode',
        statusCode: 400,
      );
    }

    // 檢查PIN碼鎖定狀態
    final lockStatus = await _securityService.getPinLockStatus(userId);
    if (lockStatus.isLocked) {
      return ApiResponse.error(
        code: 'PIN_LOCKED',
        message: 'PIN碼已被鎖定，請稍後再試',
        field: 'pinCode',
        statusCode: 423,
        details: {
          'unlockAt': lockStatus.unlockAt.toIso8601String(),
        },
      );
    }

    // 執行PIN碼驗證
    final verificationResult = await _securityService.verifyPin(
      userId: userId,
      inputPin: pinCode,
      operation: operation,
    );

    if (!verificationResult.isValid) {
      // 記錄失敗嘗試
      await _securityService.recordFailedAttempt(userId);
      
      final remainingAttempts = await _securityService.getRemainingAttempts(userId);
      
      return ApiResponse.error(
        code: 'INVALID_PIN',
        message: 'PIN碼錯誤',
        field: 'pinCode',
        statusCode: 400,
        details: {
          'remainingAttempts': remainingAttempts,
          if (remainingAttempts == 0) 'lockoutTime': DateTime.now().add(Duration(hours: 1)).toIso8601String(),
        },
      );
    }

    // 重置失敗計數
    await _securityService.resetFailedAttempts(userId);

    return ApiResponse.success(
      data: PinVerificationResult(
        verified: true,
        operation: operation.toString(),
        remainingAttempts: 3,
        validFor: 300, // 5分鐘有效
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: await _userService.getUserMode(userId),
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: 'PIN碼驗證失敗',
      statusCode: 500,
    );
  }
}
```

### 3.5 模式管理函數

```dart
/**
 * 11. 切換用戶模式 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<ModeChangeResult>> changeUserMode({
  required String userId,
  required UserMode newMode,
  String? reason,
}) async {
  try {
    // 取得當前模式
    final currentMode = await _userService.getUserMode(userId);
    
    // 檢查是否為相同模式
    if (currentMode == newMode) {
      return ApiResponse.error(
        code: 'BUSINESS_LOGIC_ERROR',
        message: '已經是該模式，無需切換',
        statusCode: 422,
      );
    }

    // 檢查用戶權限
    final canChange = await _securityService.canChangeMode(userId, newMode);
    if (!canChange) {
      return ApiResponse.error(
        code: 'FORBIDDEN',
        message: '您沒有權限切換到該模式',
        statusCode: 403,
      );
    }

    // 執行模式切換
    await _userService.changeMode(
      userId: userId,
      fromMode: currentMode,
      toMode: newMode,
      reason: reason,
    );

    // 取得新模式特性
    final modeCharacteristics = _modeAdapter.getModeCharacteristics(newMode);
    final suggestedFeatures = _modeAdapter.getSuggestedFeatures(newMode);

    return ApiResponse.success(
      data: ModeChangeResult(
        previousMode: currentMode,
        currentMode: newMode,
        changedAt: DateTime.now(),
        modeDescription: modeCharacteristics.description,
        suggestedFeatures: suggestedFeatures,
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: newMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '模式切換失敗',
      statusCode: 500,
    );
  }
}
```

```dart
/**
 * 12. 取得模式預設值 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<ModeDefaultsData>> getModeDefaults({
  required UserMode mode,
}) async {
  try {
    // 驗證模式參數
    if (!UserMode.values.contains(mode)) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: '無效的模式參數',
        field: 'mode',
        statusCode: 400,
      );
    }

    // 取得模式預設配置
    final defaults = await _modeAdapter.getModeDefaults(mode);
    
    if (defaults == null) {
      return ApiResponse.error(
        code: 'NOT_FOUND',
        message: '找不到該模式的預設配置',
        statusCode: 404,
      );
    }

    return ApiResponse.success(
      data: ModeDefaultsData(
        mode: mode,
        defaults: defaults,
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: mode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '無法取得模式預設值',
      statusCode: 500,
    );
  }
}
```

### 3.6 行為追蹤函數

```dart
/**
 * 13. 記錄使用行為追蹤 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<BehaviorTrackingResult>> recordBehaviorTracking({
  required String userId,
  required BehaviorTrackingRequest request,
}) async {
  try {
    // 驗證會話ID
    if (request.sessionId != null && request.sessionId!.isEmpty) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: '會話ID不能為空',
        field: 'sessionId',
        statusCode: 400,
      );
    }

    // 驗證事件列表
    if (request.events.isEmpty) {
      return ApiResponse.error(
        code: 'VALIDATION_ERROR',
        message: '事件列表不能為空',
        field: 'events',
        statusCode: 400,
      );
    }

    // 檢查隱私設定
    final privacySettings = await _userService.getPrivacySettings(userId);
    if (!privacySettings.allowBehaviorTracking) {
      return ApiResponse.error(
        code: 'FORBIDDEN',
        message: '用戶已禁用行為追蹤',
        statusCode: 403,
      );
    }

    // 過濾敏感資料並記錄行為
    final sanitizedEvents = _behaviorService.sanitizeEvents(request.events);
    final recordedCount = await _behaviorService.recordBehavior(
      userId: userId,
      sessionId: request.sessionId ?? _generateSessionId(),
      events: sanitizedEvents,
    );

    return ApiResponse.success(
      data: BehaviorTrackingResult(
        recorded: recordedCount,
        sessionId: request.sessionId ?? _generateSessionId(),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: await _userService.getUserMode(userId),
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '行為記錄失敗',
      statusCode: 500,
    );
  }
}
```

```dart
/**
 * 14. 取得模式優化建議 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
Future<ApiResponse<ModeRecommendationsData>> getModeRecommendations({
  required String userId,
}) async {
  try {
    // 檢查用戶權限
    final hasPermission = await _securityService.checkUserPermission(
      userId: userId,
      action: 'VIEW_RECOMMENDATIONS',
    );
    
    if (!hasPermission) {
      return ApiResponse.error(
        code: 'FORBIDDEN',
        message: '您沒有權限查看建議',
        statusCode: 403,
      );
    }

    // 分析用戶行為數據
    final behaviorData = await _behaviorService.getUserBehaviorAnalysis(userId);
    final currentMode = await _userService.getUserMode(userId);
    
    // 計算模式適合度評分
    final modeScore = await _behaviorService.calculateModeScore(
      userId: userId,
      currentMode: currentMode,
      behaviorData: behaviorData,
    );

    // 生成個人化建議
    final recommendations = await _behaviorService.generateRecommendations(
      userId: userId,
      currentMode: currentMode,
      behaviorData: behaviorData,
    );

    return ApiResponse.success(
      data: ModeRecommendationsData(
        currentModeScore: modeScore,
        recommendations: recommendations,
        analysisDate: DateTime.now(),
      ),
      metadata: ResponseMetadata(
        timestamp: DateTime.now(),
        userMode: currentMode,
      ),
    );
  } catch (e) {
    return ApiResponse.error(
      code: 'INTERNAL_SERVER_ERROR',
      message: '無法生成建議',
      statusCode: 500,
    );
  }
}
```

---

## 4. 資料模型設計

### 4.1 請求模型

```dart
/**
 * 15. 用戶資料更新請求模型 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UpdateProfileRequest {
  final String? displayName;
  final String? avatar;
  final String? language;
  final String? timezone;
  final String? theme;

  UpdateProfileRequest({
    this.displayName,
    this.avatar,
    this.language,
    this.timezone,
    this.theme,
  });

  Map<String, dynamic> toMap() {
    return {
      if (displayName != null) 'displayName': displayName,
      if (avatar != null) 'avatar': avatar,
      if (language != null) 'language': language,
      if (timezone != null) 'timezone': timezone,
      if (theme != null) 'theme': theme,
    };
  }

  factory UpdateProfileRequest.fromJson(Map<String, dynamic> json) {
    return UpdateProfileRequest(
      displayName: json['displayName'] as String?,
      avatar: json['avatar'] as String?,
      language: json['language'] as String?,
      timezone: json['timezone'] as String?,
      theme: json['theme'] as String?,
    );
  }
}
```

```dart
/**
 * 16. 評估提交請求模型 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class AssessmentSubmission {
  final String questionnaireId;
  final List<AssessmentAnswer> answers;
  final DateTime? completedAt;

  AssessmentSubmission({
    required this.questionnaireId,
    required this.answers,
    this.completedAt,
  });

  factory AssessmentSubmission.fromJson(Map<String, dynamic> json) {
    return AssessmentSubmission(
      questionnaireId: json['questionnaireId'] as String,
      answers: (json['answers'] as List)
          .map((answer) => AssessmentAnswer.fromJson(answer))
          .toList(),
      completedAt: json['completedAt'] != null 
          ? DateTime.parse(json['completedAt']) 
          : null,
    );
  }
}
```

### 4.2 回應模型

```dart
/**
 * 17. 用戶資料回應模型 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserProfileData {
  final String id;
  final String email;
  final String displayName;
  final String? avatar;
  final UserMode userMode;
  final DateTime createdAt;
  final DateTime lastLoginAt;
  final UserStatistics? statistics;
  final UserAchievements? achievements;
  final UserPreferences? preferences;
  final SecuritySettings? security;

  UserProfileData({
    required this.id,
    required this.email,
    required this.displayName,
    this.avatar,
    required this.userMode,
    required this.createdAt,
    required this.lastLoginAt,
    this.statistics,
    this.achievements,
    this.preferences,
    this.security,
  });

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'displayName': displayName,
      if (avatar != null) 'avatar': avatar,
      'userMode': userMode.name,
      'createdAt': createdAt.toIso8601String(),
      'lastLoginAt': lastLoginAt.toIso8601String(),
      if (statistics != null) 'statistics': statistics!.toJson(),
      if (achievements != null) 'achievements': achievements!.toJson(),
      if (preferences != null) 'preferences': preferences!.toJson(),
      if (security != null) 'security': security!.toJson(),
    };
  }
}
```

```dart
/**
 * 18. API統一回應模型 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class ApiResponse<T> {
  final bool success;
  final T? data;
  final ErrorInfo? error;
  final ResponseMetadata? metadata;

  ApiResponse._({
    required this.success,
    this.data,
    this.error,
    this.metadata,
  });

  factory ApiResponse.success({
    required T data,
    ResponseMetadata? metadata,
  }) {
    return ApiResponse._(
      success: true,
      data: data,
      metadata: metadata,
    );
  }

  factory ApiResponse.error({
    required String code,
    required String message,
    String? field,
    required int statusCode,
    Map<String, dynamic>? details,
  }) {
    return ApiResponse._(
      success: false,
      error: ErrorInfo(
        code: code,
        message: message,
        field: field,
        timestamp: DateTime.now(),
        requestId: _generateRequestId(),
        details: details ?? {},
      ),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'success': success,
      if (data != null) 'data': _dataToJson(data),
      if (error != null) 'error': error!.toJson(),
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  dynamic _dataToJson(T data) {
    if (data is Map) return data;
    if (data is List) return data;
    if (data is String || data is num || data is bool) return data;
    // 假設所有的資料模型都有 toJson 方法
    return (data as dynamic).toJson();
  }

  static String _generateRequestId() {
    return 'req-${DateTime.now().millisecondsSinceEpoch}-${(1000 + Random().nextInt(9000))}';
  }
}
```

---

## 5. API端點實作映射

### 5.1 端點對應表

| API端點 | Controller方法 | Service方法 | HTTP狀態碼 |
|---------|---------------|-------------|-----------|
| `GET /users/profile` | `getUserProfile()` | `UserService.getProfile()` | 200, 401, 500 |
| `PUT /users/profile` | `updateUserProfile()` | `UserService.updateProfile()` | 200, 400, 401 |
| `GET /users/assessment-questions` | `getAssessmentQuestions()` | `AssessmentService.getQuestions()` | 200, 401, 500 |
| `POST /users/assessment` | `submitAssessment()` | `AssessmentService.processAssessment()` | 200, 400, 401 |
| `PUT /users/preferences` | `updatePreferences()` | `UserService.updatePrefs()` | 200, 400, 401, 403, 500 |
| `PUT /users/security` | `updateSecuritySettings()` | `SecurityService.updateSettings()` | 200, 400, 401, 403, 422, 500 |
| `POST /users/verify-pin` | `verifyPin()` | `SecurityService.verifyPin()` | 200, 400, 401, 423 |
| `PUT /users/mode` | `changeUserMode()` | `UserService.changeMode()` | 200, 400, 401, 403, 422, 500 |
| `GET /users/mode-defaults` | `getModeDefaults()` | `ModeAdapter.getDefaults()` | 200, 400, 401, 404, 500 |
| `POST /users/behavior-tracking` | `recordBehaviorTracking()` | `BehaviorService.record()` | 200, 400, 401, 403, 500 |
| `GET /users/mode-recommendations` | `getModeRecommendations()` | `BehaviorService.getRecommendations()` | 200, 401, 403, 500 |

### 5.2 Controller路由配置

```dart
/**
 * 19. 路由配置器 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserRoutes {
  static void configureRoutes(Router router, UserController controller) {
    // GET /users/profile
    router.get('/users/profile', (Request request) async {
      final userId = request.getUserId();
      final userMode = request.getUserMode();
      
      final result = await controller.getUserProfile(
        userId: userId,
        userMode: userMode,
      );
      
      return result.toResponse();
    });

    // PUT /users/profile
    router.put('/users/profile', (Request request) async {
      final userId = request.getUserId();
      final userMode = request.getUserMode();
      final updateRequest = UpdateProfileRequest.fromJson(
        await request.readAsJson(),
      );
      
      final result = await controller.updateUserProfile(
        userId: userId,
        request: updateRequest,
        userMode: userMode,
      );
      
      return result.toResponse();
    });

    // 其他路由配置...
  }
}
```

---

## 6. 四模式差異化策略

### 6.1 UserModeAdapter 類別

```dart
/**
 * 20. 用戶模式適配器 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserModeAdapter {
  /**
   * 根據用戶模式適配個人資料回應
   */
  Future<UserProfileData> adaptUserProfile({
    required Map<String, dynamic> userDoc,
    required UserMode userMode,
  }) async {
    final baseData = UserProfileData.fromFirestore(userDoc);
    
    switch (userMode) {
      case UserMode.Expert:
        return baseData.copyWith(
          statistics: await _getDetailedStatistics(baseData.id),
          preferences: await _getFullPreferences(baseData.id),
          security: await _getSecuritySettings(baseData.id),
        );
        
      case UserMode.Inertial:
        return baseData.copyWith(
          statistics: await _getStandardStatistics(baseData.id),
          preferences: await _getBasicPreferences(baseData.id),
        );
        
      case UserMode.Cultivation:
        return baseData.copyWith(
          achievements: await _getAchievements(baseData.id),
          statistics: await _getGamifiedStatistics(baseData.id),
        );
        
      case UserMode.Guiding:
        return baseData; // 僅返回基本資料
    }
  }

  /**
   * 取得模式允許的可編輯欄位
   */
  List<String> getAllowedEditableFields(UserMode userMode) {
    switch (userMode) {
      case UserMode.Expert:
        return ['displayName', 'avatar', 'language', 'timezone', 'theme', 'dateFormat', 'currency'];
        
      case UserMode.Inertial:
        return ['displayName', 'avatar', 'language', 'theme'];
        
      case UserMode.Cultivation:
        return ['displayName', 'avatar', 'language', 'theme'];
        
      case UserMode.Guiding:
        return ['displayName', 'theme'];
    }
  }

  /**
   * 根據模式過濾偏好設定
   */
  UserPreferences filterPreferences({
    required UserPreferences preferences,
    required UserMode userMode,
  }) {
    switch (userMode) {
      case UserMode.Expert:
        return preferences; // 完整偏好設定
        
      case UserMode.Inertial:
        return preferences.copyWith(
          // 移除進階設定
          autoBackupEnabled: null,
          fiscalYearStart: null,
        );
        
      case UserMode.Cultivation:
        return preferences.copyWith(
          // 保留激勵相關設定
          gamification: preferences.gamification,
        );
        
      case UserMode.Guiding:
        return UserPreferences.minimal(
          currency: preferences.currency,
          language: preferences.language,
        );
    }
  }
}
```

### 6.2 模式特性定義

```dart
/**
 * 21. 模式特性數據類別 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class ModeCharacteristics {
  static const Map<UserMode, ModeInfo> characteristics = {
    UserMode.Expert: ModeInfo(
      name: 'Expert',
      description: '完整功能、專業工具、深度設定',
      features: ['完整功能控制', '詳細統計資料', '進階設定選項', '專業化報表'],
      uiComplexity: UIComplexity.Advanced,
      dataDepth: DataDepth.Complete,
    ),
    
    UserMode.Inertial: ModeInfo(
      name: 'Inertial',
      description: '標準功能、固定選項、穩定體驗',
      features: ['標準功能集', '基本統計資料', '預設設定', '簡潔介面'],
      uiComplexity: UIComplexity.Standard,
      dataDepth: DataDepth.Standard,
    ),
    
    UserMode.Cultivation: ModeInfo(
      name: 'Cultivation',
      description: '習慣培養、進度追蹤、激勵機制',
      features: ['成就系統', '進度追蹤', '習慣養成', '挑戰任務'],
      uiComplexity: UIComplexity.Guided,
      dataDepth: DataDepth.Motivational,
    ),
    
    UserMode.Guiding: ModeInfo(
      name: 'Guiding',
      description: '極簡操作、自動化配置、最少決策',
      features: ['極簡介面', '自動化設定', '基本操作', '智慧推薦'],
      uiComplexity: UIComplexity.Minimal,
      dataDepth: DataDepth.Essential,
    ),
  };

  static ModeInfo getCharacteristics(UserMode mode) {
    return characteristics[mode]!;
  }

  static List<String> getSuggestedFeatures(UserMode mode) {
    return characteristics[mode]!.features;
  }
}
```

---

## 7. 安全與驗證設計

### 7.1 SecurityService 類別

```dart
/**
 * 22. 安全服務 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class SecurityService {
  final EncryptionService _encryptionService;
  final FirestoreService _firestoreService;

  SecurityService({
    required EncryptionService encryptionService,
    required FirestoreService firestoreService,
  }) : _encryptionService = encryptionService,
       _firestoreService = firestoreService;

  /**
   * PIN碼加密
   */
  Future<String> encryptPin(String plainPin) async {
    final salt = _generateSalt();
    final hashedPin = await _encryptionService.hashPassword(plainPin, salt);
    return hashedPin;
  }

  /**
   * PIN碼驗證
   */
  Future<PinVerificationResult> verifyPin({
    required String userId,
    required String inputPin,
    required PinOperation operation,
  }) async {
    final storedPinData = await _firestoreService.getDocument(
      'user_security',
      userId,
    );

    if (storedPinData == null || storedPinData['pinHash'] == null) {
      return PinVerificationResult(isValid: false, reason: 'PIN not set');
    }

    final isValid = await _encryptionService.verifyPassword(
      inputPin,
      storedPinData['pinHash'],
    );

    return PinVerificationResult(
      isValid: isValid,
      reason: isValid ? 'PIN verified' : 'Invalid PIN',
    );
  }

  /**
   * 檢查PIN碼鎖定狀態
   */
  Future<PinLockStatus> getPinLockStatus(String userId) async {
    final lockData = await _firestoreService.getDocument(
      'user_pin_locks',
      userId,
    );

    if (lockData == null) {
      return PinLockStatus(isLocked: false);
    }

    final unlockAt = (lockData['unlockAt'] as Timestamp).toDate();
    final isLocked = DateTime.now().isBefore(unlockAt);

    return PinLockStatus(
      isLocked: isLocked,
      unlockAt: unlockAt,
    );
  }

  /**
   * 記錄失敗嘗試
   */
  Future<void> recordFailedAttempt(String userId) async {
    final attemptsDoc = await _firestoreService.getDocument(
      'user_pin_attempts',
      userId,
    );

    final currentAttempts = attemptsDoc?['failedAttempts'] ?? 0;
    final newAttempts = currentAttempts + 1;

    await _firestoreService.setDocument('user_pin_attempts', userId, {
      'failedAttempts': newAttempts,
      'lastAttemptAt': FieldValue.serverTimestamp(),
    });

    // 如果達到最大嘗試次數，鎖定PIN碼
    if (newAttempts >= 3) {
      await _lockPin(userId);
    }
  }

  /**
   * 鎖定PIN碼
   */
  Future<void> _lockPin(String userId) async {
    final unlockAt = DateTime.now().add(Duration(hours: 1));
    
    await _firestoreService.setDocument('user_pin_locks', userId, {
      'unlockAt': Timestamp.fromDate(unlockAt),
      'lockedAt': FieldValue.serverTimestamp(),
    });
  }

  String _generateSalt() {
    final random = Random.secure();
    final saltBytes = List<int>.generate(32, (i) => random.nextInt(256));
    return base64Encode(saltBytes);
  }
}
```

### 7.2 ValidationService 類別

```dart
/**
 * 23. 驗證服務 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class ValidationService {
  /**
   * 驗證個人資料更新
   */
  Future<ValidationResult> validateProfileUpdate(UpdateProfileRequest request) async {
    final errors = <ValidationError>[];

    // 驗證顯示名稱
    if (request.displayName != null) {
      if (request.displayName!.isEmpty) {
        errors.add(ValidationError(
          field: 'displayName',
          message: '顯示名稱不能為空',
          code: 'REQUIRED',
        ));
      } else if (request.displayName!.length > 50) {
        errors.add(ValidationError(
          field: 'displayName',
          message: '顯示名稱不能超過50個字元',
          code: 'MAX_LENGTH_EXCEEDED',
          value: request.displayName,
        ));
      }
    }

    // 驗證語言設定
    if (request.language != null) {
      const validLanguages = ['zh-TW', 'en-US'];
      if (!validLanguages.contains(request.language)) {
        errors.add(ValidationError(
          field: 'language',
          message: '不支援的語言設定',
          code: 'INVALID_VALUE',
          value: request.language,
        ));
      }
    }

    // 驗證主題設定
    if (request.theme != null) {
      const validThemes = ['light', 'dark', 'auto'];
      if (!validThemes.contains(request.theme)) {
        errors.add(ValidationError(
          field: 'theme',
          message: '不支援的主題設定',
          code: 'INVALID_VALUE',
          value: request.theme,
        ));
      }
    }

    return ValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      message: errors.isEmpty ? 'Validation passed' : '參數驗證失敗',
      field: errors.isNotEmpty ? errors.first.field : null,
    );
  }

  /**
   * 驗證偏好設定
   */
  Future<ValidationResult> validatePreferences(UserPreferences preferences) async {
    final errors = <ValidationError>[];

    // 驗證貨幣設定
    if (preferences.currency != null) {
      const validCurrencies = ['TWD', 'USD', 'CNY', 'JPY'];
      if (!validCurrencies.contains(preferences.currency)) {
        errors.add(ValidationError(
          field: 'currency',
          message: '不支援的貨幣類型',
          code: 'INVALID_CURRENCY',
        ));
      }
    }

    // 驗證日期格式
    if (preferences.dateFormat != null) {
      const validFormats = ['YYYY-MM-DD', 'DD/MM/YYYY', 'MM/DD/YYYY'];
      if (!validFormats.contains(preferences.dateFormat)) {
        errors.add(ValidationError(
          field: 'dateFormat',
          message: '不支援的日期格式',
          code: 'INVALID_FORMAT',
        ));
      }
    }

    return ValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      message: errors.isEmpty ? 'Validation passed' : '偏好設定驗證失敗',
    );
  }
}
```

---

## 8. 錯誤處理設計

### 8.1 ErrorInfo 類別

```dart
/**
 * 24. 錯誤資訊類別 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class ErrorInfo {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final String requestId;
  final Map<String, dynamic> details;

  ErrorInfo({
    required this.code,
    required this.message,
    this.field,
    required this.timestamp,
    required this.requestId,
    required this.details,
  });

  Map<String, dynamic> toJson() {
    return {
      'code': code,
      'message': message,
      if (field != null) 'field': field,
      'timestamp': timestamp.toIso8601String(),
      'requestId': requestId,
      'details': details,
    };
  }
}
```

### 8.2 錯誤碼常數定義

```dart
/**
 * 25. 錯誤碼常數 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class ErrorCodes {
  // 客戶端錯誤 (4xx)
  static const String VALIDATION_ERROR = 'VALIDATION_ERROR';
  static const String UNAUTHORIZED = 'UNAUTHORIZED';
  static const String INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS';
  static const String RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND';
  static const String DUPLICATE_RESOURCE = 'DUPLICATE_RESOURCE';
  static const String RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED';

  // 業務邏輯錯誤 (422)
  static const String BUSINESS_LOGIC_ERROR = 'BUSINESS_LOGIC_ERROR';
  static const String INVALID_PIN = 'INVALID_PIN';
  static const String PIN_LOCKED = 'PIN_LOCKED';
  static const String MODE_CHANGE_RESTRICTED = 'MODE_CHANGE_RESTRICTED';

  // 伺服器錯誤 (5xx)
  static const String INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR';
  static const String SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE';
  static const String TIMEOUT_ERROR = 'TIMEOUT_ERROR';
  static const String DATABASE_ERROR = 'DATABASE_ERROR';
  static const String EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR';

  // HTTP狀態碼映射
  static const Map<String, int> statusCodeMap = {
    VALIDATION_ERROR: 400,
    UNAUTHORIZED: 401,
    INSUFFICIENT_PERMISSIONS: 403,
    RESOURCE_NOT_FOUND: 404,
    DUPLICATE_RESOURCE: 409,
    BUSINESS_LOGIC_ERROR: 422,
    PIN_LOCKED: 423,
    INTERNAL_SERVER_ERROR: 500,
    SERVICE_UNAVAILABLE: 503,
  };

  static int getStatusCode(String errorCode) {
    return statusCodeMap[errorCode] ?? 500;
  }
}
```

---

## 9. 測試設計策略

### 9.1 單元測試結構

```dart
/**
 * 26. 用戶服務單元測試 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserServiceTest {
  /**
   * 測試取得用戶個人資料 - 成功案例
   */
  @Test('should return user profile successfully for Expert mode')
  void testGetUserProfile_Expert_Success() async {
    // Arrange
    final mockUserId = 'test-user-123';
    final mockUserMode = UserMode.Expert;
    final mockUserDoc = {
      'id': mockUserId,
      'email': 'test@example.com',
      'displayName': '測試用戶',
      'userMode': 'Expert',
      'createdAt': Timestamp.now(),
    };

    when(mockFirestoreService.getDocument('users', mockUserId))
        .thenAnswer((_) async => mockUserDoc);

    // Act
    final result = await userController.getUserProfile(
      userId: mockUserId,
      userMode: mockUserMode,
    );

    // Assert
    expect(result.success, isTrue);
    expect(result.data?.id, equals(mockUserId));
    expect(result.data?.userMode, equals(UserMode.Expert));
    verify(mockFirestoreService.getDocument('users', mockUserId)).called(1);
  }

  /**
   * 測試取得用戶個人資料 - 用戶不存在
   */
  @Test('should return 404 when user not found')
  void testGetUserProfile_UserNotFound() async {
    // Arrange
    final mockUserId = 'non-existent-user';
    
    when(mockFirestoreService.getDocument('users', mockUserId))
        .thenAnswer((_) async => null);

    // Act
    final result = await userController.getUserProfile(
      userId: mockUserId,
      userMode: UserMode.Expert,
    );

    // Assert
    expect(result.success, isFalse);
    expect(result.error?.code, equals('RESOURCE_NOT_FOUND'));
    expect(result.error?.message, equals('用戶不存在'));
  }

  /**
   * 測試PIN碼驗證 - 失敗案例
   */
  @Test('should handle PIN verification failure correctly')
  void testVerifyPin_FailureWithLockout() async {
    // Arrange
    final mockUserId = 'test-user-123';
    final wrongPin = '0000';
    
    when(mockSecurityService.verifyPin(
      userId: mockUserId,
      inputPin: wrongPin,
      operation: PinOperation.verify,
    )).thenAnswer((_) async => PinVerificationResult(isValid: false));

    when(mockSecurityService.getRemainingAttempts(mockUserId))
        .thenAnswer((_) async => 0);

    // Act
    final result = await userController.verifyPin(
      userId: mockUserId,
      pinCode: wrongPin,
      operation: PinOperation.verify,
    );

    // Assert
    expect(result.success, isFalse);
    expect(result.error?.code, equals('INVALID_PIN'));
    expect(result.error?.details?['remainingAttempts'], equals(0));
    expect(result.error?.details?['lockoutTime'], isNotNull);
  }
}
```

### 9.2 整合測試設計

```dart
/**
 * 27. 用戶管理整合測試 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserManagementIntegrationTest {
  /**
   * 測試完整的模式評估流程
   */
  @Test('should complete assessment flow successfully')
  void testCompleteAssessmentFlow() async {
    // 1. 取得評估問卷
    final questionsResponse = await userController.getAssessmentQuestions();
    expect(questionsResponse.success, isTrue);
    
    final questionnaire = questionsResponse.data!.questionnaire;
    expect(questionnaire.questions.length, equals(5));

    // 2. 提交評估答案
    final submission = AssessmentSubmission(
      questionnaireId: questionnaire.id,
      answers: [
        AssessmentAnswer(questionId: 1, selectedOptions: ['A']),
        AssessmentAnswer(questionId: 2, selectedOptions: ['C']),
        AssessmentAnswer(questionId: 3, selectedOptions: ['B']),
        AssessmentAnswer(questionId: 4, selectedOptions: ['A']),
        AssessmentAnswer(questionId: 5, selectedOptions: ['D']),
      ],
    );

    final assessmentResponse = await userController.submitAssessment(
      userId: 'test-user-123',
      submission: submission,
    );

    expect(assessmentResponse.success, isTrue);
    expect(assessmentResponse.data!.result.recommendedMode, equals(UserMode.Expert));
    expect(assessmentResponse.data!.applied, isTrue);

    // 3. 驗證用戶模式已更新
    final profileResponse = await userController.getUserProfile(
      userId: 'test-user-123',
      userMode: UserMode.Expert,
    );

    expect(profileResponse.success, isTrue);
    expect(profileResponse.data!.userMode, equals(UserMode.Expert));
  }

  /**
   * 測試四模式差異化回應
   */
  @Test('should return different data based on user mode')
  void testFourModeAdaptation() async {
    final userId = 'test-user-123';

    // Expert Mode - 應返回完整資料
    final expertResponse = await userController.getUserProfile(
      userId: userId,
      userMode: UserMode.Expert,
    );
    expect(expertResponse.data?.statistics, isNotNull);
    expect(expertResponse.data?.preferences, isNotNull);
    expect(expertResponse.data?.security, isNotNull);

    // Guiding Mode - 應返回極簡資料
    final guidingResponse = await userController.getUserProfile(
      userId: userId,
      userMode: UserMode.Guiding,
    );
    expect(guidingResponse.data?.statistics, isNull);
    expect(guidingResponse.data?.preferences, isNull);

    // Cultivation Mode - 應返回成就資料
    final cultivationResponse = await userController.getUserProfile(
      userId: userId,
      userMode: UserMode.Cultivation,
    );
    expect(cultivationResponse.data?.achievements, isNotNull);
  }
}
```

### 9.3 性能測試規格

```dart
/**
 * 28. 性能測試規格 (完全符合8088規範第5.3節)
 * @version 2025-09-02-V1.0.0
 * @date 2025-09-02 12:00:00
 * @update: 初版建立，完全符合8088規範第5.3節HTTP狀態碼標準
 */
class UserServicePerformanceTest {
  /**
   * 測試API回應時間
   */
  @Test('should respond within acceptable time limits')
  void testApiResponseTime() async {
    final stopwatch = Stopwatch()..start();
    
    final result = await userController.getUserProfile(
      userId: 'test-user-123',
      userMode: UserMode.Expert,
    );
    
    stopwatch.stop();
    
    expect(result.success, isTrue);
    expect(stopwatch.elapsedMilliseconds, lessThan(500)); // 500ms以內
  }

  /**
   * 測試併發請求處理
   */
  @Test('should handle concurrent requests correctly')
  void testConcurrentRequests() async {
    final futures = List.generate(10, (index) => 
      userController.getUserProfile(
        userId: 'test-user-$index',
        userMode: UserMode.Expert,
      )
    );

    final results = await Future.wait(futures);
    
    expect(results.length, equals(10));
    expect(results.every((result) => result.success), isTrue);
  }
}
```

---

## 附錄A：完整類別依賴圖

```
UserController
    ├─ UserService
    │   ├─ FirestoreService
    │   ├─ ValidationService
    │   └─ EncryptionService
    ├─ AssessmentService
    │   ├─ QuestionnaireRepository
    │   └─ ModeCalculationEngine
    ├─ SecurityService
    │   ├─ EncryptionService
    │   └─ FirestoreService
    ├─ UserModeAdapter
    │   └─ ModeCharacteristics
    └─ BehaviorTrackingService
        ├─ FirestoreService
        └─ AnalyticsEngine
```

## 附錄B：HTTP狀態碼使用指南

| API函數 | 成功狀態碼 | 錯誤狀態碼 | 說明 |
|---------|-----------|-----------|------|
| `getUserProfile()` | 200 | 401, 404, 500 | 查詢成功/未授權/不存在/伺服器錯誤 |
| `updateUserProfile()` | 200 | 400, 401, 500 | 更新成功/參數錯誤/未授權/伺服器錯誤 |
| `submitAssessment()` | 200 | 400, 401, 500 | 評估成功/參數錯誤/未授權/伺服器錯誤 |
| `updateSecuritySettings()` | 200 | 400, 401, 403, 422, 500 | 更新成功/參數錯誤/未授權/權限不足/業務邏輯錯誤/伺服器錯誤 |
| `verifyPin()` | 200 | 400, 401, 423 | 驗證成功/參數錯誤/未授權/PIN碼鎖定 |

---

**文件版本**: 1.0.0  
**建立日期**: 2025-09-02  
**維護者**: LCAS SA Team  
**審核狀態**: 待審核
