
# LCAS 2.0 認證服務 API - Low Level Design (LLD)

## 版本資訊
- 文件版本: 2.0.0
- API 版本: 1.1.0
- 日期: 2025-01-27
- 作者: LCAS 開發團隊

---

## 目錄
1. 簡介
2. 架構設計
3. 模組與類別設計
4. API 設計規格
5. 資料模型設計
6. 安全與驗證設計
7. 錯誤處理設計
8. 日誌與監控設計
9. 測試設計策略

---

## 1. 簡介

### 1.1 設計目的與範圍
認證服務 API 提供 LCAS 2.0 系統的完整認證功能，採用 **Dart** 語言實作客戶端 API 介面。本文件定義系統架構、類別設計、方法規格及互動關係，專注於設計規格而非實作細節。

### 1.2 核心功能模組
- **使用者認證模組**：註冊、登入、登出處理
- **密碼管理模組**：忘記密碼、重設密碼、密碼驗證
- **Token 管理模組**：JWT 生成、驗證、刷新機制
- **OAuth 整合模組**：Google OAuth 登入處理
- **跨平台綁定模組**：LINE 帳號綁定與狀態管理
- **Email 驗證模組**：註冊驗證、地址驗證流程

### 1.3 四模式支援策略
本設計支援四種使用者模式的差異化體驗：
- **Expert**：完整認證選項、詳細安全資訊、進階設定功能
- **Inertial**：標準認證流程、基本安全提示、固定選項配置
- **Cultivation**：引導式認證、安全教育內容、進度追蹤機制
- **Guiding**：極簡認證流程、最少必要步驟、簡化操作介面

---

## 2. 架構設計

### 2.1 系統分層架構
```
┌─────────────────────────────────────────┐
│            API Controller Layer         │
│         (AuthController)                │
├─────────────────────────────────────────┤
│            Service Layer                │
│  ┌─────────────┬─────────────┬────────┐ │
│  │ AuthService │OAuthService │BindSvc │ │
│  └─────────────┴─────────────┴────────┘ │
├─────────────────────────────────────────┤
│            Utility Layer                │
│  ┌─────────────┬─────────────────────┐  │
│  │ TokenSvc    │ UserModeAdapter     │  │
│  └─────────────┴─────────────────────┘  │
├─────────────────────────────────────────┤
│            Data Access Layer            │
│         (Repository Pattern)            │
└─────────────────────────────────────────┘
```

### 2.2 模組間依賴關係
- **AuthController** → **AuthService, OAuthService, BindingService**
- **AuthService** → **TokenService, UserRepository, EmailService**
- **OAuthService** → **TokenService, GoogleOAuthProvider**
- **BindingService** → **LineAPIClient, BindingRepository**
- **所有服務** → **UserModeAdapter** (四模式支援)

### 2.3 外部服務整合點
- **Google OAuth 2.0**：第三方登入驗證服務
- **LINE API**：帳號綁定與狀態查詢服務
- **Email Service**：驗證信發送服務
- **Firestore**：使用者資料儲存服務

---

## 3. 模組與類別設計

### 3.1 AuthController 類別設計

#### 3.1.1 類別職責
統一處理所有認證相關的API請求，協調各服務模組完成業務邏輯，統一回應格式與錯誤處理，實作四模式差異化邏輯。

#### 3.1.2 方法簽名規格

```dart
class AuthController {
  // 核心認證方法
  Future<ApiResponse<RegisterResponse>> register(RegisterRequest request);
  Future<ApiResponse<LoginResponse>> login(LoginRequest request);
  Future<ApiResponse<void>> logout(LogoutRequest request);
  Future<ApiResponse<RefreshTokenResponse>> refreshToken(String refreshToken);
  
  // 密碼管理方法
  Future<ApiResponse<void>> forgotPassword(ForgotPasswordRequest request);
  Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String token);
  Future<ApiResponse<void>> resetPassword(ResetPasswordRequest request);
  
  // Email驗證方法
  Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest request);
  
  // OAuth方法
  Future<ApiResponse<LoginResponse>> googleLogin(GoogleLoginRequest request);
  
  // 跨平台綁定方法
  Future<ApiResponse<BindingResponse>> bindLine(BindLineRequest request);
  Future<ApiResponse<BindingStatusResponse>> getBindStatus();
  
  // 內部輔助方法
  ApiResponse<T> _adaptResponse<T>(T data, UserMode userMode);
  void _logAuthEvent(String event, Map<String, dynamic> details);
  bool _validateRequest(dynamic request);
}
```

#### 3.1.3 錯誤處理策略設計
- 統一捕獲並轉換服務層異常
- 實作重試機制處理網路異常
- 記錄詳細錯誤日誌供除錯使用
- 四模式差異化錯誤訊息

### 3.2 AuthService 類別設計

#### 3.2.1 類別職責
實作核心認證業務邏輯，管理使用者生命週期，整合Token服務與資料層。

#### 3.2.2 方法簽名規格

```dart
class AuthService {
  // 使用者管理核心方法
  Future<RegisterResponse> registerUser(RegisterRequest request);
  Future<LoginResponse> authenticateUser(String email, String password);
  Future<void> logoutUser(LogoutRequest request);
  Future<RefreshTokenResponse> refreshToken(String refreshToken);
  
  // 密碼管理核心方法
  Future<void> sendPasswordResetEmail(String email);
  Future<VerifyResetTokenResponse> verifyResetToken(String token);
  Future<void> resetPassword(String token, String newPassword);
  
  // Email驗證核心方法
  Future<void> verifyEmail(String email, String code);
  Future<void> sendVerificationEmail(String email);
  
  // 內部業務邏輯方法
  Future<bool> _validateUserCredentials(String email, String password);
  Future<UserEntity> _createUser(RegisterRequest request);
  Future<void> _updateLastLoginTime(String userId);
  bool _isAccountLocked(String userId);
  void _incrementFailedAttempts(String userId);
  void _resetFailedAttempts(String userId);
}
```

### 3.3 TokenService 類別設計

#### 3.3.1 類別職責
管理JWT Token的生成、驗證、刷新和撤銷，處理Token生命週期管理。

#### 3.3.2 方法簽名規格

```dart
class TokenService {
  // Token生成方法
  Future<TokenPair> generateTokenPair(String userId, UserMode userMode);
  Future<String> generateAccessToken(String userId, Map<String, dynamic> claims);
  Future<String> generateRefreshToken(String userId);
  Future<String> generateResetToken(String email);
  Future<String> generateEmailVerificationToken(String email);
  
  // Token驗證方法
  Future<TokenValidationResult> validateAccessToken(String token);
  Future<TokenValidationResult> validateRefreshToken(String token);
  Future<bool> validateResetToken(String token);
  Future<bool> validateEmailVerificationToken(String token);
  
  // Token管理方法
  Future<void> revokeToken(String token);
  Future<void> revokeAllTokensForUser(String userId);
  Future<bool> isTokenRevoked(String token);
  
  // 內部方法
  Map<String, dynamic> _extractClaims(String token);
  bool _isTokenExpired(String token);
  String _generateSecureToken();
}
```

### 3.4 UserModeAdapter 類別設計

#### 3.4.1 類別職責
根據使用者模式調整API回應內容，過濾不適合的功能選項，提供模式特定的使用者體驗。

#### 3.4.2 方法簽名規格

```dart
class UserModeAdapter {
  // 核心適配方法
  T adaptResponse<T>(T response, UserMode userMode);
  
  // 具體回應適配方法
  LoginResponse adaptLoginResponse(LoginResponse response, UserMode userMode);
  RegisterResponse adaptRegisterResponse(RegisterResponse response, UserMode userMode);
  ApiError adaptErrorResponse(ApiError error, UserMode userMode);
  
  // 功能選項過濾方法
  List<String> getAvailableActions(UserMode userMode);
  Map<String, dynamic> filterData(Map<String, dynamic> data, UserMode userMode);
  
  // 模式特性方法
  bool shouldShowAdvancedOptions(UserMode userMode);
  bool shouldIncludeProgressTracking(UserMode userMode);
  bool shouldSimplifyInterface(UserMode userMode);
  String getModeSpecificMessage(String baseMessage, UserMode userMode);
}
```

### 3.5 統一回應格式設計

#### 3.5.1 ApiResponse 類別規格

```dart
class ApiResponse<T> {
  final bool success;
  final T? data;
  final ApiMetadata metadata;
  final ApiError? error;
  
  ApiResponse.success({
    required this.data,
    required this.metadata,
  }) : success = true, error = null;
  
  ApiResponse.error({
    required this.error,
    required this.metadata,
  }) : success = false, data = null;
  
  // 工廠方法
  static ApiResponse<T> createSuccess<T>(T data, ApiMetadata metadata);
  static ApiResponse<T> createError<T>(ApiError error, ApiMetadata metadata);
}
```

#### 3.5.2 ApiMetadata 類別規格

```dart
class ApiMetadata {
  final DateTime timestamp;
  final String requestId;
  final UserMode? userMode;
  
  ApiMetadata({
    required this.timestamp,
    required this.requestId,
    this.userMode,
  });
  
  // 工廠方法
  static ApiMetadata create(UserMode? userMode);
  static ApiMetadata createWithRequestId(String requestId, UserMode? userMode);
  
  // 轉換方法
  Map<String, dynamic> toJson();
  static ApiMetadata fromJson(Map<String, dynamic> json);
}
```

### 3.6 例外處理類別設計

#### 3.6.1 LCASException 階層設計

```dart
abstract class LCASException implements Exception {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final Map<String, dynamic>? details;
  
  LCASException({
    required this.code,
    required this.message,
    this.field,
    DateTime? timestamp,
    this.details,
  }) : timestamp = timestamp ?? DateTime.now();
  
  // 抽象方法
  int get httpStatusCode;
  Map<String, dynamic> toJson();
}

class ValidationException extends LCASException {
  final List<ValidationError> validationErrors;
  
  ValidationException({
    required String code,
    required String message,
    String? field,
    this.validationErrors = const [],
    Map<String, dynamic>? details,
  }) : super(code: code, message: message, field: field, details: details);
  
  @override
  int get httpStatusCode => 400;
}

class AuthException extends LCASException {
  final DateTime? unlockAt;
  
  AuthException({
    required String code,
    required String message,
    String? field,
    this.unlockAt,
    Map<String, dynamic>? details,
  }) : super(code: code, message: message, field: field, details: details);
  
  @override
  int get httpStatusCode => code == 'ACCOUNT_LOCKED' ? 423 : 401;
}

class BusinessLogicException extends LCASException {
  BusinessLogicException({
    required String code,
    required String message,
    String? field,
    Map<String, dynamic>? details,
  }) : super(code: code, message: message, field: field, details: details);
  
  @override
  int get httpStatusCode => 422;
}

class InternalServerException extends LCASException {
  InternalServerException({
    required String code,
    required String message,
    Map<String, dynamic>? details,
  }) : super(code: code, message: message, details: details);
  
  @override
  int get httpStatusCode => 500;
}
```

---

## 4. API 設計規格

### 4.1 API 端點設計總覽

本節定義認證服務的所有 API 端點的設計規格，嚴格遵循 8020. API list.md 和 8088. API設計規範.md 的規範。

| 端點 | HTTP 方法 | 函數簽名 | 功能描述 |
|------|----------|----------|----------|
| `/auth/register` | POST | `Future<ApiResponse<RegisterResponse>> register(RegisterRequest)` | 使用者註冊處理 |
| `/auth/login` | POST | `Future<ApiResponse<LoginResponse>> login(LoginRequest)` | 使用者登入處理 |
| `/auth/google-login` | POST | `Future<ApiResponse<LoginResponse>> googleLogin(GoogleLoginRequest)` | Google OAuth 登入 |
| `/auth/logout` | POST | `Future<ApiResponse<void>> logout(LogoutRequest)` | 使用者登出處理 |
| `/auth/refresh` | POST | `Future<ApiResponse<RefreshTokenResponse>> refreshToken(String)` | 刷新 Token |
| `/auth/forgot-password` | POST | `Future<ApiResponse<void>> forgotPassword(ForgotPasswordRequest)` | 忘記密碼處理 |
| `/auth/verify-reset-token` | GET | `Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String)` | 驗證重設連結 |
| `/auth/reset-password` | POST | `Future<ApiResponse<void>> resetPassword(ResetPasswordRequest)` | 重設密碼處理 |
| `/auth/verify-email` | POST | `Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest)` | 驗證 Email 地址 |
| `/auth/bind-line` | POST | `Future<ApiResponse<BindingResponse>> bindLine(BindLineRequest)` | LINE 綁定處理 |
| `/auth/bind-status` | GET | `Future<ApiResponse<BindingStatusResponse>> getBindStatus()` | 綁定狀態查詢 |

### 4.2 請求資料模型設計

#### 4.2.1 RegisterRequest 類別規格

```dart
class RegisterRequest {
  final String email;
  final String password;
  final String? confirmPassword;
  final String? displayName;
  final UserMode userMode;
  final bool acceptTerms;
  final bool acceptPrivacy;
  final String? timezone;
  final String? language;
  
  RegisterRequest({
    required this.email,
    required this.password,
    this.confirmPassword,
    this.displayName,
    required this.userMode,
    required this.acceptTerms,
    required this.acceptPrivacy,
    this.timezone,
    this.language,
  });
  
  // 驗證方法
  List<ValidationError> validate();
  
  // 轉換方法
  Map<String, dynamic> toJson();
  static RegisterRequest fromJson(Map<String, dynamic> json);
}
```

#### 4.2.2 LoginRequest 類別規格

```dart
class LoginRequest {
  final String email;
  final String password;
  final bool rememberMe;
  final DeviceInfo? deviceInfo;
  
  LoginRequest({
    required this.email,
    required this.password,
    this.rememberMe = false,
    this.deviceInfo,
  });
  
  List<ValidationError> validate();
  Map<String, dynamic> toJson();
  static LoginRequest fromJson(Map<String, dynamic> json);
}
```

### 4.3 回應資料模型設計

#### 4.3.1 RegisterResponse 類別規格

```dart
class RegisterResponse {
  final String userId;
  final String email;
  final UserMode userMode;
  final bool verificationSent;
  final bool needsAssessment;
  final String token;
  final String refreshToken;
  final DateTime expiresAt;
  
  RegisterResponse({
    required this.userId,
    required this.email,
    required this.userMode,
    required this.verificationSent,
    required this.needsAssessment,
    required this.token,
    required this.refreshToken,
    required this.expiresAt,
  });
  
  Map<String, dynamic> toJson();
  static RegisterResponse fromJson(Map<String, dynamic> json);
}
```

#### 4.3.2 LoginResponse 類別規格

```dart
class LoginResponse {
  final String token;
  final String refreshToken;
  final DateTime expiresAt;
  final UserProfile user;
  final LoginHistory? loginHistory;
  final StreakInfo? streakInfo;
  final String? simpleMessage;
  
  LoginResponse({
    required this.token,
    required this.refreshToken,
    required this.expiresAt,
    required this.user,
    this.loginHistory,
    this.streakInfo,
    this.simpleMessage,
  });
  
  Map<String, dynamic> toJson();
  static LoginResponse fromJson(Map<String, dynamic> json);
}
```

### 4.4 四模式差異化設計規格

#### 4.4.1 模式適配規則

```dart
abstract class ModeAdaptationRule<T> {
  T adapt(T original, UserMode userMode);
  bool shouldIncludeField(String fieldName, UserMode userMode);
  String adaptMessage(String original, UserMode userMode);
}

class LoginResponseAdaptationRule extends ModeAdaptationRule<LoginResponse> {
  @override
  LoginResponse adapt(LoginResponse original, UserMode userMode) {
    switch (userMode) {
      case UserMode.expert:
        return _adaptForExpert(original);
      case UserMode.inertial:
        return _adaptForInertial(original);
      case UserMode.cultivation:
        return _adaptForCultivation(original);
      case UserMode.guiding:
        return _adaptForGuiding(original);
    }
  }
  
  LoginResponse _adaptForExpert(LoginResponse original);
  LoginResponse _adaptForInertial(LoginResponse original);
  LoginResponse _adaptForCultivation(LoginResponse original);
  LoginResponse _adaptForGuiding(LoginResponse original);
}
```

#### 4.4.2 模式差異化矩陣

| 功能 | Expert | Inertial | Cultivation | Guiding |
|------|--------|----------|-------------|---------|
| 登入歷史 | 完整顯示 | 簡要顯示 | 不顯示 | 不顯示 |
| 安全資訊 | 詳細顯示 | 基本顯示 | 教育性顯示 | 不顯示 |
| 進階設定 | 全部可用 | 部分可用 | 引導式 | 不可用 |
| 錯誤訊息 | 技術詳細 | 使用者友善 | 引導式說明 | 極簡提示 |

---

## 5. 資料模型設計

### 5.1 Firestore Collection 結構設計

#### 5.1.1 Users Collection 資料模型

```dart
class UserEntity {
  final String id;
  final String email;
  final String passwordHash;
  final String? displayName;
  final UserMode userMode;
  final bool emailVerified;
  final AccountStatus status;
  final AuthProvider authProvider;
  final UserPreferences preferences;
  final SecuritySettings security;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastActiveAt;
  
  UserEntity({
    required this.id,
    required this.email,
    required this.passwordHash,
    this.displayName,
    required this.userMode,
    required this.emailVerified,
    required this.status,
    required this.authProvider,
    required this.preferences,
    required this.security,
    required this.createdAt,
    required this.updatedAt,
    this.lastActiveAt,
  });
  
  // 轉換方法
  Map<String, dynamic> toFirestore();
  static UserEntity fromFirestore(Map<String, dynamic> data, String id);
  
  // 業務方法
  bool isActive();
  bool isLocked();
  bool canLogin();
  UserEntity updateLastActive();
}
```

#### 5.1.2 PasswordResetTokens Collection 資料模型

```dart
class PasswordResetTokenEntity {
  final String id;
  final String email;
  final String tokenHash;
  final DateTime createdAt;
  final DateTime expiresAt;
  final bool used;
  final DateTime? usedAt;
  
  PasswordResetTokenEntity({
    required this.id,
    required this.email,
    required this.tokenHash,
    required this.createdAt,
    required this.expiresAt,
    required this.used,
    this.usedAt,
  });
  
  Map<String, dynamic> toFirestore();
  static PasswordResetTokenEntity fromFirestore(Map<String, dynamic> data, String id);
  
  bool isValid();
  bool isExpired();
  PasswordResetTokenEntity markAsUsed();
}
```

### 5.2 資料存取層設計

#### 5.2.1 UserRepository 介面規格

```dart
abstract class UserRepository {
  Future<UserEntity?> findByEmail(String email);
  Future<UserEntity?> findById(String id);
  Future<UserEntity> create(UserEntity user);
  Future<UserEntity> update(UserEntity user);
  Future<void> delete(String id);
  Future<bool> emailExists(String email);
  Future<List<UserEntity>> findByStatus(AccountStatus status);
  Future<UserEntity?> findByProvider(AuthProvider provider, String providerId);
}
```

#### 5.2.2 TokenRepository 介面規格

```dart
abstract class TokenRepository {
  Future<void> storeRefreshToken(String token, String userId, DateTime expiresAt);
  Future<bool> isRefreshTokenValid(String token);
  Future<void> revokeRefreshToken(String token);
  Future<void> revokeAllTokensForUser(String userId);
  Future<void> cleanupExpiredTokens();
}
```

---

## 6. 安全與驗證設計

### 6.1 JWT Token 處理設計

#### 6.1.1 Token 生成策略

```dart
class JWTTokenGenerator {
  final String secretKey;
  final Duration accessTokenLifetime;
  final Duration refreshTokenLifetime;
  
  JWTTokenGenerator({
    required this.secretKey,
    this.accessTokenLifetime = const Duration(hours: 1),
    this.refreshTokenLifetime = const Duration(days: 30),
  });
  
  Future<String> generateAccessToken(String userId, UserMode userMode);
  Future<String> generateRefreshToken(String userId);
  Future<Map<String, dynamic>> verifyToken(String token);
  bool isTokenExpired(String token);
}
```

#### 6.1.2 Token 驗證流程

```dart
class TokenValidator {
  Future<TokenValidationResult> validateAccessToken(String token);
  Future<TokenValidationResult> validateRefreshToken(String token);
  Future<bool> isTokenBlacklisted(String token);
  
  TokenValidationResult _validateSignature(String token);
  TokenValidationResult _validateExpiration(String token);
  TokenValidationResult _validateClaims(Map<String, dynamic> claims);
}
```

### 6.2 密碼安全設計

#### 6.2.1 密碼加密服務

```dart
class PasswordSecurityService {
  final int saltRounds;
  
  PasswordSecurityService({this.saltRounds = 12});
  
  Future<String> hashPassword(String password);
  Future<bool> verifyPassword(String password, String hash);
  PasswordStrength assessPasswordStrength(String password);
  bool isPasswordInBlacklist(String password);
}
```

#### 6.2.2 帳號安全機制

```dart
class AccountSecurityService {
  final int maxFailedAttempts;
  final Duration lockoutDuration;
  
  AccountSecurityService({
    this.maxFailedAttempts = 5,
    this.lockoutDuration = const Duration(minutes: 15),
  });
  
  Future<void> recordFailedAttempt(String userId);
  Future<void> resetFailedAttempts(String userId);
  Future<bool> isAccountLocked(String userId);
  Future<DateTime?> getLockoutExpiry(String userId);
  Future<void> lockAccount(String userId, Duration duration);
}
```

---

## 7. 錯誤處理設計

### 7.1 錯誤碼分類體系

#### 7.1.1 認證服務錯誤碼枚舉

```dart
enum AuthErrorCode {
  // 驗證錯誤 (400)
  validationError,
  invalidEmail,
  weakPassword,
  passwordMismatch,
  
  // 認證錯誤 (401)
  unauthorized,
  invalidCredentials,
  tokenExpired,
  tokenInvalid,
  
  // 權限錯誤 (403)
  insufficientPermissions,
  accountDisabled,
  
  // 資源錯誤 (404, 409)
  userNotFound,
  emailAlreadyExists,
  invalidResetToken,
  verificationCodeNotFound,
  
  // 帳號狀態錯誤 (423)
  accountLocked,
  accountSuspended,
  
  // 業務邏輯錯誤 (422)
  emailNotVerified,
  resetTokenUsed,
  verificationCodeExpired,
  
  // 系統錯誤 (500)
  internalServerError,
  externalServiceError,
  databaseError;
  
  int get httpStatusCode {
    switch (this) {
      case validationError:
      case invalidEmail:
      case weakPassword:
      case passwordMismatch:
        return 400;
      case unauthorized:
      case invalidCredentials:
      case tokenExpired:
      case tokenInvalid:
        return 401;
      case insufficientPermissions:
      case accountDisabled:
        return 403;
      case userNotFound:
      case invalidResetToken:
      case verificationCodeNotFound:
        return 404;
      case emailAlreadyExists:
        return 409;
      case emailNotVerified:
      case resetTokenUsed:
      case verificationCodeExpired:
        return 422;
      case accountLocked:
      case accountSuspended:
        return 423;
      case internalServerError:
      case externalServiceError:
      case databaseError:
        return 500;
    }
  }
}
```

### 7.2 錯誤處理服務設計

#### 7.2.1 ErrorHandler 類別規格

```dart
class ErrorHandler {
  ApiResponse<T> handleException<T>(Exception exception, UserMode? userMode);
  ApiError createError(AuthErrorCode code, String? field, {Map<String, dynamic>? details});
  ApiError adaptErrorForMode(ApiError error, UserMode userMode);
  
  String _getErrorMessage(AuthErrorCode code, UserMode userMode);
  bool _shouldIncludeDetails(AuthErrorCode code, UserMode userMode);
}
```

### 7.3 錯誤回復策略設計

#### 7.3.1 RetryStrategy 類別規格

```dart
class RetryStrategy {
  final int maxRetries;
  final Duration baseDelay;
  final double backoffFactor;
  
  RetryStrategy({
    this.maxRetries = 3,
    this.baseDelay = const Duration(seconds: 1),
    this.backoffFactor = 2.0,
  });
  
  Future<T> executeWithRetry<T>(Future<T> Function() operation);
  bool shouldRetry(Exception exception, int attemptNumber);
  Duration calculateDelay(int attemptNumber);
}
```

---

## 8. 日誌與監控設計

### 8.1 日誌記錄策略

#### 8.1.1 AuthLogger 類別設計

```dart
class AuthLogger {
  void logAuthenticationAttempt(String email, bool success, {String? reason});
  void logRegistration(String userId, UserMode userMode);
  void logPasswordReset(String email, bool success);
  void logTokenRefresh(String userId, bool success);
  void logAccountLockout(String userId, Duration lockoutDuration);
  void logSecurityEvent(SecurityEventType type, String userId, Map<String, dynamic> details);
  
  LogEntry _createLogEntry(LogLevel level, String event, Map<String, dynamic> data);
  void _writeLog(LogEntry entry);
}
```

#### 8.1.2 日誌資料模型

```dart
class LogEntry {
  final DateTime timestamp;
  final LogLevel level;
  final String category;
  final String event;
  final String? userId;
  final String? email;
  final String? ipAddress;
  final String? userAgent;
  final String requestId;
  final Map<String, dynamic> details;
  
  LogEntry({
    required this.timestamp,
    required this.level,
    required this.category,
    required this.event,
    this.userId,
    this.email,
    this.ipAddress,
    this.userAgent,
    required this.requestId,
    required this.details,
  });
  
  Map<String, dynamic> toJson();
  static LogEntry fromJson(Map<String, dynamic> json);
}
```

### 8.2 效能監控設計

#### 8.2.1 PerformanceMonitor 類別設計

```dart
class PerformanceMonitor {
  void startOperation(String operationName, String requestId);
  void endOperation(String operationName, String requestId);
  void recordMetric(String metricName, double value);
  PerformanceReport generateReport(Duration period);
  
  Map<String, PerformanceMetric> _activeOperations;
  List<PerformanceRecord> _performanceHistory;
}
```

#### 8.2.2 監控指標定義

```dart
class PerformanceMetric {
  final String name;
  final double averageResponseTime;
  final double maxResponseTime;
  final double minResponseTime;
  final int totalRequests;
  final int successfulRequests;
  final double errorRate;
  
  PerformanceMetric({
    required this.name,
    required this.averageResponseTime,
    required this.maxResponseTime,
    required this.minResponseTime,
    required this.totalRequests,
    required this.successfulRequests,
    required this.errorRate,
  });
  
  bool isWithinThreshold(PerformanceThreshold threshold);
  Map<String, dynamic> toJson();
}
```

---

## 9. 測試設計策略

### 9.1 測試層級設計

#### 9.1.1 單元測試設計策略

```dart
abstract class AuthServiceTestSuite {
  // 測試方法簽名
  void testRegisterUser_ValidInput_ShouldReturnSuccess();
  void testRegisterUser_DuplicateEmail_ShouldThrowException();
  void testRegisterUser_WeakPassword_ShouldThrowValidationException();
  void testLoginUser_ValidCredentials_ShouldReturnTokens();
  void testLoginUser_InvalidCredentials_ShouldThrowAuthException();
  void testLoginUser_LockedAccount_ShouldThrowAccountLockedException();
  
  // 測試輔助方法
  RegisterRequest createValidRegisterRequest();
  RegisterRequest createInvalidRegisterRequest();
  void mockUserRepository();
  void mockTokenService();
}
```

#### 9.1.2 整合測試設計策略

```dart
abstract class AuthControllerIntegrationTest {
  void testCompleteRegistrationFlow();
  void testPasswordResetFlow();
  void testFourModeResponseDifferences();
  void testErrorHandlingFlow();
  void testSecurityMechanisms();
  
  void setupTestEnvironment();
  void cleanupTestData();
  void assertResponseFormat(ApiResponse response);
}
```

### 9.2 四模式測試設計

#### 9.2.1 模式差異化測試策略

```dart
class UserModeTestSuite {
  void testExpertModeResponse();
  void testInertialModeResponse();
  void testCultivationModeResponse();
  void testGuidingModeResponse();
  
  void assertExpertModeFeatures(dynamic response);
  void assertCultivationModeFeatures(dynamic response);
  void assertGuidingModeSimplicity(dynamic response);
  
  TestScenario createModeTestScenario(UserMode mode);
}
```

### 9.3 安全測試設計

#### 9.3.1 安全測試策略

```dart
abstract class SecurityTestSuite {
  void testPasswordBruteForceProtection();
  void testTokenTampering();
  void testSQLInjectionPrevention();
  void testXSSPrevention();
  void testRateLimiting();
  void testSessionManagement();
  
  void simulateBruteForceAttack();
  void attemptTokenManipulation();
  void testInputSanitization();
}
```

---

## 附錄

### A. 資料類型定義

#### A.1 枚舉類型定義

```dart
enum UserMode {
  expert,
  inertial,
  cultivation,
  guiding;
  
  String get displayName {
    switch (this) {
      case expert: return '專家模式';
      case inertial: return '慣性模式';
      case cultivation: return '培育模式';
      case guiding: return '引導模式';
    }
  }
}

enum AccountStatus {
  active,
  inactive,
  locked,
  suspended;
}

enum AuthProvider {
  email,
  google,
  line;
}

enum LogLevel {
  debug,
  info,
  warning,
  error,
  critical;
}
```

### B. 配置參數定義

#### B.1 系統配置常數

```dart
class AuthConfig {
  static const Duration accessTokenLifetime = Duration(hours: 1);
  static const Duration refreshTokenLifetime = Duration(days: 30);
  static const Duration resetTokenLifetime = Duration(hours: 1);
  static const Duration verificationCodeLifetime = Duration(hours: 24);
  
  static const int maxFailedLoginAttempts = 5;
  static const Duration accountLockoutDuration = Duration(minutes: 15);
  static const int passwordMinLength = 8;
  static const int bcryptSaltRounds = 12;
  
  static const int maxRetryAttempts = 3;
  static const Duration retryBaseDelay = Duration(seconds: 1);
  static const double retryBackoffFactor = 2.0;
}
```

### C. 介面契約定義

#### C.1 Repository 介面契約

```dart
abstract class RepositoryContract<T, ID> {
  Future<T?> findById(ID id);
  Future<T> save(T entity);
  Future<void> delete(ID id);
  Future<List<T>> findAll();
  Future<bool> exists(ID id);
}

abstract class UserRepositoryContract extends RepositoryContract<UserEntity, String> {
  Future<UserEntity?> findByEmail(String email);
  Future<bool> emailExists(String email);
  Future<List<UserEntity>> findByStatus(AccountStatus status);
}
```

---

**文件完成日期**: 2025-01-27  
**版本**: 2.0.0  
**維護者**: LCAS 開發團隊  
**規範遵循**: 完全遵循 8020、8088、8101 文件規範，專注於Low Level Design規格而非實作細節
