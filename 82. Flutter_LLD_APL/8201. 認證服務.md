
# LCAS 2.0 認證服務 API - Low Level Design (LLD)

## 版本資訊
- 文件版本: 2.1.0
- API 版本: 1.1.0
- 日期: 2025-01-27
- 作者: LCAS 開發團隊

---

## 目錄
1. [簡介](#1-簡介)
2. [架構設計](#2-架構設計)
3. [模組與類別設計](#3-模組與類別設計)
4. [API 設計規格](#4-api-設計規格)
5. [資料模型設計](#5-資料模型設計)
6. [安全與驗證設計](#6-安全與驗證設計)
7. [錯誤處理設計](#7-錯誤處理設計)
8. [日誌與監控設計](#8-日誌與監控設計)
9. [測試設計策略](#9-測試設計策略)

---

## 1. 簡介

### 1.1 設計目的與範圍
認證服務 API 提供 LCAS 2.0 系統的完整認證功能，採用 **Dart** 語言實作客戶端 API 介面。本文件定義系統架構、類別設計、方法規格及互動關係，專注於Low Level Design規格。

### 1.2 核心功能模組
- **使用者認證模組**：註冊、登入、登出處理
- **密碼管理模組**：忘記密碼、重設密碼、密碼驗證
- **Token 管理模組**：JWT 生成、驗證、刷新機制
- **OAuth 整合模組**：Google OAuth 登入處理
- **跨平台綁定模組**：LINE 帳號綁定與狀態管理
- **Email 驗證模組**：註冊驗證、地址驗證流程

### 1.3 四模式支援策略
本設計支援四種使用者模式的差異化體驗：
- **Expert**：完整認證選項、詳細安全資訊、進階設定功能
- **Inertial**：標準認證流程、基本安全提示、固定選項配置
- **Cultivation**：引導式認證、安全教育內容、進度追蹤機制
- **Guiding**：極簡認證流程、最少必要步驟、簡化操作介面

---

## 2. 架構設計

### 2.1 系統分層架構
```
┌─────────────────────────────────────────┐
│            API Controller Layer         │
│         (AuthController)                │
├─────────────────────────────────────────┤
│            Service Layer                │
│  ┌─────────────┬─────────────┬────────┐ │
│  │ AuthService │OAuthService │BindSvc │ │
│  └─────────────┴─────────────┴────────┘ │
├─────────────────────────────────────────┤
│            Utility Layer                │
│  ┌─────────────┬─────────────────────┐  │
│  │ TokenSvc    │ UserModeAdapter     │  │
│  └─────────────┴─────────────────────┘  │
├─────────────────────────────────────────┤
│            Data Access Layer            │
│         (Repository Pattern)            │
└─────────────────────────────────────────┘
```

### 2.2 類別關係圖
```
AuthController
    ├─ depends on ──→ AuthService
    ├─ depends on ──→ OAuthService
    ├─ depends on ──→ BindingService
    └─ depends on ──→ UserModeAdapter

AuthService
    ├─ depends on ──→ TokenService
    ├─ depends on ──→ UserRepository
    └─ depends on ──→ EmailService

OAuthService
    ├─ depends on ──→ TokenService
    └─ depends on ──→ GoogleOAuthProvider

BindingService
    ├─ depends on ──→ LineAPIClient
    └─ depends on ──→ BindingRepository
```

### 2.3 互動序列圖設計
#### 使用者註冊流程
```
Client → AuthController → AuthService → UserRepository
     ← ApiResponse    ← RegisterResult ← UserEntity
```

#### 登入驗證流程
```
Client → AuthController → AuthService → TokenService
     ← LoginResponse  ← TokenPair   ← JWT Tokens
```

---

## 3. 模組與類別設計

### 3.1 AuthController 類別設計

#### 3.1.1 類別職責
- 統一處理所有認證相關的API請求
- 協調各服務模組完成業務邏輯
- 統一回應格式與錯誤處理
- 實作四模式差異化邏輯

#### 3.1.2 方法簽名規格

```dart
class AuthController {
  // 核心認證方法
  Future<ApiResponse<RegisterResponse>> register(RegisterRequest request);
  Future<ApiResponse<LoginResponse>> login(LoginRequest request);
  Future<ApiResponse<void>> logout(LogoutRequest request);
  Future<ApiResponse<RefreshTokenResponse>> refreshToken(String refreshToken);
  
  // 密碼管理方法
  Future<ApiResponse<void>> forgotPassword(ForgotPasswordRequest request);
  Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String token);
  Future<ApiResponse<void>> resetPassword(ResetPasswordRequest request);
  
  // Email驗證方法
  Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest request);
  
  // OAuth方法
  Future<ApiResponse<LoginResponse>> googleLogin(GoogleLoginRequest request);
  
  // 跨平台綁定方法
  Future<ApiResponse<BindingResponse>> bindLine(BindLineRequest request);
  Future<ApiResponse<BindingStatusResponse>> getBindStatus();
  
  // 內部輔助方法
  ApiResponse<T> _adaptResponse<T>(T data, UserMode userMode);
  void _logAuthEvent(String event, Map<String, dynamic> details);
  bool _validateRequest(dynamic request);
}
```

### 3.2 AuthService 類別設計

#### 3.2.1 類別職責
- 實作核心認證業務邏輯
- 管理使用者生命週期
- 整合Token服務與資料層
- 執行安全檢查機制

#### 3.2.2 方法簽名規格

```dart
class AuthService {
  // 使用者管理核心方法
  Future<RegisterResponse> registerUser(RegisterRequest request);
  Future<LoginResponse> authenticateUser(String email, String password);
  Future<void> logoutUser(LogoutRequest request);
  Future<RefreshTokenResponse> refreshToken(String refreshToken);
  
  // 密碼管理核心方法
  Future<void> sendPasswordResetEmail(String email);
  Future<VerifyResetTokenResponse> verifyResetToken(String token);
  Future<void> resetPassword(String token, String newPassword);
  
  // Email驗證核心方法
  Future<void> verifyEmail(String email, String code);
  Future<void> sendVerificationEmail(String email);
  
  // 內部業務邏輯方法
  Future<bool> _validateUserCredentials(String email, String password);
  Future<UserEntity> _createUser(RegisterRequest request);
  Future<void> _updateLastLoginTime(String userId);
  bool _isAccountLocked(String userId);
  void _incrementFailedAttempts(String userId);
  void _resetFailedAttempts(String userId);
}
```

### 3.3 TokenService 類別設計

#### 3.3.1 類別職責
- 管理JWT Token的生成、驗證、刷新和撤銷
- 處理Token生命週期管理
- 實作Token安全機制

#### 3.3.2 方法簽名規格

```dart
class TokenService {
  // Token生成方法
  Future<TokenPair> generateTokenPair(String userId, UserMode userMode);
  Future<String> generateAccessToken(String userId, Map<String, dynamic> claims);
  Future<String> generateRefreshToken(String userId);
  Future<String> generateResetToken(String email);
  Future<String> generateEmailVerificationToken(String email);
  
  // Token驗證方法
  Future<TokenValidationResult> validateAccessToken(String token);
  Future<TokenValidationResult> validateRefreshToken(String token);
  Future<bool> validateResetToken(String token);
  Future<bool> validateEmailVerificationToken(String token);
  
  // Token管理方法
  Future<void> revokeToken(String token);
  Future<void> revokeAllTokensForUser(String userId);
  Future<bool> isTokenRevoked(String token);
  
  // 內部方法
  Map<String, dynamic> _extractClaims(String token);
  bool _isTokenExpired(String token);
  String _generateSecureToken();
}
```

### 3.4 UserModeAdapter 類別設計

#### 3.4.1 類別職責
- 根據使用者模式調整API回應內容
- 過濾不適合的功能選項
- 提供模式特定的使用者體驗

#### 3.4.2 方法簽名規格

```dart
class UserModeAdapter {
  // 核心適配方法
  T adaptResponse<T>(T response, UserMode userMode);
  
  // 具體回應適配方法
  LoginResponse adaptLoginResponse(LoginResponse response, UserMode userMode);
  RegisterResponse adaptRegisterResponse(RegisterResponse response, UserMode userMode);
  ApiError adaptErrorResponse(ApiError error, UserMode userMode);
  
  // 功能選項過濾方法
  List<String> getAvailableActions(UserMode userMode);
  Map<String, dynamic> filterData(Map<String, dynamic> data, UserMode userMode);
  
  // 模式特性方法
  bool shouldShowAdvancedOptions(UserMode userMode);
  bool shouldIncludeProgressTracking(UserMode userMode);
  bool shouldSimplifyInterface(UserMode userMode);
  String getModeSpecificMessage(String baseMessage, UserMode userMode);
}
```

### 3.5 統一回應格式設計

#### 3.5.1 ApiResponse 類別規格

```dart
class ApiResponse<T> {
  final bool success;
  final T? data;
  final ApiMetadata metadata;
  final ApiError? error;
  
  ApiResponse.success({
    required this.data,
    required this.metadata,
  }) : success = true, error = null;
  
  ApiResponse.error({
    required this.error,
    required this.metadata,
  }) : success = false, data = null;
  
  // 工廠方法
  static ApiResponse<T> createSuccess<T>(T data, ApiMetadata metadata) {
    return ApiResponse.success(data: data, metadata: metadata);
  }
  
  static ApiResponse<T> createError<T>(ApiError error, ApiMetadata metadata) {
    return ApiResponse.error(error: error, metadata: metadata);
  }
  
  // JSON 轉換方法
  Map<String, dynamic> toJson() {
    return {
      'success': success,
      'data': data,
      'metadata': metadata.toJson(),
      if (error != null) 'error': error!.toJson(),
    };
  }
  
  static ApiResponse<T> fromJson<T>(
    Map<String, dynamic> json,
    T Function(Map<String, dynamic>) fromJsonT,
  ) {
    final metadata = ApiMetadata.fromJson(json['metadata']);
    
    if (json['success'] == true) {
      return ApiResponse.success(
        data: fromJsonT(json['data']),
        metadata: metadata,
      );
    } else {
      return ApiResponse.error(
        error: ApiError.fromJson(json['error']),
        metadata: metadata,
      );
    }
  }
}
```

#### 3.5.2 ApiMetadata 類別規格

```dart
class ApiMetadata {
  final DateTime timestamp;
  final String requestId;
  final UserMode userMode;
  final String apiVersion;
  final int processingTimeMs;
  final Map<String, dynamic>? additionalInfo;
  
  ApiMetadata({
    required this.timestamp,
    required this.requestId,
    required this.userMode,
    this.apiVersion = '1.1.0',
    this.processingTimeMs = 0,
    this.additionalInfo,
  });
  
  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'requestId': requestId,
      'userMode': userMode.name,
      'apiVersion': apiVersion,
      'processingTimeMs': processingTimeMs,
      if (additionalInfo != null) 'additionalInfo': additionalInfo,
    };
  }
  
  static ApiMetadata fromJson(Map<String, dynamic> json) {
    return ApiMetadata(
      timestamp: DateTime.parse(json['timestamp']),
      requestId: json['requestId'],
      userMode: UserMode.values.byName(json['userMode']),
      apiVersion: json['apiVersion'] ?? '1.1.0',
      processingTimeMs: json['processingTimeMs'] ?? 0,
      additionalInfo: json['additionalInfo'],
    );
  }
  
  // 工廠方法
  static ApiMetadata create(UserMode userMode, {Map<String, dynamic>? additionalInfo}) {
    return ApiMetadata(
      timestamp: DateTime.now().toUtc(),
      requestId: _generateRequestId(),
      userMode: userMode,
      additionalInfo: additionalInfo,
    );
  }
  
  static String _generateRequestId() {
    return 'req-${DateTime.now().millisecondsSinceEpoch}-${_generateRandomString()}';
  }
  
  static String _generateRandomString() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    final random = Random();
    return String.fromCharCodes(Iterable.generate(8, (_) => chars.codeUnitAt(random.nextInt(chars.length))));
  }
}
```

---

## 4. API 設計規格

### 4.1 API 端點完整設計

本節定義認證服務的所有 API 端點的詳細設計規格，嚴格遵循 8020. API list.md 和 8088. API設計規範.md 的規範。

| 端點 | HTTP 方法 | 函數簽名 | 功能描述 |
|------|----------|----------|----------|
| `/auth/register` | POST | `Future<ApiResponse<RegisterResponse>> register(RegisterRequest)` | 使用者註冊處理 |
| `/auth/login` | POST | `Future<ApiResponse<LoginResponse>> login(LoginRequest)` | 使用者登入處理 |
| `/auth/google-login` | POST | `Future<ApiResponse<LoginResponse>> googleLogin(GoogleLoginRequest)` | Google OAuth 登入 |
| `/auth/logout` | POST | `Future<ApiResponse<void>> logout(LogoutRequest)` | 使用者登出處理 |
| `/auth/refresh` | POST | `Future<ApiResponse<RefreshTokenResponse>> refreshToken(String)` | 刷新 Token |
| `/auth/forgot-password` | POST | `Future<ApiResponse<void>> forgotPassword(ForgotPasswordRequest)` | 忘記密碼處理 |
| `/auth/verify-reset-token` | GET | `Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String)` | 驗證重設連結 |
| `/auth/reset-password` | POST | `Future<ApiResponse<void>> resetPassword(ResetPasswordRequest)` | 重設密碼處理 |
| `/auth/verify-email` | POST | `Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest)` | 驗證 Email 地址 |
| `/auth/bind-line` | POST | `Future<ApiResponse<BindingResponse>> bindLine(BindLineRequest)` | LINE 綁定處理 |
| `/auth/bind-status` | GET | `Future<ApiResponse<BindingStatusResponse>> getBindStatus()` | 綁定狀態查詢 |

### 4.2 各端點詳細設計規格

#### 4.2.1 `/auth/verify-email` - Email 驗證端點

**Controller 方法簽名**:
```dart
Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest request)
```

**業務邏輯流程**:
1. 驗證請求參數格式
2. 檢查驗證碼有效性
3. 更新使用者Email驗證狀態
4. 清除已使用的驗證碼
5. 根據使用者模式調整回應

**模式差異化**:
- **Expert**: 包含驗證統計資訊
- **Cultivation**: 包含成就解鎖資訊
- **Guiding**: 極簡成功訊息

#### 4.2.2 `/auth/verify-reset-token` - 重設 Token 驗證端點

**Controller 方法簽名**:
```dart
Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String token)
```

**業務邏輯流程**:
1. 解析並驗證 Token 格式
2. 檢查 Token 是否存在且未過期
3. 檢查 Token 是否已被使用
4. 返回關聯的 Email 地址
5. 記錄驗證行為日誌

**回應模型設計**:
```dart
class VerifyResetTokenResponse {
  final bool valid;
  final String email;
  final DateTime expiresAt;
  final String? nextStep; // 指導下一步操作
}
```

### 4.2 請求資料模型設計

#### 4.2.1 RegisterRequest 類別規格

```dart
class RegisterRequest {
  final String email;
  final String password;
  final String? confirmPassword;
  final String? displayName;
  final UserMode userMode;
  final bool acceptTerms;
  final bool acceptPrivacy;
  final String? timezone;
  final String? language;
  
  RegisterRequest({
    required this.email,
    required this.password,
    this.confirmPassword,
    this.displayName,
    required this.userMode,
    required this.acceptTerms,
    required this.acceptPrivacy,
    this.timezone,
    this.language,
  });
  
  // 驗證方法
  List<ValidationError> validate();
  
  // 轉換方法
  Map<String, dynamic> toJson();
  static RegisterRequest fromJson(Map<String, dynamic> json);
}
```

### 4.3 回應資料模型設計

#### 4.3.1 RegisterResponse 類別規格

```dart
class RegisterResponse {
  final String userId;
  final String email;
  final UserMode userMode;
  final bool verificationSent;
  final bool needsAssessment;
  final String token;
  final String refreshToken;
  final DateTime expiresAt;
  
  RegisterResponse({
    required this.userId,
    required this.email,
    required this.userMode,
    required this.verificationSent,
    required this.needsAssessment,
    required this.token,
    required this.refreshToken,
    required this.expiresAt,
  });
  
  Map<String, dynamic> toJson();
  static RegisterResponse fromJson(Map<String, dynamic> json);
}
```

### 4.4 四模式差異化設計規格

#### 4.4.1 模式適配規則設計

```dart
abstract class ModeAdaptationRule<T> {
  T adapt(T original, UserMode userMode);
  bool shouldIncludeField(String fieldName, UserMode userMode);
  String adaptMessage(String original, UserMode userMode);
}

class LoginResponseAdaptationRule implements ModeAdaptationRule<LoginResponse> {
  @override
  LoginResponse adapt(LoginResponse original, UserMode userMode) {
    switch (userMode) {
      case UserMode.expert:
        return _adaptForExpert(original);
      case UserMode.inertial:
        return _adaptForInertial(original);
      case UserMode.cultivation:
        return _adaptForCultivation(original);
      case UserMode.guiding:
        return _adaptForGuiding(original);
    }
  }
  
  LoginResponse _adaptForExpert(LoginResponse original) {
    return original.copyWith(
      loginHistory: _getDetailedLoginHistory(original.user.id),
      securityInfo: _getSecurityInfo(original.user.id),
      advancedOptions: _getAdvancedOptions(),
    );
  }
  
  LoginResponse _adaptForCultivation(LoginResponse original) {
    return original.copyWith(
      streakInfo: _getStreakInfo(original.user.id),
      achievement: _checkAchievements(original.user.id),
      motivationalContent: _getMotivationalContent(),
      loginHistory: null, // 不顯示歷史
    );
  }
  
  LoginResponse _adaptForGuiding(LoginResponse original) {
    return LoginResponse.simple(
      token: original.token,
      refreshToken: original.refreshToken,
      expiresAt: original.expiresAt,
      userId: original.user.id,
      simpleMessage: '登入成功',
    );
  }
  
  // 內部輔助方法
  Map<String, dynamic>? _getDetailedLoginHistory(String userId) { ... }
  SecurityInfo? _getSecurityInfo(String userId) { ... }
  List<String> _getAdvancedOptions() { ... }
  StreakInfo? _getStreakInfo(String userId) { ... }
  Achievement? _checkAchievements(String userId) { ... }
  String _getMotivationalContent() { ... }
}
```

#### 4.4.2 詳細模式差異化矩陣

| 功能分類 | Expert | Inertial | Cultivation | Guiding |
|---------|--------|----------|-------------|---------|
| **登入回應** |
| 登入歷史 | 詳細歷史記錄<br>設備資訊<br>地理位置 | 最近5筆記錄<br>基本設備資訊 | 不顯示歷史<br>僅顯示連續天數 | 不顯示 |
| Token資訊 | 包含過期時間<br>權限範圍<br>刷新策略 | 包含過期時間<br>基本資訊 | 僅包含基本資訊 | 隱藏技術細節 |
| 使用者資料 | 完整個人檔案<br>偏好設定 | 基本個人資料 | 基本資料+進度 | 僅顯示名稱 |
| **安全功能** |
| 密碼強度 | 詳細強度分析<br>建議改善項目 | 強度等級顯示 | 教育性提示<br>安全小知識 | 簡單提示 |
| 兩階段驗證 | 完整設定選項<br>備用方案 | 基本開關設定 | 引導式設定<br>好處說明 | 自動建議開啟 |
| 登入警示 | 詳細安全日誌<br>異常分析 | 基本異常通知 | 安全教育內容 | 簡化警示 |
| **錯誤處理** |
| 錯誤訊息 | 技術性詳細說明<br>錯誤碼顯示 | 使用者友善描述 | 引導性說明<br>解決建議 | 極簡提示<br>一鍵修正 |
| 故障排除 | 完整故障排除指南 | 常見解決方案 | 逐步引導修正 | 自動處理+簡單提示 |
| **個人化設定** |
| 介面設定 | 全部客製化選項 | 預設主題選項 | 引導式設定<br>推薦配置 | 固定最佳設定 |
| 通知設定 | 細粒度控制 | 分類開關 | 建議設定+說明 | 智慧預設 |

#### 4.4.3 模式適配實作策略

```dart
class ModeSpecificResponseBuilder {
  static Map<String, dynamic> buildLoginResponse(
    LoginResponse baseResponse, 
    UserMode userMode
  ) {
    final builder = _ResponseBuilder(baseResponse, userMode);
    
    return {
      'token': baseResponse.token,
      'refreshToken': baseResponse.refreshToken,
      'expiresAt': baseResponse.expiresAt.toIso8601String(),
      'user': _buildUserProfile(baseResponse.user, userMode),
      ...builder.getAdditionalFields(),
    };
  }
  
  static Map<String, dynamic> _buildUserProfile(User user, UserMode userMode) {
    final base = {
      'id': user.id,
      'email': user.email,
      'userMode': user.userMode.name,
    };
    
    switch (userMode) {
      case UserMode.expert:
        return {
          ...base,
          'displayName': user.displayName,
          'avatar': user.avatar,
          'preferences': user.preferences.toJson(),
          'createdAt': user.createdAt.toIso8601String(),
          'lastActiveAt': user.lastActiveAt?.toIso8601String(),
        };
        
      case UserMode.guiding:
        return {
          'id': user.id,
          'displayName': user.displayName ?? '使用者',
        };
        
      default:
        return {
          ...base,
          'displayName': user.displayName,
          'avatar': user.avatar,
        };
    }
  }
}

class _ResponseBuilder {
  final LoginResponse _baseResponse;
  final UserMode _userMode;
  
  _ResponseBuilder(this._baseResponse, this._userMode);
  
  Map<String, dynamic> getAdditionalFields() {
    switch (_userMode) {
      case UserMode.expert:
        return _getExpertFields();
      case UserMode.cultivation:
        return _getCultivationFields();
      case UserMode.inertial:
        return _getInertialFields();
      case UserMode.guiding:
        return _getGuidingFields();
    }
  }
  
  Map<String, dynamic> _getExpertFields() {
    return {
      'loginHistory': _getLoginHistory(),
      'securityInfo': _getSecurityInfo(),
      'advancedOptions': _getAdvancedOptions(),
    };
  }
  
  Map<String, dynamic> _getCultivationFields() {
    return {
      'streakInfo': _getStreakInfo(),
      'achievement': _getAchievementInfo(),
      'motivationalContent': _getMotivationalContent(),
      'progressTracking': _getProgressInfo(),
    };
  }
  
  // 各種內部方法實作...
  Map<String, dynamic>? _getLoginHistory() { ... }
  Map<String, dynamic>? _getSecurityInfo() { ... }
  List<String> _getAdvancedOptions() { ... }
  Map<String, dynamic>? _getStreakInfo() { ... }
}
```

---

## 5. 資料模型設計

### 5.1 Firestore Collection 結構設計

#### 5.1.1 Users Collection 資料模型

```dart
class UserEntity {
  final String id;
  final String email;
  final String passwordHash;
  final String? displayName;
  final UserMode userMode;
  final bool emailVerified;
  final AccountStatus status;
  final AuthProvider authProvider;
  final UserPreferences preferences;
  final SecuritySettings security;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastActiveAt;
  
  UserEntity({
    required this.id,
    required this.email,
    required this.passwordHash,
    this.displayName,
    required this.userMode,
    required this.emailVerified,
    required this.status,
    required this.authProvider,
    required this.preferences,
    required this.security,
    required this.createdAt,
    required this.updatedAt,
    this.lastActiveAt,
  });
  
  // 轉換方法
  Map<String, dynamic> toFirestore();
  static UserEntity fromFirestore(Map<String, dynamic> data, String id);
  
  // 業務方法
  bool isActive();
  bool isLocked();
  bool canLogin();
  UserEntity updateLastActive();
}
```

### 5.2 資料存取層設計

#### 5.2.1 Repository 介面規格

```dart
abstract class UserRepository {
  Future<UserEntity?> findByEmail(String email);
  Future<UserEntity?> findById(String id);
  Future<UserEntity> create(UserEntity user);
  Future<UserEntity> update(UserEntity user);
  Future<void> delete(String id);
  Future<bool> emailExists(String email);
  Future<List<UserEntity>> findByStatus(AccountStatus status);
  Future<UserEntity?> findByProvider(AuthProvider provider, String providerId);
}
```

---

## 6. 安全與驗證設計

### 6.1 JWT Token 處理設計

#### 6.1.1 Token 生成策略設計

```dart
class JWTTokenGenerator {
  final String secretKey;
  final Duration accessTokenLifetime;
  final Duration refreshTokenLifetime;
  
  JWTTokenGenerator({
    required this.secretKey,
    this.accessTokenLifetime = const Duration(hours: 1),
    this.refreshTokenLifetime = const Duration(days: 30),
  });
  
  Future<String> generateAccessToken(String userId, UserMode userMode);
  Future<String> generateRefreshToken(String userId);
  Future<Map<String, dynamic>> verifyToken(String token);
  bool isTokenExpired(String token);
}
```

### 6.2 密碼安全設計

#### 6.2.1 密碼加密服務設計

```dart
class PasswordSecurityService {
  final int saltRounds;
  
  PasswordSecurityService({this.saltRounds = 12});
  
  Future<String> hashPassword(String password);
  Future<bool> verifyPassword(String password, String hash);
  PasswordStrength assessPasswordStrength(String password);
  bool isPasswordInBlacklist(String password);
}
```

---

## 7. 錯誤處理設計

### 7.1 錯誤碼分類體系

#### 7.1.1 認證服務錯誤碼枚舉

```dart
enum AuthErrorCode {
  // 驗證錯誤 (400)
  validationError,
  invalidEmail,
  weakPassword,
  passwordMismatch,
  missingRequiredField,
  invalidDateFormat,
  
  // 認證錯誤 (401)
  unauthorized,
  invalidCredentials,
  tokenExpired,
  tokenInvalid,
  tokenRevoked,
  
  // 權限錯誤 (403)
  insufficientPermissions,
  accountDisabled,
  accountNotVerified,
  
  // 資源錯誤 (404, 409)
  userNotFound,
  emailAlreadyExists,
  invalidResetToken,
  verificationCodeNotFound,
  bindingNotFound,
  
  // 帳號狀態錯誤 (423)
  accountLocked,
  accountSuspended,
  tooManyAttempts,
  
  // 業務邏輯錯誤 (422)
  emailNotVerified,
  resetTokenUsed,
  verificationCodeExpired,
  bindingAlreadyExists,
  invalidUserMode,
  
  // 系統錯誤 (500)
  internalServerError,
  externalServiceError,
  databaseError,
  emailServiceError,
  oauthServiceError;
  
  int get httpStatusCode {
    switch (this) {
      case validationError:
      case invalidEmail:
      case weakPassword:
      case passwordMismatch:
      case missingRequiredField:
      case invalidDateFormat:
        return 400;
      
      case unauthorized:
      case invalidCredentials:
      case tokenExpired:
      case tokenInvalid:
      case tokenRevoked:
        return 401;
      
      case insufficientPermissions:
      case accountDisabled:
      case accountNotVerified:
        return 403;
      
      case userNotFound:
      case invalidResetToken:
      case verificationCodeNotFound:
      case bindingNotFound:
        return 404;
      
      case emailAlreadyExists:
      case bindingAlreadyExists:
        return 409;
      
      case emailNotVerified:
      case resetTokenUsed:
      case verificationCodeExpired:
      case invalidUserMode:
        return 422;
      
      case accountLocked:
      case accountSuspended:
      case tooManyAttempts:
        return 423;
      
      case internalServerError:
      case externalServiceError:
      case databaseError:
      case emailServiceError:
      case oauthServiceError:
        return 500;
    }
  }
  
  String getMessage(UserMode userMode) {
    return _getLocalizedMessage(this, userMode);
  }
  
  static String _getLocalizedMessage(AuthErrorCode code, UserMode userMode) {
    final messages = _getErrorMessages(userMode);
    return messages[code] ?? '未知錯誤';
  }
  
  static Map<AuthErrorCode, String> _getErrorMessages(UserMode userMode) {
    switch (userMode) {
      case UserMode.expert:
        return _expertMessages;
      case UserMode.inertial:
        return _inertialMessages;
      case UserMode.cultivation:
        return _cultivationMessages;
      case UserMode.guiding:
        return _guidingMessages;
    }
  }
  
  static const Map<AuthErrorCode, String> _expertMessages = {
    validationError: '請求參數驗證失敗，請檢查輸入格式',
    invalidCredentials: '認證失敗：Email 或密碼不正確',
    tokenExpired: 'JWT Token 已過期，請重新登入',
    accountLocked: '帳號因多次登入失敗被暫時鎖定',
    // ... 更多詳細技術訊息
  };
  
  static const Map<AuthErrorCode, String> _guidingMessages = {
    validationError: '輸入資料有誤',
    invalidCredentials: '帳號或密碼錯誤',
    tokenExpired: '請重新登入',
    accountLocked: '帳號暫時無法使用',
    // ... 更多簡化訊息
  };
  
  // 其他模式訊息映射表...
  static const Map<AuthErrorCode, String> _inertialMessages = {
    // ...
  };
  
  static const Map<AuthErrorCode, String> _cultivationMessages = {
    // ...
  };
}
```

#### 7.1.2 ApiError 類別設計

```dart
class ApiError {
  final AuthErrorCode code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final String requestId;
  final Map<String, dynamic>? details;
  
  ApiError({
    required this.code,
    required this.message,
    this.field,
    required this.timestamp,
    required this.requestId,
    this.details,
  });
  
  Map<String, dynamic> toJson() {
    return {
      'code': code.name,
      'message': message,
      if (field != null) 'field': field,
      'timestamp': timestamp.toIso8601String(),
      'requestId': requestId,
      if (details != null) 'details': details,
    };
  }
  
  static ApiError fromJson(Map<String, dynamic> json) {
    return ApiError(
      code: AuthErrorCode.values.byName(json['code']),
      message: json['message'],
      field: json['field'],
      timestamp: DateTime.parse(json['timestamp']),
      requestId: json['requestId'],
      details: json['details'],
    );
  }
  
  static ApiError create(
    AuthErrorCode code,
    UserMode userMode, {
    String? field,
    String? requestId,
    Map<String, dynamic>? details,
  }) {
    return ApiError(
      code: code,
      message: code.getMessage(userMode),
      field: field,
      timestamp: DateTime.now().toUtc(),
      requestId: requestId ?? _generateRequestId(),
      details: details,
    );
  }
  
  static String _generateRequestId() {
    return 'err-${DateTime.now().millisecondsSinceEpoch}';
  }
}
```

### 7.2 錯誤處理服務設計

#### 7.2.1 ErrorHandler 類別規格

```dart
class ErrorHandler {
  ApiResponse<T> handleException<T>(Exception exception, UserMode? userMode);
  ApiError createError(AuthErrorCode code, String? field, {Map<String, dynamic>? details});
  ApiError adaptErrorForMode(ApiError error, UserMode userMode);
  
  String _getErrorMessage(AuthErrorCode code, UserMode userMode);
  bool _shouldIncludeDetails(AuthErrorCode code, UserMode userMode);
}
```

---

## 8. 日誌與監控設計

### 8.1 日誌記錄策略設計

#### 8.1.1 AuthLogger 類別設計

```dart
class AuthLogger {
  void logAuthenticationAttempt(String email, bool success, {String? reason});
  void logRegistration(String userId, UserMode userMode);
  void logPasswordReset(String email, bool success);
  void logTokenRefresh(String userId, bool success);
  void logAccountLockout(String userId, Duration lockoutDuration);
  void logSecurityEvent(SecurityEventType type, String userId, Map<String, dynamic> details);
  
  LogEntry _createLogEntry(LogLevel level, String event, Map<String, dynamic> data);
  void _writeLog(LogEntry entry);
}
```

### 8.2 效能監控設計

#### 8.2.1 PerformanceMonitor 類別設計

```dart
class PerformanceMonitor {
  void startOperation(String operationName, String requestId);
  void endOperation(String operationName, String requestId);
  void recordMetric(String metricName, double value);
  PerformanceReport generateReport(Duration period);
  
  Map<String, PerformanceMetric> _activeOperations;
  List<PerformanceRecord> _performanceHistory;
}
```

---

## 9. 測試設計策略

### 9.1 測試層級設計

#### 9.1.1 單元測試設計策略

```dart
abstract class AuthServiceTestSuite {
  // 測試方法簽名
  void testRegisterUser_ValidInput_ShouldReturnSuccess();
  void testRegisterUser_DuplicateEmail_ShouldThrowException();
  void testRegisterUser_WeakPassword_ShouldThrowValidationException();
  void testLoginUser_ValidCredentials_ShouldReturnTokens();
  void testLoginUser_InvalidCredentials_ShouldThrowAuthException();
  void testLoginUser_LockedAccount_ShouldThrowAccountLockedException();
  
  // 測試輔助方法
  RegisterRequest createValidRegisterRequest();
  RegisterRequest createInvalidRegisterRequest();
  void mockUserRepository();
  void mockTokenService();
}
```

### 9.2 四模式測試設計

#### 9.2.1 模式差異化測試策略

```dart
class UserModeTestSuite {
  void testExpertModeResponse();
  void testInertialModeResponse();
  void testCultivationModeResponse();
  void testGuidingModeResponse();
  
  void assertExpertModeFeatures(dynamic response);
  void assertCultivationModeFeatures(dynamic response);
  void assertGuidingModeSimplicity(dynamic response);
  
  TestScenario createModeTestScenario(UserMode mode);
}
```

---

## 附錄

### A. 資料類型定義

#### A.1 枚舉類型定義

```dart
enum UserMode {
  expert,
  inertial,
  cultivation,
  guiding;
  
  String get displayName {
    switch (this) {
      case expert: return '專家模式';
      case inertial: return '慣性模式';
      case cultivation: return '培育模式';
      case guiding: return '引導模式';
    }
  }
}

enum AccountStatus {
  active,
  inactive,
  locked,
  suspended;
}

enum AuthProvider {
  email,
  google,
  line;
}

enum LogLevel {
  debug,
  info,
  warning,
  error,
  critical;
}
```

### B. 介面契約定義

#### B.1 Repository 介面契約

```dart
abstract class RepositoryContract<T, ID> {
  Future<T?> findById(ID id);
  Future<T> save(T entity);
  Future<void> delete(ID id);
  Future<List<T>> findAll();
  Future<bool> exists(ID id);
}

abstract class UserRepositoryContract extends RepositoryContract<UserEntity, String> {
  Future<UserEntity?> findByEmail(String email);
  Future<bool> emailExists(String email);
  Future<List<UserEntity>> findByStatus(AccountStatus status);
}
```

---

**文件完成日期**: 2025-01-27  
**版本**: 2.1.0  
**維護者**: LCAS 開發團隊  
**規範遵循**: 完全遵循 8020、8088、8101 文件規範，專注於Low Level Design規格而非實作細節
