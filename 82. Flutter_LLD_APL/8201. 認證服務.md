
# LCAS 2.0 認證服務 API - Low Level Design (LLD)

## 版本資訊
- 文件版本: 1.0
- API 版本: 1.1.0
- 日期: 2025-01-27
- 作者: LCAS 開發團隊

---

## 目錄
1. 簡介
2. 架構設計
3. 模組與類別設計
4. API 詳細實作設計
5. 資料庫設計
6. 安全與驗證
7. 錯誤處理
8. 日誌與監控
9. 測試設計

---

## 1. 簡介

### 1.1 API 目的與範圍
認證服務 API 提供 LCAS 2.0 系統的完整認證功能，包括使用者註冊、登入、密碼管理、跨平台綁定等核心認證機制。

### 1.2 核心功能列表
- **使用者認證**：註冊、登入、登出
- **密碼管理**：忘記密碼、重設密碼、密碼加密
- **Token 管理**：JWT 生成、驗證、刷新
- **OAuth 整合**：Google OAuth 登入
- **跨平台綁定**：LINE 帳號綁定與狀態查詢
- **Email 驗證**：註冊驗證、地址驗證

### 1.3 支援的四種使用者模式
- **Expert**：完整認證選項、詳細安全資訊、進階設定
- **Inertial**：標準認證流程、基本安全提示、固定選項
- **Cultivation**：引導式認證、安全教育內容、進度追蹤
- **Guiding**：極簡認證、最少必要步驟、簡化流程

---

## 2. 架構設計

### 2.1 系統架構圖
```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│    (Flutter APP + LINE OA)             │
├─────────────────────────────────────────┤
│         API Gateway Layer               │
│    ┌─────────────────────────────────┐  │
│    │  認證中介層 (Auth Middleware)    │  │
│    │  - JWT 驗證                     │  │
│    │  - 模式判斷                     │  │
│    │  - 請求日誌                     │  │
│    └─────────────────────────────────┘  │
├─────────────────────────────────────────┤
│         Service Layer                   │
│    ┌─────────────────────────────────┐  │
│    │  認證服務 (AuthService)          │  │
│    │  - 登入/註冊邏輯                │  │
│    │  - 密碼管理                     │  │
│    │  - Token 管理                   │  │
│    └─────────────────────────────────┘  │
│    ┌─────────────────────────────────┐  │
│    │  OAuth 服務 (OAuthService)      │  │
│    │  - Google OAuth                 │  │
│    │  - 第三方驗證                   │  │
│    └─────────────────────────────────┘  │
│    ┌─────────────────────────────────┐  │
│    │  綁定服務 (BindingService)      │  │
│    │  - LINE 綁定                    │  │
│    │  - 綁定狀態管理                 │  │
│    └─────────────────────────────────┘  │
├─────────────────────────────────────────┤
│         Data Layer                      │
│           (Firestore)                   │
│    - Users Collection                   │
│    - AuthTokens Collection              │
│    - PasswordResetTokens Collection     │
│    - AccountBindings Collection         │
└─────────────────────────────────────────┘
```

### 2.2 模組間依賴圖
```
AuthController
    ├── AuthService
    │   ├── UserRepository
    │   ├── TokenService
    │   └── EmailService
    ├── OAuthService
    │   ├── GoogleOAuthProvider
    │   └── TokenService
    └── BindingService
        ├── LineAPIClient
        └── BindingRepository
```

### 2.3 外部服務整合
- **Google OAuth 2.0**：第三方登入驗證
- **LINE API**：帳號綁定與狀態查詢
- **Email Service**：驗證信發送
- **Firestore**：使用者資料儲存

---

## 3. 模組與類別設計

### 3.1 AuthController 類別
```javascript
class AuthController {
  constructor(authService, oauthService, bindingService) {
    this.authService = authService;
    this.oauthService = oauthService;
    this.bindingService = bindingService;
  }

  async register(req, res) {
    // 註冊邏輯實作
  }

  async login(req, res) {
    // 登入邏輯實作
  }

  async logout(req, res) {
    // 登出邏輯實作
  }

  async refreshToken(req, res) {
    // Token 刷新實作
  }

  async forgotPassword(req, res) {
    // 忘記密碼實作
  }

  async resetPassword(req, res) {
    // 重設密碼實作
  }

  async verifyEmail(req, res) {
    // Email 驗證實作
  }

  async googleLogin(req, res) {
    // Google OAuth 登入實作
  }

  async bindLine(req, res) {
    // LINE 綁定實作
  }

  async getBindStatus(req, res) {
    // 綁定狀態查詢實作
  }
}
```

### 3.2 AuthService 類別
```javascript
class AuthService {
  constructor(userRepository, tokenService, emailService) {
    this.userRepository = userRepository;
    this.tokenService = tokenService;
    this.emailService = emailService;
  }

  async registerUser(userData) {
    // 使用者註冊邏輯
    // 1. 驗證輸入資料
    // 2. 檢查 Email 是否已存在
    // 3. 加密密碼
    // 4. 建立使用者記錄
    // 5. 發送驗證信
    // 6. 生成 Token
  }

  async authenticateUser(email, password) {
    // 使用者認證邏輯
    // 1. 查詢使用者
    // 2. 驗證密碼
    // 3. 檢查帳號狀態
    // 4. 生成 Token
  }

  async generatePasswordResetToken(email) {
    // 生成密碼重設 Token
  }

  async resetUserPassword(token, newPassword) {
    // 重設使用者密碼
  }

  async verifyEmailAddress(email, code) {
    // 驗證 Email 地址
  }
}
```

### 3.3 TokenService 類別
```javascript
class TokenService {
  constructor(secretKey, refreshSecretKey) {
    this.secretKey = secretKey;
    this.refreshSecretKey = refreshSecretKey;
  }

  generateAccessToken(userData) {
    // 生成 Access Token (1小時有效)
    return jwt.sign({
      userId: userData.id,
      email: userData.email,
      userMode: userData.userMode,
      type: 'access'
    }, this.secretKey, { expiresIn: '1h' });
  }

  generateRefreshToken(userData) {
    // 生成 Refresh Token (30天有效)
    return jwt.sign({
      userId: userData.id,
      type: 'refresh'
    }, this.refreshSecretKey, { expiresIn: '30d' });
  }

  verifyAccessToken(token) {
    // 驗證 Access Token
  }

  verifyRefreshToken(token) {
    // 驗證 Refresh Token
  }

  revokeToken(token) {
    // 撤銷 Token
  }
}
```

### 3.4 UserModeAdapter 類別
```javascript
class UserModeAdapter {
  static adaptResponse(data, userMode) {
    switch (userMode) {
      case 'Expert':
        return this.adaptExpertMode(data);
      case 'Inertial':
        return this.adaptInertialMode(data);
      case 'Cultivation':
        return this.adaptCultivationMode(data);
      case 'Guiding':
        return this.adaptGuidingMode(data);
      default:
        return this.adaptInertialMode(data);
    }
  }

  static adaptExpertMode(data) {
    // 完整詳細資訊
    return {
      ...data,
      securityInfo: data.securityInfo,
      loginHistory: data.loginHistory,
      advancedOptions: data.advancedOptions
    };
  }

  static adaptGuidingMode(data) {
    // 極簡化資訊
    return {
      token: data.token,
      message: "登入成功"
    };
  }
}
```

---

## 4. API 詳細實作設計

### 4.1 Endpoint: `/auth/register`

#### 主要邏輯流程
1. **請求參數驗證**
   ```javascript
   const validateRegisterRequest = (req) => {
     const { email, password, userMode, acceptTerms } = req.body;
     
     if (!email || !isValidEmail(email)) {
       throw new ValidationError('INVALID_EMAIL', 'Email 格式無效');
     }
     
     if (!password || password.length < 8) {
       throw new ValidationError('WEAK_PASSWORD', '密碼至少需要 8 個字元');
     }
     
     if (!acceptTerms) {
       throw new ValidationError('TERMS_NOT_ACCEPTED', '必須同意服務條款');
     }
   };
   ```

2. **檢查 Email 是否已存在**
   ```javascript
   const existingUser = await this.userRepository.findByEmail(email);
   if (existingUser) {
     throw new ConflictError('EMAIL_ALREADY_EXISTS', '此 Email 已被註冊');
   }
   ```

3. **建立使用者紀錄**
   ```javascript
   const hashedPassword = await bcrypt.hash(password, 12);
   const userData = {
     id: generateUUID(),
     email,
     password: hashedPassword,
     userMode: userMode || 'Inertial',
     emailVerified: false,
     createdAt: new Date(),
     status: 'active'
   };
   
   await this.userRepository.create(userData);
   ```

4. **發送驗證信**
   ```javascript
   const verificationCode = generateVerificationCode();
   await this.emailService.sendVerificationEmail(email, verificationCode);
   ```

5. **生成 Token**
   ```javascript
   const accessToken = this.tokenService.generateAccessToken(userData);
   const refreshToken = this.tokenService.generateRefreshToken(userData);
   ```

#### 使用者模式差異化流程
- **Expert 模式**：提供完整註冊選項、安全設定
- **Inertial 模式**：標準註冊流程、基本驗證
- **Cultivation 模式**：引導式註冊、進度提示
- **Guiding 模式**：極簡註冊、最少欄位

### 4.2 Endpoint: `/auth/login`

#### 主要邏輯流程
1. **驗證請求參數**
2. **使用者認證**
   ```javascript
   const user = await this.userRepository.findByEmail(email);
   if (!user) {
     throw new UnauthorizedError('INVALID_CREDENTIALS', 'Email 或密碼錯誤');
   }
   
   const isPasswordValid = await bcrypt.compare(password, user.password);
   if (!isPasswordValid) {
     throw new UnauthorizedError('INVALID_CREDENTIALS', 'Email 或密碼錯誤');
   }
   ```

3. **檢查帳號狀態**
   ```javascript
   if (user.status === 'locked') {
     throw new ForbiddenError('ACCOUNT_LOCKED', '帳號已被鎖定');
   }
   ```

4. **生成 Token 與更新登入記錄**
5. **記錄登入歷史**
   ```javascript
   await this.userRepository.updateLoginHistory(user.id, {
     loginTime: new Date(),
     deviceInfo: req.deviceInfo,
     ipAddress: req.ip
   });
   ```

#### 模式差異化回應
- **Expert**：詳細登入資訊、設備檢測、登入歷史
- **Inertial**：標準登入回應
- **Cultivation**：連續登入天數、成就提示
- **Guiding**：簡化成功訊息

### 4.3 Endpoint: `/auth/google-login`

#### OAuth 驗證流程
1. **驗證 Google Token**
   ```javascript
   const googleUser = await this.oauthService.verifyGoogleToken(googleToken);
   if (!googleUser) {
     throw new UnauthorizedError('INVALID_GOOGLE_TOKEN', 'Google Token 無效');
   }
   ```

2. **檢查或建立使用者**
   ```javascript
   let user = await this.userRepository.findByEmail(googleUser.email);
   
   if (!user) {
     // 自動建立新使用者
     user = await this.userRepository.create({
       id: generateUUID(),
       email: googleUser.email,
       displayName: googleUser.name,
       avatar: googleUser.picture,
       userMode: userMode || 'Inertial',
       emailVerified: true,
       authProvider: 'google',
       googleId: googleUser.id,
       createdAt: new Date()
     });
   }
   ```

3. **更新 Google 綁定資訊**
4. **生成認證 Token**

### 4.4 Endpoint: `/auth/logout`

#### 登出策略
1. **Token 失效處理**
   ```javascript
   await this.tokenService.revokeToken(accessToken);
   if (logoutAllDevices) {
     await this.tokenService.revokeAllUserTokens(userId);
   }
   ```

2. **清理 Session 資料**
3. **記錄登出事件**

### 4.5 Endpoint: `/auth/refresh`

#### Token 刷新邏輯
1. **驗證 Refresh Token**
   ```javascript
   const payload = this.tokenService.verifyRefreshToken(refreshToken);
   if (!payload) {
     throw new UnauthorizedError('INVALID_REFRESH_TOKEN', 'Refresh Token 無效');
   }
   ```

2. **檢查使用者狀態**
3. **生成新的 Token 對**
4. **撤銷舊 Token**

### 4.6 Endpoint: `/auth/forgot-password`

#### 密碼重設流程
1. **驗證 Email 存在**
2. **生成重設 Token**
   ```javascript
   const resetToken = generateSecureToken();
   const resetRecord = {
     email,
     token: resetToken,
     expiresAt: new Date(Date.now() + 3600000), // 1小時
     used: false
   };
   
   await this.passwordResetRepository.create(resetRecord);
   ```

3. **發送重設郵件**
   ```javascript
   const resetUrl = `${baseUrl}/reset-password?token=${resetToken}`;
   await this.emailService.sendPasswordResetEmail(email, resetUrl);
   ```

### 4.7 Endpoint: `/auth/reset-password`

#### 密碼重設實作
1. **驗證重設 Token**
   ```javascript
   const resetRecord = await this.passwordResetRepository.findByToken(token);
   if (!resetRecord || resetRecord.used || new Date() > resetRecord.expiresAt) {
     throw new BadRequestError('INVALID_RESET_TOKEN', 'Token 無效或已過期');
   }
   ```

2. **更新密碼**
   ```javascript
   const hashedPassword = await bcrypt.hash(newPassword, 12);
   await this.userRepository.updatePassword(resetRecord.email, hashedPassword);
   ```

3. **標記 Token 已使用**
4. **可選自動登入**

### 4.8 Endpoint: `/auth/bind-line`

#### LINE 綁定流程
1. **驗證 LINE Token**
   ```javascript
   const lineProfile = await this.lineAPIClient.getProfile(lineAccessToken);
   if (!lineProfile) {
     throw new UnauthorizedError('INVALID_LINE_TOKEN', 'LINE Token 無效');
   }
   ```

2. **檢查 LINE 帳號是否已綁定**
   ```javascript
   const existingBinding = await this.bindingRepository.findByLineUserId(lineUserId);
   if (existingBinding && existingBinding.userId !== currentUserId) {
     throw new ConflictError('LINE_ALREADY_BOUND', 'LINE 帳號已被其他使用者綁定');
   }
   ```

3. **建立綁定記錄**
   ```javascript
   const bindingData = {
     userId: currentUserId,
     platform: 'line',
     platformUserId: lineUserId,
     platformProfile: {
       displayName: lineProfile.displayName,
       pictureUrl: lineProfile.pictureUrl
     },
     bindingDate: new Date(),
     verified: true
   };
   
   await this.bindingRepository.create(bindingData);
   ```

### 4.9 Endpoint: `/auth/bind-status`

#### 綁定狀態查詢
1. **查詢所有綁定記錄**
   ```javascript
   const bindings = await this.bindingRepository.findByUserId(userId);
   ```

2. **格式化回應資料**
   ```javascript
   const linkedAccounts = {
     email: {
       value: user.email,
       verified: user.emailVerified,
       bindingDate: user.createdAt
     }
   };
   
   bindings.forEach(binding => {
     linkedAccounts[binding.platform] = {
       value: binding.platformUserId,
       verified: binding.verified,
       bindingDate: binding.bindingDate,
       profile: binding.platformProfile
     };
   });
   ```

---

## 5. 資料庫設計

### 5.1 ER 圖概念
```
Users ||--o{ AuthTokens : owns
Users ||--o{ PasswordResetTokens : requests
Users ||--o{ AccountBindings : has
Users ||--o{ EmailVerifications : requires
```

### 5.2 主要 Collection 設計

#### Users Collection
```javascript
{
  id: "string (UUID)",                    // 使用者唯一 ID
  email: "string",                        // Email 地址
  password: "string (hashed)",            // 加密密碼
  displayName: "string",                  // 顯示名稱
  avatar: "string (URL)",                 // 頭像 URL
  userMode: "Expert|Inertial|Cultivation|Guiding", // 使用者模式
  emailVerified: "boolean",               // Email 驗證狀態
  status: "active|inactive|locked",       // 帳號狀態
  authProvider: "email|google",           // 認證提供者
  googleId: "string",                     // Google ID (可選)
  preferences: {                          // 偏好設定
    language: "string",
    timezone: "string",
    theme: "light|dark|auto"
  },
  security: {                             // 安全設定
    loginFailures: "number",              // 登入失敗次數
    lastFailureAt: "timestamp",           // 最後失敗時間
    lockedUntil: "timestamp"              // 鎖定到期時間
  },
  createdAt: "timestamp",                 // 建立時間
  updatedAt: "timestamp",                 // 更新時間
  lastActiveAt: "timestamp"               // 最後活動時間
}
```

#### AuthTokens Collection
```javascript
{
  id: "string (UUID)",                    // Token ID
  userId: "string",                       // 使用者 ID
  tokenType: "access|refresh",            // Token 類型
  token: "string (hashed)",               // Token Hash
  deviceInfo: {                           // 設備資訊
    deviceId: "string",
    platform: "iOS|Android|Web",
    appVersion: "string",
    userAgent: "string"
  },
  ipAddress: "string",                    // IP 地址
  issuedAt: "timestamp",                  // 發行時間
  expiresAt: "timestamp",                 // 過期時間
  revokedAt: "timestamp",                 // 撤銷時間 (可選)
  lastUsedAt: "timestamp"                 // 最後使用時間
}
```

#### PasswordResetTokens Collection
```javascript
{
  id: "string (UUID)",                    // 重設 ID
  email: "string",                        // Email 地址
  token: "string (hashed)",               // 重設 Token Hash
  createdAt: "timestamp",                 // 建立時間
  expiresAt: "timestamp",                 // 過期時間
  used: "boolean",                        // 是否已使用
  usedAt: "timestamp",                    // 使用時間 (可選)
  ipAddress: "string"                     // 請求 IP
}
```

#### AccountBindings Collection
```javascript
{
  id: "string (UUID)",                    // 綁定 ID
  userId: "string",                       // 使用者 ID
  platform: "line|google",               // 平台類型
  platformUserId: "string",               // 平台使用者 ID
  platformProfile: {                     // 平台個人資料
    displayName: "string",
    pictureUrl: "string",
    email: "string"
  },
  bindingDate: "timestamp",               // 綁定時間
  verified: "boolean",                    // 驗證狀態
  lastSyncAt: "timestamp"                 // 最後同步時間
}
```

#### EmailVerifications Collection
```javascript
{
  id: "string (UUID)",                    // 驗證 ID
  email: "string",                        // Email 地址
  code: "string (6-digit)",               // 驗證碼
  token: "string (UUID)",                 // 驗證 Token
  type: "registration|email_change",      // 驗證類型
  createdAt: "timestamp",                 // 建立時間
  expiresAt: "timestamp",                 // 過期時間
  verified: "boolean",                    // 驗證狀態
  verifiedAt: "timestamp",                // 驗證時間 (可選)
  attempts: "number"                      // 嘗試次數
}
```

### 5.3 索引設計
```javascript
// Users Collection 索引
db.users.createIndex({ email: 1 }, { unique: true });
db.users.createIndex({ googleId: 1 }, { sparse: true });
db.users.createIndex({ status: 1 });
db.users.createIndex({ createdAt: -1 });

// AuthTokens Collection 索引
db.authTokens.createIndex({ userId: 1 });
db.authTokens.createIndex({ expiresAt: 1 });
db.authTokens.createIndex({ "deviceInfo.deviceId": 1 });

// PasswordResetTokens Collection 索引
db.passwordResetTokens.createIndex({ email: 1 });
db.passwordResetTokens.createIndex({ token: 1 }, { unique: true });
db.passwordResetTokens.createIndex({ expiresAt: 1 });

// AccountBindings Collection 索引
db.accountBindings.createIndex({ userId: 1 });
db.accountBindings.createIndex({ platform: 1, platformUserId: 1 }, { unique: true });

// EmailVerifications Collection 索引
db.emailVerifications.createIndex({ email: 1 });
db.emailVerifications.createIndex({ token: 1 }, { unique: true });
db.emailVerifications.createIndex({ expiresAt: 1 });
```

---

## 6. 安全與驗證

### 6.1 JWT Token 策略

#### Access Token 設計
```javascript
{
  "iss": "lcas-api",                      // 發行者
  "sub": "user-uuid",                     // 主體 (使用者 ID)
  "aud": "lcas-app",                      // 受眾
  "exp": 1640995200,                      // 過期時間 (1小時)
  "iat": 1640991600,                      // 發行時間
  "jti": "token-uuid",                    // Token ID
  "scope": "read write",                  // 權限範圍
  "userMode": "Expert",                   // 使用者模式
  "email": "user@example.com"             // Email
}
```

#### Refresh Token 設計
```javascript
{
  "iss": "lcas-api",
  "sub": "user-uuid",
  "exp": 1643587200,                      // 過期時間 (30天)
  "iat": 1640991600,
  "jti": "refresh-token-uuid",
  "type": "refresh"                       // Token 類型
}
```

### 6.2 密碼安全策略

#### 密碼加密
```javascript
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 12;

const hashPassword = async (password) => {
  return await bcrypt.hash(password, SALT_ROUNDS);
};

const verifyPassword = async (password, hash) => {
  return await bcrypt.compare(password, hash);
};
```

#### 密碼強度驗證
```javascript
const validatePassword = (password) => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  const errors = [];
  
  if (password.length < minLength) {
    errors.push('密碼長度至少需要 8 個字元');
  }
  
  if (!hasUpperCase) {
    errors.push('密碼需包含至少一個大寫字母');
  }
  
  if (!hasLowerCase) {
    errors.push('密碼需包含至少一個小寫字母');
  }
  
  if (!hasNumbers) {
    errors.push('密碼需包含至少一個數字');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};
```

### 6.3 OAuth Token 驗證

#### Google OAuth 驗證
```javascript
const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

const verifyGoogleToken = async (token) => {
  try {
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID
    });
    
    const payload = ticket.getPayload();
    return {
      id: payload.sub,
      email: payload.email,
      name: payload.name,
      picture: payload.picture,
      emailVerified: payload.email_verified
    };
  } catch (error) {
    throw new UnauthorizedError('INVALID_GOOGLE_TOKEN', 'Google Token 驗證失敗');
  }
};
```

### 6.4 跨平台綁定安全檢查

#### LINE Token 驗證
```javascript
const verifyLineToken = async (accessToken) => {
  try {
    const response = await axios.get('https://api.line.me/v2/profile', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    
    return response.data;
  } catch (error) {
    throw new UnauthorizedError('INVALID_LINE_TOKEN', 'LINE Token 驗證失敗');
  }
};
```

#### 綁定安全檢查
```javascript
const validateBinding = async (userId, platform, platformUserId) => {
  // 檢查是否已被其他使用者綁定
  const existingBinding = await bindingRepository.findByPlatformUser(platform, platformUserId);
  
  if (existingBinding && existingBinding.userId !== userId) {
    throw new ConflictError('ALREADY_BOUND', `${platform} 帳號已被其他使用者綁定`);
  }
  
  // 檢查同一使用者是否重複綁定
  const userBinding = await bindingRepository.findByUserAndPlatform(userId, platform);
  
  if (userBinding) {
    throw new ConflictError('DUPLICATE_BINDING', `您已綁定此 ${platform} 帳號`);
  }
  
  return true;
};
```

### 6.5 安全中介層

#### Rate Limiting
```javascript
const rateLimit = require('express-rate-limit');

const authRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 分鐘
  max: 5, // 最多 5 次嘗試
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: '登入嘗試次數過多，請稍後再試'
    }
  },
  standardHeaders: true,
  legacyHeaders: false
});
```

#### 帳號鎖定機制
```javascript
const checkAccountLock = async (email) => {
  const user = await userRepository.findByEmail(email);
  
  if (user && user.security.lockedUntil && new Date() < user.security.lockedUntil) {
    throw new ForbiddenError('ACCOUNT_LOCKED', '帳號暫時被鎖定，請稍後再試');
  }
  
  return true;
};

const handleLoginFailure = async (email) => {
  const user = await userRepository.findByEmail(email);
  
  if (user) {
    const failures = (user.security.loginFailures || 0) + 1;
    const updateData = {
      'security.loginFailures': failures,
      'security.lastFailureAt': new Date()
    };
    
    // 5 次失敗後鎖定 30 分鐘
    if (failures >= 5) {
      updateData['security.lockedUntil'] = new Date(Date.now() + 30 * 60 * 1000);
    }
    
    await userRepository.updateSecurity(user.id, updateData);
  }
};
```

---

## 7. 錯誤處理

### 7.1 錯誤分類與處理

#### 認證相關錯誤
```javascript
class AuthenticationError extends Error {
  constructor(code, message, field = null) {
    super(message);
    this.name = 'AuthenticationError';
    this.code = code;
    this.field = field;
    this.httpStatus = 401;
  }
}

// 使用範例
throw new AuthenticationError('INVALID_CREDENTIALS', 'Email 或密碼錯誤');
throw new AuthenticationError('TOKEN_EXPIRED', 'Token 已過期');
throw new AuthenticationError('ACCOUNT_LOCKED', '帳號已被鎖定');
```

#### 驗證錯誤
```javascript
class ValidationError extends Error {
  constructor(code, message, field = null, value = null) {
    super(message);
    this.name = 'ValidationError';
    this.code = code;
    this.field = field;
    this.value = value;
    this.httpStatus = 400;
  }
}

// 使用範例
throw new ValidationError('INVALID_EMAIL', 'Email 格式無效', 'email', 'invalid-email');
throw new ValidationError('WEAK_PASSWORD', '密碼強度不足', 'password');
```

#### 業務邏輯錯誤
```javascript
class BusinessError extends Error {
  constructor(code, message, details = null) {
    super(message);
    this.name = 'BusinessError';
    this.code = code;
    this.details = details;
    this.httpStatus = 422;
  }
}

// 使用範例
throw new BusinessError('EMAIL_ALREADY_EXISTS', '此 Email 已被註冊');
throw new BusinessError('LINE_ALREADY_BOUND', 'LINE 帳號已被其他使用者綁定');
```

### 7.2 統一錯誤處理中介層

```javascript
const errorHandler = (error, req, res, next) => {
  const requestId = req.headers['x-request-id'] || generateUUID();
  const timestamp = new Date().toISOString();
  
  // 記錄錯誤日誌
  logger.error({
    requestId,
    error: {
      name: error.name,
      message: error.message,
      code: error.code,
      stack: error.stack
    },
    request: {
      method: req.method,
      url: req.url,
      headers: req.headers,
      body: req.body
    }
  });
  
  // 建構錯誤回應
  const errorResponse = {
    success: false,
    error: {
      code: error.code || 'INTERNAL_SERVER_ERROR',
      message: error.message || '內部伺服器錯誤',
      field: error.field || null,
      timestamp,
      requestId
    }
  };
  
  // 在開發環境中添加詳細資訊
  if (process.env.NODE_ENV === 'development') {
    errorResponse.error.details = {
      stack: error.stack,
      cause: error.cause
    };
  }
  
  // 驗證錯誤的詳細資訊
  if (error.name === 'ValidationError' && error.details) {
    errorResponse.error.details = {
      validation: error.details
    };
  }
  
  const httpStatus = error.httpStatus || 500;
  res.status(httpStatus).json(errorResponse);
};
```

### 7.3 特定錯誤處理策略

#### JWT 錯誤處理
```javascript
const handleJWTError = (error) => {
  if (error.name === 'TokenExpiredError') {
    return new AuthenticationError('TOKEN_EXPIRED', 'Token 已過期');
  }
  
  if (error.name === 'JsonWebTokenError') {
    return new AuthenticationError('INVALID_TOKEN', 'Token 格式無效');
  }
  
  if (error.name === 'NotBeforeError') {
    return new AuthenticationError('TOKEN_NOT_ACTIVE', 'Token 尚未生效');
  }
  
  return new AuthenticationError('TOKEN_ERROR', 'Token 驗證失敗');
};
```

#### 資料庫錯誤處理
```javascript
const handleDatabaseError = (error) => {
  if (error.code === 11000) {
    // MongoDB 重複鍵錯誤
    const field = Object.keys(error.keyPattern)[0];
    return new BusinessError('DUPLICATE_RESOURCE', `${field} 已存在`, { field });
  }
  
  if (error.name === 'CastError') {
    return new ValidationError('INVALID_ID', 'ID 格式無效');
  }
  
  return new Error('DATABASE_ERROR', '資料庫操作失敗');
};
```

---

## 8. 日誌與監控

### 8.1 請求與回應日誌

#### 請求日誌格式
```javascript
const requestLogger = (req, res, next) => {
  const requestId = req.headers['x-request-id'] || generateUUID();
  req.requestId = requestId;
  
  const logData = {
    requestId,
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.url,
    userAgent: req.headers['user-agent'],
    ip: req.ip,
    userMode: req.headers['x-user-mode'],
    userId: req.user?.id || null
  };
  
  // 敏感資料遮罩
  if (req.body) {
    logData.body = maskSensitiveData(req.body);
  }
  
  logger.info('Request received', logData);
  next();
};
```

#### 回應日誌格式
```javascript
const responseLogger = (req, res, next) => {
  const originalSend = res.send;
  
  res.send = function(data) {
    const logData = {
      requestId: req.requestId,
      timestamp: new Date().toISOString(),
      statusCode: res.statusCode,
      responseTime: Date.now() - req.startTime,
      contentLength: Buffer.byteLength(data || '', 'utf8')
    };
    
    if (res.statusCode >= 400) {
      logData.errorResponse = JSON.parse(data);
    }
    
    logger.info('Response sent', logData);
    originalSend.call(this, data);
  };
  
  next();
};
```

### 8.2 認證事件日誌

#### 登入事件
```javascript
const logLoginAttempt = (email, success, reason = null, deviceInfo = null) => {
  logger.info('Login attempt', {
    event: 'LOGIN_ATTEMPT',
    email: maskEmail(email),
    success,
    reason,
    deviceInfo,
    timestamp: new Date().toISOString(),
    ip: req.ip
  });
};

const logLoginSuccess = (userId, userMode, deviceInfo) => {
  logger.info('Login successful', {
    event: 'LOGIN_SUCCESS',
    userId,
    userMode,
    deviceInfo,
    timestamp: new Date().toISOString()
  });
};
```

#### Token 使用日誌
```javascript
const logTokenUsage = (tokenId, userId, action, endpoint) => {
  logger.info('Token usage', {
    event: 'TOKEN_USAGE',
    tokenId,
    userId,
    action, // 'issued', 'refreshed', 'revoked', 'expired'
    endpoint,
    timestamp: new Date().toISOString()
  });
};
```

#### 綁定事件日誌
```javascript
const logBindingEvent = (userId, platform, action, platformUserId = null) => {
  logger.info('Account binding', {
    event: 'ACCOUNT_BINDING',
    userId,
    platform,
    action, // 'bind', 'unbind', 'verify'
    platformUserId: platformUserId ? maskId(platformUserId) : null,
    timestamp: new Date().toISOString()
  });
};
```

### 8.3 監控指標

#### 認證系統關鍵指標
```javascript
const metrics = {
  // 註冊相關
  registrations_total: new prometheus.Counter({
    name: 'auth_registrations_total',
    help: 'Total number of user registrations',
    labelNames: ['user_mode', 'auth_provider']
  }),
  
  // 登入相關
  login_attempts_total: new prometheus.Counter({
    name: 'auth_login_attempts_total',
    help: 'Total number of login attempts',
    labelNames: ['result', 'auth_provider'] // result: success, failure, locked
  }),
  
  login_duration: new prometheus.Histogram({
    name: 'auth_login_duration_seconds',
    help: 'Login process duration',
    buckets: [0.1, 0.5, 1, 2, 5]
  }),
  
  // Token 相關
  tokens_issued_total: new prometheus.Counter({
    name: 'auth_tokens_issued_total',
    help: 'Total number of tokens issued',
    labelNames: ['token_type'] // access, refresh
  }),
  
  token_refresh_total: new prometheus.Counter({
    name: 'auth_token_refresh_total',
    help: 'Total number of token refreshes',
    labelNames: ['result'] // success, failure
  }),
  
  // 綁定相關
  bindings_total: new prometheus.Counter({
    name: 'auth_bindings_total',
    help: 'Total number of account bindings',
    labelNames: ['platform', 'result'] // platform: line, google
  }),
  
  // 錯誤相關
  errors_total: new prometheus.Counter({
    name: 'auth_errors_total',
    help: 'Total number of authentication errors',
    labelNames: ['error_code', 'endpoint']
  })
};
```

#### 監控告警規則
```yaml
# Prometheus 告警規則
groups:
  - name: auth_service_alerts
    rules:
      - alert: HighLoginFailureRate
        expr: rate(auth_login_attempts_total{result="failure"}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "高登入失敗率檢測"
          description: "過去 5 分鐘內登入失敗率超過 10%"
      
      - alert: AuthServiceDown
        expr: up{job="auth-service"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "認證服務停機"
          description: "認證服務無法存取"
      
      - alert: HighTokenRefreshFailure
        expr: rate(auth_token_refresh_total{result="failure"}[5m]) > 0.05
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "Token 刷新失敗率過高"
          description: "Token 刷新失敗率超過 5%"
```

### 8.4 安全監控

#### 異常行為檢測
```javascript
const detectAnomalousActivity = async (userId, activity) => {
  const recentActivity = await getRecentActivity(userId, '1h');
  
  // 檢測同一 IP 多次登入失敗
  if (activity.type === 'login_failure') {
    const failures = recentActivity.filter(a => 
      a.type === 'login_failure' && 
      a.ip === activity.ip
    ).length;
    
    if (failures >= 5) {
      await triggerSecurityAlert('SUSPICIOUS_LOGIN_ACTIVITY', {
        userId,
        ip: activity.ip,
        failureCount: failures
      });
    }
  }
  
  // 檢測異常地理位置登入
  if (activity.type === 'login_success') {
    const lastLocation = await getLastLoginLocation(userId);
    const currentLocation = await getLocationByIP(activity.ip);
    
    if (lastLocation && calculateDistance(lastLocation, currentLocation) > 1000) {
      await triggerSecurityAlert('UNUSUAL_LOCATION_LOGIN', {
        userId,
        lastLocation,
        currentLocation
      });
    }
  }
};
```

#### 安全事件回應
```javascript
const triggerSecurityAlert = async (alertType, details) => {
  const alertData = {
    type: alertType,
    severity: getSeverityLevel(alertType),
    details,
    timestamp: new Date().toISOString(),
    resolved: false
  };
  
  // 記錄安全事件
  await securityEventRepository.create(alertData);
  
  // 發送通知
  if (alertData.severity === 'high') {
    await notificationService.sendSecurityAlert(alertData);
  }
  
  // 自動回應措施
  await executeAutomatedResponse(alertType, details);
};
```

---

## 9. 測試設計

### 9.1 單元測試

#### AuthService 測試
```javascript
describe('AuthService', () => {
  let authService;
  let mockUserRepository;
  let mockTokenService;
  let mockEmailService;
  
  beforeEach(() => {
    mockUserRepository = {
      findByEmail: jest.fn(),
      create: jest.fn(),
      updateLoginHistory: jest.fn()
    };
    
    mockTokenService = {
      generateAccessToken: jest.fn(),
      generateRefreshToken: jest.fn(),
      verifyToken: jest.fn()
    };
    
    mockEmailService = {
      sendVerificationEmail: jest.fn()
    };
    
    authService = new AuthService(
      mockUserRepository,
      mockTokenService,
      mockEmailService
    );
  });
  
  describe('registerUser', () => {
    it('should successfully register a new user', async () => {
      // Arrange
      const userData = {
        email: 'test@example.com',
        password: 'securePassword123',
        userMode: 'Expert',
        acceptTerms: true
      };
      
      mockUserRepository.findByEmail.mockResolvedValue(null);
      mockUserRepository.create.mockResolvedValue({ id: 'user-123' });
      mockTokenService.generateAccessToken.mockReturnValue('access-token');
      mockTokenService.generateRefreshToken.mockReturnValue('refresh-token');
      
      // Act
      const result = await authService.registerUser(userData);
      
      // Assert
      expect(result).toHaveProperty('userId');
      expect(result).toHaveProperty('token');
      expect(mockUserRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          email: userData.email,
          userMode: userData.userMode
        })
      );
      expect(mockEmailService.sendVerificationEmail).toHaveBeenCalled();
    });
    
    it('should throw error when email already exists', async () => {
      // Arrange
      const userData = {
        email: 'existing@example.com',
        password: 'securePassword123',
        userMode: 'Expert',
        acceptTerms: true
      };
      
      mockUserRepository.findByEmail.mockResolvedValue({ id: 'existing-user' });
      
      // Act & Assert
      await expect(authService.registerUser(userData))
        .rejects
        .toThrow('EMAIL_ALREADY_EXISTS');
    });
  });
  
  describe('authenticateUser', () => {
    it('should successfully authenticate valid credentials', async () => {
      // Arrange
      const email = 'test@example.com';
      const password = 'correctPassword';
      const hashedPassword = await bcrypt.hash(password, 12);
      
      const mockUser = {
        id: 'user-123',
        email,
        password: hashedPassword,
        status: 'active'
      };
      
      mockUserRepository.findByEmail.mockResolvedValue(mockUser);
      mockTokenService.generateAccessToken.mockReturnValue('access-token');
      mockTokenService.generateRefreshToken.mockReturnValue('refresh-token');
      
      // Act
      const result = await authService.authenticateUser(email, password);
      
      // Assert
      expect(result).toHaveProperty('token');
      expect(result).toHaveProperty('user');
      expect(mockUserRepository.updateLoginHistory).toHaveBeenCalled();
    });
    
    it('should throw error for invalid credentials', async () => {
      // Arrange
      mockUserRepository.findByEmail.mockResolvedValue(null);
      
      // Act & Assert
      await expect(authService.authenticateUser('invalid@example.com', 'wrongPassword'))
        .rejects
        .toThrow('INVALID_CREDENTIALS');
    });
  });
});
```

#### TokenService 測試
```javascript
describe('TokenService', () => {
  let tokenService;
  
  beforeEach(() => {
    tokenService = new TokenService('test-secret', 'test-refresh-secret');
  });
  
  describe('generateAccessToken', () => {
    it('should generate valid access token', () => {
      // Arrange
      const userData = {
        id: 'user-123',
        email: 'test@example.com',
        userMode: 'Expert'
      };
      
      // Act
      const token = tokenService.generateAccessToken(userData);
      
      // Assert
      expect(token).toBeDefined();
      expect(typeof token).toBe('string');
      
      // 驗證 token 內容
      const decoded = jwt.verify(token, 'test-secret');
      expect(decoded.sub).toBe(userData.id);
      expect(decoded.email).toBe(userData.email);
      expect(decoded.userMode).toBe(userData.userMode);
    });
  });
  
  describe('verifyAccessToken', () => {
    it('should verify valid token', () => {
      // Arrange
      const userData = { id: 'user-123', email: 'test@example.com' };
      const token = tokenService.generateAccessToken(userData);
      
      // Act
      const result = tokenService.verifyAccessToken(token);
      
      // Assert
      expect(result).toBeDefined();
      expect(result.sub).toBe(userData.id);
    });
    
    it('should throw error for invalid token', () => {
      // Act & Assert
      expect(() => tokenService.verifyAccessToken('invalid-token'))
        .toThrow();
    });
  });
});
```

### 9.2 API 測試

#### 註冊 API 測試
```javascript
describe('POST /auth/register', () => {
  it('should register user successfully', async () => {
    // Arrange
    const requestData = {
      email: 'newuser@example.com',
      password: 'securePassword123',
      userMode: 'Expert',
      acceptTerms: true,
      acceptPrivacy: true
    };
    
    // Act
    const response = await request(app)
      .post('/auth/register')
      .send(requestData)
      .expect(201);
    
    // Assert
    expect(response.body.success).toBe(true);
    expect(response.body.data).toHaveProperty('userId');
    expect(response.body.data).toHaveProperty('token');
    expect(response.body.data.email).toBe(requestData.email);
    expect(response.body.data.userMode).toBe(requestData.userMode);
  });
  
  it('should return validation error for invalid email', async () => {
    // Arrange
    const requestData = {
      email: 'invalid-email',
      password: 'securePassword123',
      userMode: 'Expert',
      acceptTerms: true
    };
    
    // Act
    const response = await request(app)
      .post('/auth/register')
      .send(requestData)
      .expect(400);
    
    // Assert
    expect(response.body.success).toBe(false);
    expect(response.body.error.code).toBe('VALIDATION_ERROR');
    expect(response.body.error.field).toBe('email');
  });
  
  it('should return conflict error for existing email', async () => {
    // Arrange - 先註冊一個使用者
    await request(app)
      .post('/auth/register')
      .send({
        email: 'existing@example.com',
        password: 'password123',
        userMode: 'Expert',
        acceptTerms: true
      });
    
    // Act - 嘗試使用相同 email 註冊
    const response = await request(app)
      .post('/auth/register')
      .send({
        email: 'existing@example.com',
        password: 'differentPassword123',
        userMode: 'Inertial',
        acceptTerms: true
      })
      .expect(409);
    
    // Assert
    expect(response.body.success).toBe(false);
    expect(response.body.error.code).toBe('EMAIL_ALREADY_EXISTS');
  });
});
```

#### 登入 API 測試
```javascript
describe('POST /auth/login', () => {
  let testUser;
  
  beforeEach(async () => {
    // 建立測試使用者
    testUser = await createTestUser({
      email: 'test@example.com',
      password: 'testPassword123',
      userMode: 'Expert'
    });
  });
  
  it('should login successfully with valid credentials', async () => {
    // Act
    const response = await request(app)
      .post('/auth/login')
      .send({
        email: 'test@example.com',
        password: 'testPassword123'
      })
      .expect(200);
    
    // Assert
    expect(response.body.success).toBe(true);
    expect(response.body.data).toHaveProperty('token');
    expect(response.body.data).toHaveProperty('refreshToken');
    expect(response.body.data.user.email).toBe(testUser.email);
  });
  
  it('should return error for invalid credentials', async () => {
    // Act
    const response = await request(app)
      .post('/auth/login')
      .send({
        email: 'test@example.com',
        password: 'wrongPassword'
      })
      .expect(401);
    
    // Assert
    expect(response.body.success).toBe(false);
    expect(response.body.error.code).toBe('INVALID_CREDENTIALS');
  });
});
```

### 9.3 四模式差異化驗證測試

```javascript
describe('User Mode Adaptation', () => {
  let testUser;
  
  beforeEach(async () => {
    testUser = await createTestUser({
      email: 'test@example.com',
      password: 'password123',
      userMode: 'Expert'
    });
  });
  
  describe('Login Response Adaptation', () => {
    it('should return Expert mode response with detailed info', async () => {
      // Act
      const response = await request(app)
        .post('/auth/login')
        .set('X-User-Mode', 'Expert')
        .send({
          email: 'test@example.com',
          password: 'password123'
        })
        .expect(200);
      
      // Assert
      expect(response.body.data).toHaveProperty('loginHistory');
      expect(response.body.data).toHaveProperty('securityInfo');
      expect(response.body.metadata.userMode).toBe('Expert');
    });
    
    it('should return Guiding mode response with simplified info', async () => {
      // Arrange
      await updateUserMode(testUser.id, 'Guiding');
      
      // Act
      const response = await request(app)
        .post('/auth/login')
        .set('X-User-Mode', 'Guiding')
        .send({
          email: 'test@example.com',
          password: 'password123'
        })
        .expect(200);
      
      // Assert
      expect(response.body.data).not.toHaveProperty('loginHistory');
      expect(response.body.data).not.toHaveProperty('securityInfo');
      expect(response.body.data).toHaveProperty('message');
      expect(response.body.metadata.userMode).toBe('Guiding');
    });
    
    it('should return Cultivation mode response with achievement info', async () => {
      // Arrange
      await updateUserMode(testUser.id, 'Cultivation');
      
      // Act
      const response = await request(app)
        .post('/auth/login')
        .set('X-User-Mode', 'Cultivation')
        .send({
          email: 'test@example.com',
          password: 'password123'
        })
        .expect(200);
      
      // Assert
      expect(response.body.data).toHaveProperty('streakInfo');
      expect(response.body.data).toHaveProperty('achievements');
      expect(response.body.metadata.userMode).toBe('Cultivation');
    });
  });
});
```

### 9.4 整合測試

#### 完整認證流程測試
```javascript
describe('Complete Authentication Flow', () => {
  it('should complete registration to login flow', async () => {
    // Step 1: Register
    const registerResponse = await request(app)
      .post('/auth/register')
      .send({
        email: 'flowtest@example.com',
        password: 'securePassword123',
        userMode: 'Expert',
        acceptTerms: true
      })
      .expect(201);
    
    expect(registerResponse.body.data).toHaveProperty('userId');
    const userId = registerResponse.body.data.userId;
    
    // Step 2: Verify Email (模擬)
    await request(app)
      .post('/auth/verify-email')
      .send({
        email: 'flowtest@example.com',
        verificationCode: '123456' // 測試環境固定碼
      })
      .expect(200);
    
    // Step 3: Login
    const loginResponse = await request(app)
      .post('/auth/login')
      .send({
        email: 'flowtest@example.com',
        password: 'securePassword123'
      })
      .expect(200);
    
    expect(loginResponse.body.data.user.id).toBe(userId);
    
    // Step 4: Use Token to Access Protected Resource
    const token = loginResponse.body.data.token;
    const profileResponse = await request(app)
      .get('/users/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);
    
    expect(profileResponse.body.data.id).toBe(userId);
  });
});
```

#### OAuth 整合測試
```javascript
describe('OAuth Integration', () => {
  it('should handle Google OAuth login flow', async () => {
    // 模擬 Google Token
    const mockGoogleToken = 'mock-google-token';
    
    // 模擬 Google API 回應
    nock('https://www.googleapis.com')
      .get('/oauth2/v3/tokeninfo')
      .query({ id_token: mockGoogleToken })
      .reply(200, {
        sub: 'google-user-123',
        email: 'googleuser@example.com',
        name: 'Google User',
        picture: 'https://example.com/avatar.jpg',
        email_verified: true
      });
    
    // Act
    const response = await request(app)
      .post('/auth/google-login')
      .send({
        googleToken: mockGoogleToken,
        userMode: 'Expert'
      })
      .expect(200);
    
    // Assert
    expect(response.body.data.isNewUser).toBe(true);
    expect(response.body.data.user.email).toBe('googleuser@example.com');
    expect(response.body.data).toHaveProperty('token');
  });
});
```

### 9.5 邊界條件與異常測試

#### 安全測試
```javascript
describe('Security Tests', () => {
  it('should handle rate limiting', async () => {
    const email = 'ratetest@example.com';
    
    // 快速進行多次登入嘗試
    const promises = Array(6).fill().map(() => 
      request(app)
        .post('/auth/login')
        .send({
          email,
          password: 'wrongPassword'
        })
    );
    
    const responses = await Promise.all(promises);
    
    // 檢查是否有被限制的請求
    const rateLimitedResponses = responses.filter(res => res.status === 429);
    expect(rateLimitedResponses.length).toBeGreaterThan(0);
  });
  
  it('should lock account after multiple failures', async () => {
    // 建立測試使用者
    await createTestUser({
      email: 'locktest@example.com',
      password: 'correctPassword123'
    });
    
    // 進行 5 次錯誤登入
    for (let i = 0; i < 5; i++) {
      await request(app)
        .post('/auth/login')
        .send({
          email: 'locktest@example.com',
          password: 'wrongPassword'
        });
    }
    
    // 嘗試正確密碼登入，應該被鎖定
    const response = await request(app)
      .post('/auth/login')
      .send({
        email: 'locktest@example.com',
        password: 'correctPassword123'
      })
      .expect(423);
    
    expect(response.body.error.code).toBe('ACCOUNT_LOCKED');
  });
});
```

#### 效能測試
```javascript
describe('Performance Tests', () => {
  it('should handle concurrent login requests', async () => {
    // 建立多個測試使用者
    const users = await Promise.all(
      Array(10).fill().map((_, i) => 
        createTestUser({
          email: `perf${i}@example.com`,
          password: 'password123'
        })
      )
    );
    
    const startTime = Date.now();
    
    // 同時進行多個登入請求
    const promises = users.map(user => 
      request(app)
        .post('/auth/login')
        .send({
          email: user.email,
          password: 'password123'
        })
    );
    
    const responses = await Promise.all(promises);
    const endTime = Date.now();
    
    // 檢查所有請求都成功
    responses.forEach(response => {
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
    });
    
    // 檢查總執行時間（應該小於 5 秒）
    expect(endTime - startTime).toBeLessThan(5000);
  });
});
```

---

## 附錄

### A. 環境配置
```javascript
// config/auth.js
module.exports = {
  jwt: {
    secret: process.env.JWT_SECRET,
    refreshSecret: process.env.JWT_REFRESH_SECRET,
    accessTokenExpiry: '1h',
    refreshTokenExpiry: '30d'
  },
  
  bcrypt: {
    saltRounds: 12
  },
  
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5 // 5 attempts per window
  },
  
  accountLock: {
    maxFailures: 5,
    lockDuration: 30 * 60 * 1000 // 30 minutes
  },
  
  oauth: {
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET
    }
  },
  
  line: {
    channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN
  }
};
```

### B. 部署注意事項
1. **環境變數設定**：確保所有敏感資訊透過環境變數設定
2. **SSL/TLS 配置**：生產環境必須使用 HTTPS
3. **資料庫連線**：配置連線池與失敗重試機制
4. **日誌輪轉**：設定適當的日誌保留政策
5. **監控告警**：配置關鍵指標的監控與告警

### C. 安全檢查清單
- [ ] 密碼加密使用足夠強度的 hash 演算法
- [ ] JWT Secret 使用強密碼且定期輪換
- [ ] 實作 Rate Limiting 防止暴力攻擊
- [ ] 設定帳號鎖定機制
- [ ] 敏感資料日誌遮罩
- [ ] OAuth Token 驗證
- [ ] HTTPS 強制使用
- [ ] CORS 正確配置
- [ ] 輸入驗證與 SQL 注入防護

---

**文件完成日期**: 2025-01-27  
**版本**: 1.0  
**維護者**: LCAS 開發團隊
