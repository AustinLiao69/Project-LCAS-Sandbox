
# LCAS 2.0 認證服務 API - Low Level Design (LLD)

## 版本資訊
- 文件版本: 1.2.0
- API 版本: 1.1.0
- 日期: 2025-08-27
- 作者: LCAS 開發團隊

---

## 目錄
1. 簡介
2. 架構設計
3. 模組與類別設計
4. API 清單
5. API 詳細實作設計
6. 資料庫設計
7. 安全與驗證
8. 錯誤處理
9. 日誌與監控
10. 測試設計

---

## 1. 簡介

### 1.1 API 目的與範圍
認證服務 API 提供 LCAS 2.0 系統的完整認證功能，包括使用者註冊、登入、密碼管理、跨平台綁定等核心認證機制。本文件採用 **Dart** 語言實作客戶端 API 介面。

### 1.2 核心功能列表
- **使用者認證**：註冊、登入、登出
- **密碼管理**：忘記密碼、重設密碼、密碼加密
- **Token 管理**：JWT 生成、驗證、刷新
- **OAuth 整合**：Google OAuth 登入
- **跨平台綁定**：LINE 帳號綁定與狀態查詢
- **Email 驗證**：註冊驗證、地址驗證

### 1.3 支援的四種使用者模式
- **Expert**：完整認證選項、詳細安全資訊、進階設定
- **Inertial**：標準認證流程、基本安全提示、固定選項
- **Cultivation**：引導式認證、安全教育內容、進度追蹤
- **Guiding**：極簡認證、最少必要步驟、簡化流程

---

## 2. 架構設計

### 2.1 系統架構圖
```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│    (Flutter APP + LINE OA)             │
├─────────────────────────────────────────┤
│         API Gateway Layer               │
│    ┌─────────────────────────────────┐  │
│    │  認證中介層 (Auth Middleware)    │  │
│    │  - JWT 驗證                     │  │
│    │  - 模式判斷                     │  │
│    │  - 請求日誌                     │  │
│    └─────────────────────────────────┘  │
├─────────────────────────────────────────┤
│         Service Layer                   │
│    ┌─────────────────────────────────┐  │
│    │  認證服務 (AuthService)          │  │
│    │  - 登入/註冊邏輯                │  │
│    │  - 密碼管理                     │  │
│    │  - Token 管理                   │  │
│    └─────────────────────────────────┘  │
│    ┌─────────────────────────────────┐  │
│    │  OAuth 服務 (OAuthService)      │  │
│    │  - Google OAuth                 │  │
│    │  - 第三方驗證                   │  │
│    └─────────────────────────────────┘  │
│    ┌─────────────────────────────────┐  │
│    │  綁定服務 (BindingService)      │  │
│    │  - LINE 綁定                    │  │
│    │  - 綁定狀態管理                 │  │
│    └─────────────────────────────────┘  │
├─────────────────────────────────────────┤
│         Data Layer                      │
│           (Firestore)                   │
│    - Users Collection                   │
│    - AuthTokens Collection              │
│    - PasswordResetTokens Collection     │
│    - AccountBindings Collection         │
└─────────────────────────────────────────┘
```

### 2.2 模組間依賴圖
```
AuthController
    ├── AuthService
    │   ├── UserRepository
    │   ├── TokenService
    │   └── EmailService
    ├── OAuthService
    │   ├── GoogleOAuthProvider
    │   └── TokenService
    └── BindingService
        ├── LineAPIClient
        └── BindingRepository
```

### 2.3 外部服務整合
- **Google OAuth 2.0**：第三方登入驗證
- **LINE API**：帳號綁定與狀態查詢
- **Email Service**：驗證信發送
- **Firestore**：使用者資料儲存

---

## 3. 模組與類別設計

### 3.1 AuthController 類別 (Dart)
```dart
class AuthController {
  final AuthService _authService;
  final OAuthService _oauthService;
  final BindingService _bindingService;

  AuthController({
    required AuthService authService,
    required OAuthService oauthService,
    required BindingService bindingService,
  }) : _authService = authService,
       _oauthService = oauthService,
       _bindingService = bindingService;

  Future<ApiResponse<RegisterResponse>> register(RegisterRequest request) async {
    try {
      final result = await _authService.registerUser(request);
      return ApiResponse.success(
        data: result,
        metadata: ApiMetadata.create(request.userMode),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<LoginResponse>> login(LoginRequest request) async {
    try {
      final result = await _authService.authenticateUser(
        request.email,
        request.password,
      );
      
      // 四模式差異化處理
      final adaptedResult = UserModeAdapter.adaptLoginResponse(
        result,
        result.user.userMode,
      );
      
      return ApiResponse.success(
        data: adaptedResult,
        metadata: ApiMetadata.create(result.user.userMode),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<void>> logout(LogoutRequest request) async {
    try {
      await _authService.logoutUser(request);
      return ApiResponse.success(
        data: null,
        metadata: ApiMetadata.create(UserMode.inertial), // 登出後使用預設模式
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<RefreshTokenResponse>> refreshToken(String refreshToken) async {
    try {
      final result = await _authService.refreshToken(refreshToken);
      return ApiResponse.success(
        data: result,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<void>> forgotPassword(ForgotPasswordRequest request) async {
    try {
      await _authService.sendPasswordResetEmail(request.email);
      return ApiResponse.success(
        data: null,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String token) async {
    try {
      final result = await _authService.verifyResetToken(token);
      return ApiResponse.success(
        data: result,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<void>> resetPassword(ResetPasswordRequest request) async {
    try {
      await _authService.resetPassword(request.token, request.newPassword);
      return ApiResponse.success(
        data: null,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest request) async {
    try {
      await _authService.verifyEmail(request.email, request.verificationCode);
      return ApiResponse.success(
        data: null,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<LoginResponse>> googleLogin(GoogleLoginRequest request) async {
    try {
      final result = await _oauthService.authenticateWithGoogle(request.googleToken);
      
      // 四模式差異化處理
      final adaptedResult = UserModeAdapter.adaptLoginResponse(
        result,
        result.user.userMode,
      );
      
      return ApiResponse.success(
        data: adaptedResult,
        metadata: ApiMetadata.create(result.user.userMode),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<BindingResponse>> bindLine(BindLineRequest request) async {
    try {
      final result = await _bindingService.bindLineAccount(
        request.lineUserId,
        request.lineAccessToken,
      );
      return ApiResponse.success(
        data: result,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }

  Future<ApiResponse<BindingStatusResponse>> getBindStatus() async {
    try {
      final result = await _bindingService.getBindingStatus();
      return ApiResponse.success(
        data: result,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } on LCASException catch (e) {
      return ApiResponse.error(e);
    } catch (e) {
      return ApiResponse.error(
        LCASException.internal('INTERNAL_SERVER_ERROR', e.toString()),
      );
    }
  }
}
```

### 3.2 統一回應格式 (Dart) - 遵循 8088 規範
```dart
class ApiResponse<T> {
  final bool success;
  final T? data;
  final ApiMetadata metadata;

  ApiResponse({
    required this.success,
    this.data,
    required this.metadata,
  });

  factory ApiResponse.success({
    required T data,
    required ApiMetadata metadata,
  }) {
    return ApiResponse(
      success: true,
      data: data,
      metadata: metadata,
    );
  }

  factory ApiResponse.error(LCASException exception) {
    return ApiResponse(
      success: false,
      data: null,
      metadata: ApiMetadata.createWithError(exception),
    );
  }

  Map<String, dynamic> toJson() {
    if (success) {
      return {
        'success': success,
        'data': data,
        'metadata': metadata.toJson(),
      };
    } else {
      return {
        'success': success,
        'error': metadata.error?.toJson(),
      };
    }
  }
}

class ApiMetadata {
  final DateTime timestamp;
  final String requestId;
  final UserMode? userMode;
  final ApiError? error;

  ApiMetadata({
    required this.timestamp,
    required this.requestId,
    this.userMode,
    this.error,
  });

  factory ApiMetadata.create(UserMode? userMode) {
    return ApiMetadata(
      timestamp: DateTime.now(),
      requestId: Uuid().v4(),
      userMode: userMode,
    );
  }

  factory ApiMetadata.createWithError(LCASException exception) {
    return ApiMetadata(
      timestamp: DateTime.now(),
      requestId: Uuid().v4(),
      error: ApiError.fromException(exception),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'requestId': requestId,
      if (userMode != null) 'userMode': userMode.toString().split('.').last,
      if (error != null) 'error': error!.toJson(),
    };
  }
}
```

### 3.3 統一錯誤處理 (Dart) - 遵循 8088 規範
```dart
abstract class LCASException implements Exception {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final Map<String, dynamic>? details;

  LCASException({
    required this.code,
    required this.message,
    this.field,
    Map<String, dynamic>? details,
  }) : timestamp = DateTime.now(),
       details = details;

  factory LCASException.validation(String message, {String? field, List<ValidationError>? validationErrors}) {
    return ValidationException(
      code: 'VALIDATION_ERROR',
      message: message,
      field: field,
      validationErrors: validationErrors ?? [],
    );
  }

  factory LCASException.unauthorized(String message) {
    return AuthException(code: 'UNAUTHORIZED', message: message);
  }

  factory LCASException.forbidden(String message) {
    return AuthException(code: 'INSUFFICIENT_PERMISSIONS', message: message);
  }

  factory LCASException.notFound(String message) {
    return BusinessLogicException(code: 'RESOURCE_NOT_FOUND', message: message);
  }

  factory LCASException.conflict(String message) {
    return BusinessLogicException(code: 'DUPLICATE_RESOURCE', message: message);
  }

  factory LCASException.businessLogic(String code, String message) {
    return BusinessLogicException(code: code, message: message);
  }

  factory LCASException.internal(String code, String message) {
    return InternalServerException(code: code, message: message);
  }

  @override
  String toString() => 'LCASException: [$code] $message';

  Map<String, dynamic> toJson() {
    return {
      'code': code,
      'message': message,
      if (field != null) 'field': field,
      'timestamp': timestamp.toIso8601String(),
      if (details != null) 'details': details,
    };
  }
}

class ValidationException extends LCASException {
  final List<ValidationError> validationErrors;

  ValidationException({
    required String code,
    required String message,
    String? field,
    required this.validationErrors,
  }) : super(
          code: code,
          message: message,
          field: field,
          details: {
            'validation': validationErrors.map((e) => e.toJson()).toList(),
          },
        );
}

class AuthException extends LCASException {
  AuthException({required String code, required String message, String? field})
      : super(code: code, message: message, field: field);
}

class BusinessLogicException extends LCASException {
  BusinessLogicException({required String code, required String message, String? field})
      : super(code: code, message: message, field: field);
}

class InternalServerException extends LCASException {
  InternalServerException({required String code, required String message})
      : super(code: code, message: message);
}

class ValidationError {
  final String field;
  final String message;
  final String? code;
  final dynamic value;

  ValidationError({
    required this.field,
    required this.message,
    this.code,
    this.value,
  });

  Map<String, dynamic> toJson() {
    return {
      'field': field,
      'message': message,
      if (code != null) 'code': code,
      if (value != null) 'value': value,
    };
  }
}

class ApiError {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final String requestId;
  final Map<String, dynamic>? details;

  ApiError({
    required this.code,
    required this.message,
    this.field,
    required this.timestamp,
    required this.requestId,
    this.details,
  });

  factory ApiError.fromException(LCASException exception) {
    return ApiError(
      code: exception.code,
      message: exception.message,
      field: exception.field,
      timestamp: exception.timestamp,
      requestId: Uuid().v4(),
      details: exception.details,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'code': code,
      'message': message,
      if (field != null) 'field': field,
      'timestamp': timestamp.toIso8601String(),
      'requestId': requestId,
      if (details != null) 'details': details,
    };
  }
}
```

### 3.4 四模式適配器 (Dart) - 深化實作
```dart
class UserModeAdapter {
  static LoginResponse adaptLoginResponse(
    LoginResponse baseResponse,
    UserMode userMode,
  ) {
    switch (userMode) {
      case UserMode.expert:
        return baseResponse.copyWith(
          loginHistory: LoginHistory(
            lastLogin: DateTime.now().subtract(Duration(days: 1)),
            loginCount: 156,
            newDeviceDetected: false,
            recentLogins: [
              // 最近登入記錄
            ],
          ),
          securityInfo: SecurityInfo(
            lastPasswordChange: DateTime.now().subtract(Duration(days: 30)),
            activeDevices: 3,
            securityScore: 85,
          ),
          advancedOptions: AdvancedOptions(
            biometricEnabled: true,
            twoFactorEnabled: false,
            sessionTimeout: Duration(hours: 8),
          ),
        );

      case UserMode.inertial:
        return baseResponse.copyWith(
          // 移除進階功能，保持標準回應
          loginHistory: null,
          securityInfo: null,
          advancedOptions: null,
        );

      case UserMode.cultivation:
        return baseResponse.copyWith(
          streakInfo: StreakInfo(
            currentStreak: 7,
            longestStreak: 14,
            streakMessage: "連續登入 7 天！繼續保持！",
            nextReward: "連續 10 天登入獎勵",
          ),
          achievements: [
            Achievement(
              id: "login_streak_7",
              title: "登入達人",
              description: "連續登入 7 天",
              unlockedAt: DateTime.now(),
            ),
          ],
          motivationalContent: MotivationalContent(
            message: "今天又是記帳的好日子！",
            tip: "定期記帳能幫助您更好地管理財務",
          ),
        );

      case UserMode.guiding:
        return LoginResponse(
          token: baseResponse.token,
          refreshToken: baseResponse.refreshToken,
          expiresAt: baseResponse.expiresAt,
          user: baseResponse.user,
          simpleMessage: "登入成功",
          // 移除所有複雜資訊
        );
    }
  }

  static RegisterResponse adaptRegisterResponse(
    RegisterResponse baseResponse,
    UserMode userMode,
  ) {
    switch (userMode) {
      case UserMode.expert:
        return baseResponse.copyWith(
          nextSteps: [
            "設定雙重認證",
            "驗證 Email 地址",
            "完成個人資料",
            "匯入現有資料",
          ],
          securityRecommendations: [
            "啟用生物辨識登入",
            "設定強密碼",
            "定期更換密碼",
          ],
        );

      case UserMode.cultivation:
        return baseResponse.copyWith(
          welcomeMessage: "歡迎加入 LCAS！開始您的理財旅程！",
          firstSteps: [
            "驗證 Email 地址",
            "新增第一筆記帳",
            "設定月度預算",
          ],
          motivationalContent: MotivationalContent(
            message: "每一步都是進步！",
            tip: "從今天開始記帳，養成良好的理財習慣",
          ),
        );

      case UserMode.guiding:
        return RegisterResponse(
          userId: baseResponse.userId,
          email: baseResponse.email,
          userMode: baseResponse.userMode,
          verificationSent: baseResponse.verificationSent,
          needsAssessment: false, // 簡化流程
          token: baseResponse.token,
          refreshToken: baseResponse.refreshToken,
          expiresAt: baseResponse.expiresAt,
          simpleMessage: "註冊成功，請檢查 Email 驗證信",
        );

      default:
        return baseResponse;
    }
  }
}
```

---

## 4. API 清單

### 4.1 認證服務 API 端點總覽

本節列出認證服務的所有 API 端點，嚴格遵循 8020. API list.md 和 8088. API設計規範.md 的規範。

| 端點 | HTTP 方法 | 描述 | 對應畫面 | 優先級 |
|------|----------|------|----------|--------|
| `/auth/register` | POST | 使用者註冊 | S-103 | P1 |
| `/auth/login` | POST | 使用者登入 | S-104 | P1 |
| `/auth/google-login` | POST | Google OAuth 登入 | S-104 | P1 |
| `/auth/logout` | POST | 使用者登出 | - | P1 |
| `/auth/refresh` | POST | 刷新 Token | - | P1 |
| `/auth/forgot-password` | POST | 忘記密碼 | S-105 | P1 |
| `/auth/verify-reset-token` | GET | 驗證重設連結 | S-105 | P1 |
| `/auth/reset-password` | POST | 重設密碼 | S-105 | P1 |
| `/auth/verify-email` | POST | 驗證 Email 地址 | S-103 | P1 |
| `/auth/bind-line` | POST | LINE 綁定 | S-107 | P1 |
| `/auth/bind-status` | GET | 綁定狀態查詢 | S-107 | P1 |

### 4.2 API 設計規範遵循

#### 4.2.1 URL 設計規範（遵循 8088 文件）
```
https://api.lcas.app/v1/auth/{action}
```

所有端點均遵循以下設計原則：
- 使用 RESTful 架構
- 統一 `/auth` 前綴
- 動詞形式的操作（如 `login`, `logout`）
- 符合語義化命名

#### 4.2.2 HTTP 方法使用（遵循 8088 文件）
- **POST**：用於狀態變更操作（註冊、登入、登出等）
- **GET**：用於查詢操作（綁定狀態查詢、Token 驗證）

#### 4.2.3 四模式支援（遵循 8020 文件）
所有 API 端點均支援四種使用者模式的差異化回應：
- **Expert**：完整詳細資訊
- **Inertial**：標準資訊
- **Cultivation**：引導式資訊
- **Guiding**：極簡資訊

通過 `X-User-Mode` 標頭識別模式：
```http
X-User-Mode: Expert|Inertial|Cultivation|Guiding
```

---

## 5. API 詳細實作設計

### 5.1 Endpoint: `/auth/register` (Dart Client)

#### 實作邏輯流程
1. **輸入驗證**：檢查 email 格式、密碼強度、必填欄位
2. **重複檢查**：驗證 email 是否已被註冊
3. **密碼加密**：使用 bcrypt 加密密碼
4. **建立使用者**：在 Firestore 中建立使用者記錄
5. **發送驗證信**：異步發送 email 驗證信
6. **生成 Token**：建立 JWT access 和 refresh token
7. **四模式適配**：根據使用者模式調整回應內容

#### Dart 客戶端實作
```dart
Future<ApiResponse<RegisterResponse>> register(RegisterRequest request) async {
  try {
    // 客戶端驗證
    final validationErrors = _validateRegisterRequest(request);
    if (validationErrors.isNotEmpty) {
      throw LCASException.validation(
        '註冊資料驗證失敗',
        validationErrors: validationErrors,
      );
    }

    final response = await _dio.post(
      '/auth/register',
      data: request.toJson(),
      options: Options(
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'X-User-Mode': request.userMode.toString().split('.').last,
          'X-Request-ID': Uuid().v4(),
        },
      ),
    );

    if (response.statusCode == 201) {
      final responseData = RegisterResponse.fromJson(response.data['data']);
      
      // 四模式適配
      final adaptedResponse = UserModeAdapter.adaptRegisterResponse(
        responseData,
        request.userMode,
      );
      
      return ApiResponse.success(
        data: adaptedResponse,
        metadata: ApiMetadata.create(request.userMode),
      );
    } else {
      throw LCASException.internal('REGISTRATION_FAILED', '註冊失敗');
    }
  } on DioException catch (e) {
    return _handleDioError(e);
  } catch (e) {
    return ApiResponse.error(
      LCASException.internal('UNEXPECTED_ERROR', '未預期的錯誤: $e'),
    );
  }
}

List<ValidationError> _validateRegisterRequest(RegisterRequest request) {
  final errors = <ValidationError>[];

  // Email 格式驗證
  if (!_isValidEmail(request.email)) {
    errors.add(ValidationError(
      field: 'email',
      message: 'Email 格式不正確',
      code: 'INVALID_FORMAT',
      value: request.email,
    ));
  }

  // 密碼強度驗證
  if (request.password.length < 8) {
    errors.add(ValidationError(
      field: 'password',
      message: '密碼長度至少需要 8 個字元',
      code: 'PASSWORD_TOO_SHORT',
      value: request.password.length,
    ));
  }

  // 必填欄位驗證
  if (!request.acceptTerms) {
    errors.add(ValidationError(
      field: 'acceptTerms',
      message: '必須同意服務條款',
      code: 'REQUIRED_FIELD',
      value: request.acceptTerms,
    ));
  }

  return errors;
}
```

### 5.2 Endpoint: `/auth/login` (Dart Client)

#### 實作邏輯流程
1. **認證驗證**：檢查 email 和密碼
2. **帳號狀態檢查**：確認帳號未被鎖定或停用
3. **密碼驗證**：使用 bcrypt 驗證密碼
4. **生成 Token**：建立新的 JWT token 對
5. **登入記錄**：更新最後登入時間和裝置資訊
6. **四模式差異化**：根據使用者模式提供不同深度的資訊

#### Dart 客戶端實作
```dart
Future<ApiResponse<LoginResponse>> login(LoginRequest request) async {
  try {
    final response = await _dio.post(
      '/auth/login',
      data: request.toJson(),
      options: Options(
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'X-Request-ID': Uuid().v4(),
        },
      ),
    );

    if (response.statusCode == 200) {
      final responseData = LoginResponse.fromJson(response.data['data']);
      
      // 根據使用者模式適配回應
      final adaptedData = UserModeAdapter.adaptLoginResponse(
        responseData,
        responseData.user.userMode,
      );
      
      return ApiResponse.success(
        data: adaptedData,
        metadata: ApiMetadata.create(responseData.user.userMode),
      );
    } else {
      throw LCASException.unauthorized('登入失敗');
    }
  } on DioException catch (e) {
    return _handleDioError(e);
  } catch (e) {
    return ApiResponse.error(
      LCASException.internal('LOGIN_ERROR', '登入過程發生錯誤: $e'),
    );
  }
}
```

### 5.3 Endpoint: `/auth/verify-reset-token` (Dart Client)

#### 實作邏輯流程
1. **Token 格式檢查**：驗證 token 格式
2. **Token 有效性驗證**：檢查 token 是否存在且未過期
3. **使用狀態檢查**：確認 token 未被使用過
4. **回傳驗證結果**：提供 token 相關資訊

#### Dart 客戶端實作
```dart
Future<ApiResponse<VerifyResetTokenResponse>> verifyResetToken(String token) async {
  try {
    final response = await _dio.get(
      '/auth/verify-reset-token',
      queryParameters: {'token': token},
      options: Options(
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'X-Request-ID': Uuid().v4(),
        },
      ),
    );

    if (response.statusCode == 200) {
      final responseData = VerifyResetTokenResponse.fromJson(response.data['data']);
      return ApiResponse.success(
        data: responseData,
        metadata: ApiMetadata.create(UserMode.inertial),
      );
    } else {
      throw LCASException.businessLogic('INVALID_RESET_TOKEN', 'Token 無效或已過期');
    }
  } on DioException catch (e) {
    return _handleDioError(e);
  } catch (e) {
    return ApiResponse.error(
      LCASException.internal('VERIFY_TOKEN_ERROR', '驗證過程發生錯誤: $e'),
    );
  }
}
```

### 5.4 統一錯誤處理實作 (Dart)

```dart
ApiResponse<T> _handleDioError<T>(DioException e) {
  switch (e.type) {
    case DioExceptionType.connectionTimeout:
    case DioExceptionType.sendTimeout:
    case DioExceptionType.receiveTimeout:
      return ApiResponse.error(
        LCASException.internal('TIMEOUT_ERROR', '連線超時，請稍後重試'),
      );
    
    case DioExceptionType.badResponse:
      final statusCode = e.response?.statusCode;
      final errorData = e.response?.data;
      
      if (errorData != null && errorData['error'] != null) {
        final error = errorData['error'];
        return ApiResponse.error(
          LCASException.businessLogic(
            error['code'] ?? 'UNKNOWN_ERROR',
            error['message'] ?? '未知錯誤',
          ),
        );
      }
      
      switch (statusCode) {
        case 400:
          return ApiResponse.error(
            LCASException.validation('請求參數錯誤'),
          );
        case 401:
          return ApiResponse.error(
            LCASException.unauthorized('認證失敗，請重新登入'),
          );
        case 403:
          return ApiResponse.error(
            LCASException.forbidden('權限不足'),
          );
        case 404:
          return ApiResponse.error(
            LCASException.notFound('請求的資源不存在'),
          );
        case 409:
          return ApiResponse.error(
            LCASException.conflict('資源衝突'),
          );
        case 422:
          return ApiResponse.error(
            LCASException.validation('資料驗證失敗'),
          );
        case 500:
          return ApiResponse.error(
            LCASException.internal('SERVER_ERROR', '伺服器內部錯誤'),
          );
        default:
          return ApiResponse.error(
            LCASException.internal('HTTP_ERROR', 'HTTP 錯誤 $statusCode'),
          );
      }
    
    case DioExceptionType.cancel:
      return ApiResponse.error(
        LCASException.internal('CANCELLED', '請求已取消'),
      );
    
    case DioExceptionType.unknown:
      return ApiResponse.error(
        LCASException.internal('NETWORK_ERROR', '網路連線錯誤'),
      );
    
    default:
      return ApiResponse.error(
        LCASException.internal('UNKNOWN_ERROR', '未知錯誤'),
      );
  }
}
```

---

## 6. 資料庫設計

### 6.1 Firestore Collection 結構

#### Users Collection
```dart
class UserData {
  final String id;
  final String email;
  final String password;
  final String? displayName;
  final String? avatar;
  final UserMode userMode;
  final bool emailVerified;
  final AccountStatus status;
  final AuthProvider authProvider;
  final String? googleId;
  final UserPreferences preferences;
  final SecuritySettings security;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastActiveAt;

  UserData({
    required this.id,
    required this.email,
    required this.password,
    this.displayName,
    this.avatar,
    required this.userMode,
    required this.emailVerified,
    required this.status,
    required this.authProvider,
    this.googleId,
    required this.preferences,
    required this.security,
    required this.createdAt,
    required this.updatedAt,
    this.lastActiveAt,
  });

  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'email': email,
      'password': password,
      'displayName': displayName,
      'avatar': avatar,
      'userMode': userMode.toString().split('.').last,
      'emailVerified': emailVerified,
      'status': status.toString().split('.').last,
      'authProvider': authProvider.toString().split('.').last,
      'googleId': googleId,
      'preferences': preferences.toMap(),
      'security': security.toMap(),
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'lastActiveAt': lastActiveAt != null ? Timestamp.fromDate(lastActiveAt!) : null,
    };
  }

  factory UserData.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserData(
      id: data['id'],
      email: data['email'],
      password: data['password'],
      displayName: data['displayName'],
      avatar: data['avatar'],
      userMode: UserMode.values.firstWhere(
        (mode) => mode.toString().split('.').last == data['userMode'],
      ),
      emailVerified: data['emailVerified'],
      status: AccountStatus.values.firstWhere(
        (status) => status.toString().split('.').last == data['status'],
      ),
      authProvider: AuthProvider.values.firstWhere(
        (provider) => provider.toString().split('.').last == data['authProvider'],
      ),
      googleId: data['googleId'],
      preferences: UserPreferences.fromMap(data['preferences']),
      security: SecuritySettings.fromMap(data['security']),
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      lastActiveAt: data['lastActiveAt'] != null 
          ? (data['lastActiveAt'] as Timestamp).toDate()
          : null,
    );
  }
}
```

#### PasswordResetTokens Collection
```dart
class PasswordResetToken {
  final String id;
  final String email;
  final String token;
  final DateTime createdAt;
  final DateTime expiresAt;
  final bool used;
  final DateTime? usedAt;

  PasswordResetToken({
    required this.id,
    required this.email,
    required this.token,
    required this.createdAt,
    required this.expiresAt,
    this.used = false,
    this.usedAt,
  });

  bool get isExpired => DateTime.now().isAfter(expiresAt);
  bool get isValid => !used && !isExpired;

  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'email': email,
      'token': token,
      'createdAt': Timestamp.fromDate(createdAt),
      'expiresAt': Timestamp.fromDate(expiresAt),
      'used': used,
      'usedAt': usedAt != null ? Timestamp.fromDate(usedAt!) : null,
    };
  }

  factory PasswordResetToken.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return PasswordResetToken(
      id: data['id'],
      email: data['email'],
      token: data['token'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      expiresAt: (data['expiresAt'] as Timestamp).toDate(),
      used: data['used'] ?? false,
      usedAt: data['usedAt'] != null 
          ? (data['usedAt'] as Timestamp).toDate()
          : null,
    );
  }
}
```

#### EmailVerifications Collection
```dart
class EmailVerification {
  final String id;
  final String email;
  final String verificationCode;
  final DateTime createdAt;
  final DateTime expiresAt;
  final bool verified;
  final DateTime? verifiedAt;
  final int attempts;

  EmailVerification({
    required this.id,
    required this.email,
    required this.verificationCode,
    required this.createdAt,
    required this.expiresAt,
    this.verified = false,
    this.verifiedAt,
    this.attempts = 0,
  });

  bool get isExpired => DateTime.now().isAfter(expiresAt);
  bool get isValid => !verified && !isExpired && attempts < 5;

  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'email': email,
      'verificationCode': verificationCode,
      'createdAt': Timestamp.fromDate(createdAt),
      'expiresAt': Timestamp.fromDate(expiresAt),
      'verified': verified,
      'verifiedAt': verifiedAt != null ? Timestamp.fromDate(verifiedAt!) : null,
      'attempts': attempts,
    };
  }
}
```

---

## 7. 安全與驗證

### 7.1 JWT Token 處理 (Dart)
```dart
class JWTHandler {
  static Map<String, dynamic>? decodeToken(String token) {
    try {
      final parts = token.split('.');
      if (parts.length != 3) {
        return null;
      }

      final payload = parts[1];
      final normalizedPayload = base64Url.normalize(payload);
      final decodedBytes = base64Url.decode(normalizedPayload);
      final decodedString = utf8.decode(decodedBytes);
      
      return json.decode(decodedString) as Map<String, dynamic>;
    } catch (e) {
      return null;
    }
  }

  static bool isTokenExpired(String token) {
    final payload = decodeToken(token);
    if (payload == null) return true;

    final exp = payload['exp'] as int?;
    if (exp == null) return true;

    final expirationDate = DateTime.fromMillisecondsSinceEpoch(exp * 1000);
    return DateTime.now().isAfter(expirationDate);
  }

  static String? getUserIdFromToken(String token) {
    final payload = decodeToken(token);
    return payload?['userId'] as String?;
  }

  static UserMode? getUserModeFromToken(String token) {
    final payload = decodeToken(token);
    final modeString = payload?['userMode'] as String?;
    
    if (modeString == null) return null;
    
    return UserMode.values.firstWhere(
      (mode) => mode.toString().split('.').last == modeString,
      orElse: () => UserMode.inertial,
    );
  }
}
```

### 7.2 密碼加密服務 (Dart)
```dart
class PasswordHashService {
  static const int _saltRounds = 12;

  Future<String> hashPassword(String password) async {
    try {
      final salt = BCrypt.gensalt(logRounds: _saltRounds);
      return BCrypt.hashpw(password, salt);
    } catch (e) {
      throw LCASException.internal('HASH_ERROR', '密碼加密失敗: $e');
    }
  }

  Future<bool> verifyPassword(String password, String hashedPassword) async {
    try {
      return BCrypt.checkpw(password, hashedPassword);
    } catch (e) {
      throw LCASException.internal('VERIFY_ERROR', '密碼驗證失敗: $e');
    }
  }

  bool validatePasswordStrength(String password) {
    // 至少 8 個字元
    if (password.length < 8) return false;
    
    // 包含大寫字母
    if (!RegExp(r'[A-Z]').hasMatch(password)) return false;
    
    // 包含小寫字母
    if (!RegExp(r'[a-z]').hasMatch(password)) return false;
    
    // 包含數字
    if (!RegExp(r'[0-9]').hasMatch(password)) return false;
    
    return true;
  }

  List<ValidationError> getPasswordStrengthErrors(String password) {
    final errors = <ValidationError>[];
    
    if (password.length < 8) {
      errors.add(ValidationError(
        field: 'password',
        message: '密碼長度至少需要 8 個字元',
        code: 'PASSWORD_TOO_SHORT',
        value: password.length,
      ));
    }
    
    if (!RegExp(r'[A-Z]').hasMatch(password)) {
      errors.add(ValidationError(
        field: 'password',
        message: '密碼需包含至少一個大寫字母',
        code: 'MISSING_UPPERCASE',
      ));
    }
    
    if (!RegExp(r'[a-z]').hasMatch(password)) {
      errors.add(ValidationError(
        field: 'password',
        message: '密碼需包含至少一個小寫字母',
        code: 'MISSING_LOWERCASE',
      ));
    }
    
    if (!RegExp(r'[0-9]').hasMatch(password)) {
      errors.add(ValidationError(
        field: 'password',
        message: '密碼需包含至少一個數字',
        code: 'MISSING_NUMBER',
      ));
    }
    
    return errors;
  }
}
```

---

## 8. 錯誤處理

### 8.1 HTTP 狀態碼對應 (遵循 8088 規範)

| 狀態碼 | 說明 | 使用場景 | 錯誤碼範例 |
|--------|------|----------|------------|
| 200 | 成功 | 正常請求回應 | - |
| 201 | 建立成功 | 註冊成功 | - |
| 400 | 請求錯誤 | 參數驗證失敗 | `VALIDATION_ERROR` |
| 401 | 未授權 | 認證失敗 | `UNAUTHORIZED` |
| 403 | 禁止存取 | 權限不足 | `INSUFFICIENT_PERMISSIONS` |
| 404 | 資源不存在 | 使用者不存在 | `RESOURCE_NOT_FOUND` |
| 409 | 資源衝突 | Email 已註冊 | `DUPLICATE_RESOURCE` |
| 422 | 無法處理 | 業務邏輯錯誤 | `BUSINESS_LOGIC_ERROR` |
| 500 | 伺服器錯誤 | 系統異常 | `INTERNAL_SERVER_ERROR` |

### 8.2 錯誤碼規範 (遵循 8088 規範)

#### 認證相關錯誤碼
```dart
class AuthErrorCodes {
  // 驗證錯誤
  static const String VALIDATION_ERROR = 'VALIDATION_ERROR';
  static const String INVALID_EMAIL = 'INVALID_EMAIL';
  static const String WEAK_PASSWORD = 'WEAK_PASSWORD';
  static const String PASSWORD_MISMATCH = 'PASSWORD_MISMATCH';
  
  // 認證錯誤
  static const String UNAUTHORIZED = 'UNAUTHORIZED';
  static const String INVALID_CREDENTIALS = 'INVALID_CREDENTIALS';
  static const String ACCOUNT_LOCKED = 'ACCOUNT_LOCKED';
  static const String ACCOUNT_SUSPENDED = 'ACCOUNT_SUSPENDED';
  
  // 資源錯誤
  static const String EMAIL_ALREADY_EXISTS = 'EMAIL_ALREADY_EXISTS';
  static const String USER_NOT_FOUND = 'USER_NOT_FOUND';
  static const String INVALID_RESET_TOKEN = 'INVALID_RESET_TOKEN';
  static const String INVALID_VERIFICATION_CODE = 'INVALID_VERIFICATION_CODE';
  
  // Token 錯誤
  static const String INVALID_TOKEN = 'INVALID_TOKEN';
  static const String EXPIRED_TOKEN = 'EXPIRED_TOKEN';
  static const String INVALID_REFRESH_TOKEN = 'INVALID_REFRESH_TOKEN';
  
  // 第三方認證錯誤
  static const String GOOGLE_AUTH_FAILED = 'GOOGLE_AUTH_FAILED';
  static const String LINE_BINDING_FAILED = 'LINE_BINDING_FAILED';
  static const String LINE_ALREADY_BOUND = 'LINE_ALREADY_BOUND';
  
  // 系統錯誤
  static const String INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR';
  static const String SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE';
  static const String TIMEOUT_ERROR = 'TIMEOUT_ERROR';
}
```

### 8.3 統一錯誤處理中介層 (Dart)
```dart
class ErrorHandlerMiddleware {
  static ApiResponse<T> handleError<T>(Exception exception) {
    if (exception is LCASException) {
      return ApiResponse.error(exception);
    }
    
    if (exception is DioException) {
      return _handleDioException<T>(exception);
    }
    
    // 未預期的錯誤
    return ApiResponse.error(
      LCASException.internal(
        'UNEXPECTED_ERROR',
        '系統發生未預期的錯誤: ${exception.toString()}',
      ),
    );
  }
  
  static ApiResponse<T> _handleDioException<T>(DioException e) {
    // 詳細的 DioException 處理邏輯
    // (如前面實作所示)
    return _handleDioError<T>(e);
  }
  
  static void logError(LCASException exception, {StackTrace? stackTrace}) {
    final logData = {
      'error': exception.toJson(),
      'stackTrace': stackTrace?.toString(),
    };
    
    switch (exception.code) {
      case AuthErrorCodes.INTERNAL_SERVER_ERROR:
      case AuthErrorCodes.SERVICE_UNAVAILABLE:
        Logger.error('Critical error occurred', logData);
        break;
      case AuthErrorCodes.UNAUTHORIZED:
      case AuthErrorCodes.INVALID_CREDENTIALS:
        Logger.warning('Authentication failed', logData);
        break;
      default:
        Logger.info('Client error occurred', logData);
        break;
    }
  }
}
```

---

## 9. 日誌與監控

### 9.1 認證事件日誌 (Dart)
```dart
class AuthLogger {
  static final Logger _logger = Logger('AuthService');

  static void logAuthAttempt({
    required String email,
    required bool success,
    String? reason,
    String? deviceInfo,
    String? ipAddress,
    UserMode? userMode,
  }) {
    final logData = {
      'event': 'AUTH_ATTEMPT',
      'email': _maskEmail(email),
      'success': success,
      'reason': reason,
      'deviceInfo': deviceInfo,
      'ipAddress': ipAddress,
      'userMode': userMode?.toString().split('.').last,
      'timestamp': DateTime.now().toIso8601String(),
    };

    if (success) {
      _logger.info('Authentication successful: ${json.encode(logData)}');
    } else {
      _logger.warning('Authentication failed: ${json.encode(logData)}');
    }
  }

  static void logRegistration({
    required String email,
    required UserMode userMode,
    required bool success,
    String? reason,
  }) {
    final logData = {
      'event': 'USER_REGISTRATION',
      'email': _maskEmail(email),
      'userMode': userMode.toString().split('.').last,
      'success': success,
      'reason': reason,
      'timestamp': DateTime.now().toIso8601String(),
    };

    if (success) {
      _logger.info('User registration successful: ${json.encode(logData)}');
    } else {
      _logger.warning('User registration failed: ${json.encode(logData)}');
    }
  }

  static void logPasswordReset({
    required String email,
    required String action, // 'request', 'verify', 'reset'
    required bool success,
    String? reason,
  }) {
    final logData = {
      'event': 'PASSWORD_RESET',
      'email': _maskEmail(email),
      'action': action,
      'success': success,
      'reason': reason,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.info('Password reset action: ${json.encode(logData)}');
  }

  static void logTokenEvent({
    required String tokenId,
    required String userId,
    required String action, // 'generate', 'refresh', 'revoke'
    String? endpoint,
  }) {
    final logData = {
      'event': 'TOKEN_EVENT',
      'tokenId': tokenId,
      'userId': userId,
      'action': action,
      'endpoint': endpoint,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.info('Token event: ${json.encode(logData)}');
  }

  static void logSecurityEvent({
    required String eventType,
    required String userId,
    required String description,
    Map<String, dynamic>? details,
  }) {
    final logData = {
      'event': 'SECURITY_EVENT',
      'eventType': eventType,
      'userId': userId,
      'description': description,
      'details': details,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.warning('Security event: ${json.encode(logData)}');
  }

  static void logOAuthEvent({
    required String provider,
    required String action,
    required bool success,
    String? userId,
    String? reason,
  }) {
    final logData = {
      'event': 'OAUTH_EVENT',
      'provider': provider,
      'action': action,
      'success': success,
      'userId': userId,
      'reason': reason,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.info('OAuth event: ${json.encode(logData)}');
  }

  static void logBindingEvent({
    required String platform,
    required String action,
    required bool success,
    String? userId,
    String? reason,
  }) {
    final logData = {
      'event': 'ACCOUNT_BINDING',
      'platform': platform,
      'action': action,
      'success': success,
      'userId': userId,
      'reason': reason,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.info('Account binding event: ${json.encode(logData)}');
  }

  static String _maskEmail(String email) {
    final parts = email.split('@');
    if (parts.length != 2) return '***';
    
    final local = parts[0];
    final domain = parts[1];
    
    if (local.length <= 2) {
      return '***@$domain';
    }
    
    return '${local.substring(0, 2)}***@$domain';
  }
}
```

### 9.2 效能監控 (Dart)
```dart
class AuthPerformanceMonitor {
  static final Map<String, Stopwatch> _timers = {};
  static final Map<String, List<int>> _operationTimes = {};

  static void startTimer(String operation) {
    _timers[operation] = Stopwatch()..start();
  }

  static void endTimer(String operation, {Map<String, dynamic>? metadata}) {
    final timer = _timers.remove(operation);
    if (timer == null) return;

    timer.stop();
    final duration = timer.elapsedMilliseconds;

    // 記錄操作時間
    _operationTimes.putIfAbsent(operation, () => []).add(duration);

    final logData = {
      'operation': operation,
      'duration': duration,
      'metadata': metadata,
      'timestamp': DateTime.now().toIso8601String(),
    };

    AuthLogger._logger.info('Performance: $operation took ${duration}ms');

    // 如果操作時間過長，記錄警告
    if (duration > 5000) {
      AuthLogger.logSecurityEvent(
        eventType: 'SLOW_OPERATION',
        userId: metadata?['userId'] ?? 'unknown',
        description: 'Slow operation detected: $operation took ${duration}ms',
        details: logData,
      );
    }
  }

  static T measureOperation<T>(String operation, T Function() function) {
    startTimer(operation);
    try {
      return function();
    } finally {
      endTimer(operation);
    }
  }

  static Future<T> measureAsyncOperation<T>(
    String operation,
    Future<T> Function() function,
  ) async {
    startTimer(operation);
    try {
      return await function();
    } finally {
      endTimer(operation);
    }
  }

  static Map<String, dynamic> getPerformanceStats() {
    final stats = <String, dynamic>{};
    
    for (final entry in _operationTimes.entries) {
      final times = entry.value;
      if (times.isEmpty) continue;
      
      times.sort();
      stats[entry.key] = {
        'count': times.length,
        'average': times.reduce((a, b) => a + b) / times.length,
        'median': times[times.length ~/ 2],
        'min': times.first,
        'max': times.last,
        'p95': times[(times.length * 0.95).floor()],
      };
    }
    
    return stats;
  }
}
```

---

## 10. 測試設計

### 10.1 單元測試 (Dart)
```dart
import 'package:test/test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

@GenerateMocks([
  UserRepository,
  TokenService,
  EmailService,
  PasswordHashService,
])
import 'auth_service_test.mocks.dart';

void main() {
  group('AuthService Tests', () {
    late AuthService authService;
    late MockUserRepository mockUserRepository;
    late MockTokenService mockTokenService;
    late MockEmailService mockEmailService;
    late MockPasswordHashService mockPasswordHashService;

    setUp(() {
      mockUserRepository = MockUserRepository();
      mockTokenService = MockTokenService();
      mockEmailService = MockEmailService();
      mockPasswordHashService = MockPasswordHashService();

      authService = AuthService(
        userRepository: mockUserRepository,
        tokenService: mockTokenService,
        emailService: mockEmailService,
        passwordHashService: mockPasswordHashService,
      );
    });

    group('registerUser', () {
      test('should successfully register a new user', () async {
        // Arrange
        final request = RegisterRequest(
          email: 'test@example.com',
          password: 'SecurePassword123',
          userMode: UserMode.expert,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => null);
        
        when(mockPasswordHashService.hashPassword(any))
            .thenAnswer((_) async => 'hashed_password');
        
        when(mockUserRepository.create(any))
            .thenAnswer((_) async => UserData(
              id: 'user-123',
              email: request.email,
              password: 'hashed_password',
              userMode: request.userMode,
              emailVerified: false,
              status: AccountStatus.active,
              authProvider: AuthProvider.email,
              preferences: UserPreferences.defaultSettings(),
              security: SecuritySettings.defaultSettings(),
              createdAt: DateTime.now(),
              updatedAt: DateTime.now(),
            ));

        when(mockEmailService.sendVerificationEmail(any, any))
            .thenAnswer((_) async => {});

        when(mockTokenService.generateTokenPair(any))
            .thenAnswer((_) async => TokenPair(
              accessToken: 'access_token',
              refreshToken: 'refresh_token',
              expiresAt: DateTime.now().add(Duration(hours: 1)),
            ));

        // Act
        final result = await authService.registerUser(request);

        // Assert
        expect(result.userId, equals('user-123'));
        expect(result.email, equals(request.email));
        expect(result.userMode, equals(request.userMode));
        expect(result.verificationSent, isTrue);
        
        verify(mockUserRepository.findByEmail(request.email)).called(1);
        verify(mockPasswordHashService.hashPassword(request.password)).called(1);
        verify(mockUserRepository.create(any)).called(1);
        verify(mockEmailService.sendVerificationEmail(request.email, any)).called(1);
        verify(mockTokenService.generateTokenPair(any)).called(1);
      });

      test('should throw EMAIL_ALREADY_EXISTS when email exists', () async {
        // Arrange
        final request = RegisterRequest(
          email: 'existing@example.com',
          password: 'SecurePassword123',
          userMode: UserMode.expert,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        final existingUser = UserData(
          id: 'existing-user',
          email: request.email,
          password: 'existing_password',
          userMode: UserMode.inertial,
          emailVerified: true,
          status: AccountStatus.active,
          authProvider: AuthProvider.email,
          preferences: UserPreferences.defaultSettings(),
          security: SecuritySettings.defaultSettings(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => existingUser);

        // Act & Assert
        expect(
          () => authService.registerUser(request),
          throwsA(isA<LCASException>()
              .having((e) => e.code, 'code', 'EMAIL_ALREADY_EXISTS')),
        );
      });

      test('should validate password strength', () async {
        // Arrange
        final request = RegisterRequest(
          email: 'test@example.com',
          password: '123', // 弱密碼
          userMode: UserMode.expert,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => null);

        // Act & Assert
        expect(
          () => authService.registerUser(request),
          throwsA(isA<ValidationException>()
              .having((e) => e.code, 'code', 'VALIDATION_ERROR')),
        );
      });
    });

    group('authenticateUser', () {
      test('should successfully authenticate valid credentials', () async {
        // Arrange
        const email = 'test@example.com';
        const password = 'correctPassword';
        const hashedPassword = 'hashed_correct_password';

        final user = UserData(
          id: 'user-123',
          email: email,
          password: hashedPassword,
          userMode: UserMode.expert,
          emailVerified: true,
          status: AccountStatus.active,
          authProvider: AuthProvider.email,
          preferences: UserPreferences.defaultSettings(),
          security: SecuritySettings.defaultSettings(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        when(mockUserRepository.findByEmail(email))
            .thenAnswer((_) async => user);
        
        when(mockPasswordHashService.verifyPassword(password, hashedPassword))
            .thenAnswer((_) async => true);

        when(mockTokenService.generateTokenPair(user))
            .thenAnswer((_) async => TokenPair(
              accessToken: 'access_token',
              refreshToken: 'refresh_token',
              expiresAt: DateTime.now().add(Duration(hours: 1)),
            ));

        when(mockUserRepository.updateLoginHistory(any, any))
            .thenAnswer((_) async => {});

        // Act
        final result = await authService.authenticateUser(email, password);

        // Assert
        expect(result.token, equals('access_token'));
        expect(result.refreshToken, equals('refresh_token'));
        expect(result.user.email, equals(email));
        
        verify(mockUserRepository.findByEmail(email)).called(1);
        verify(mockPasswordHashService.verifyPassword(password, hashedPassword)).called(1);
        verify(mockTokenService.generateTokenPair(user)).called(1);
        verify(mockUserRepository.updateLoginHistory(user.id, any)).called(1);
      });

      test('should throw INVALID_CREDENTIALS for invalid credentials', () async {
        // Arrange
        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => null);

        // Act & Assert
        expect(
          () => authService.authenticateUser('invalid@example.com', 'wrongPassword'),
          throwsA(isA<LCASException>()
              .having((e) => e.code, 'code', 'INVALID_CREDENTIALS')),
        );
      });

      test('should throw ACCOUNT_LOCKED for locked account', () async {
        // Arrange
        final lockedUser = UserData(
          id: 'user-123',
          email: 'locked@example.com',
          password: 'hashed_password',
          userMode: UserMode.expert,
          emailVerified: true,
          status: AccountStatus.locked,
          authProvider: AuthProvider.email,
          preferences: UserPreferences.defaultSettings(),
          security: SecuritySettings.defaultSettings(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => lockedUser);

        // Act & Assert
        expect(
          () => authService.authenticateUser('locked@example.com', 'password'),
          throwsA(isA<LCASException>()
              .having((e) => e.code, 'code', 'ACCOUNT_LOCKED')),
        );
      });
    });

    group('Four Mode Adaptation Tests', () {
      test('should adapt login response for Expert mode', () async {
        // Arrange
        final baseResponse = LoginResponse(
          token: 'token',
          refreshToken: 'refresh_token',
          expiresAt: DateTime.now().add(Duration(hours: 1)),
          user: UserProfile(
            id: 'user-123',
            email: 'expert@example.com',
            userMode: UserMode.expert,
          ),
        );

        // Act
        final adaptedResponse = UserModeAdapter.adaptLoginResponse(
          baseResponse,
          UserMode.expert,
        );

        // Assert
        expect(adaptedResponse.loginHistory, isNotNull);
        expect(adaptedResponse.securityInfo, isNotNull);
        expect(adaptedResponse.advancedOptions, isNotNull);
      });

      test('should adapt login response for Guiding mode', () async {
        // Arrange
        final baseResponse = LoginResponse(
          token: 'token',
          refreshToken: 'refresh_token',
          expiresAt: DateTime.now().add(Duration(hours: 1)),
          user: UserProfile(
            id: 'user-123',
            email: 'guiding@example.com',
            userMode: UserMode.guiding,
          ),
        );

        // Act
        final adaptedResponse = UserModeAdapter.adaptLoginResponse(
          baseResponse,
          UserMode.guiding,
        );

        // Assert
        expect(adaptedResponse.simpleMessage, equals('登入成功'));
        expect(adaptedResponse.loginHistory, isNull);
        expect(adaptedResponse.securityInfo, isNull);
        expect(adaptedResponse.advancedOptions, isNull);
      });
    });
  });
}
```

### 10.2 整合測試 (Dart)
```dart
import 'package:integration_test/integration_test.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Auth API Integration Tests', () {
    late AuthApiClient authApiClient;

    setUpAll(() {
      authApiClient = AuthApiClient(
        baseUrl: 'https://api-staging.lcas.com',
      );
    });

    testWidgets('Complete registration to login flow', (WidgetTester tester) async {
      // Step 1: Register
      final registerRequest = RegisterRequest(
        email: 'integration_test_${DateTime.now().millisecondsSinceEpoch}@example.com',
        password: 'TestPassword123',
        userMode: UserMode.expert,
        acceptTerms: true,
        acceptPrivacy: true,
      );

      final registerResponse = await authApiClient.register(registerRequest);
      
      expect(registerResponse.success, isTrue);
      expect(registerResponse.data?.userId, isNotNull);
      
      final userId = registerResponse.data!.userId;

      // Step 2: Verify Email
      final verifyEmailRequest = VerifyEmailRequest(
        email: registerRequest.email,
        verificationCode: '123456', // 測試環境固定碼
      );

      final verifyResponse = await authApiClient.verifyEmail(verifyEmailRequest);
      expect(verifyResponse.success, isTrue);

      // Step 3: Login
      final loginRequest = LoginRequest(
        email: registerRequest.email,
        password: registerRequest.password,
      );

      final loginResponse = await authApiClient.login(loginRequest);
      
      expect(loginResponse.success, isTrue);
      expect(loginResponse.data?.user.id, equals(userId));
      expect(loginResponse.data?.token, isNotNull);

      // Step 4: Use token to access protected resource
      final token = loginResponse.data!.token;
      authApiClient.setAuthToken(token);
      
      final bindStatusResponse = await authApiClient.getBindStatus();
      expect(bindStatusResponse.success, isTrue);
    });

    testWidgets('Password reset flow', (WidgetTester tester) async {
      final email = 'reset_test_${DateTime.now().millisecondsSinceEpoch}@example.com';
      
      // Step 1: Register user first
      await authApiClient.register(RegisterRequest(
        email: email,
        password: 'OriginalPassword123',
        userMode: UserMode.inertial,
        acceptTerms: true,
        acceptPrivacy: true,
      ));

      // Step 2: Request password reset
      final forgotPasswordRequest = ForgotPasswordRequest(email: email);
      final forgotResponse = await authApiClient.forgotPassword(forgotPasswordRequest);
      expect(forgotResponse.success, isTrue);

      // Step 3: Verify reset token (in testing, use fixed token)
      const resetToken = 'test_reset_token_123';
      final verifyTokenResponse = await authApiClient.verifyResetToken(resetToken);
      expect(verifyTokenResponse.success, isTrue);

      // Step 4: Reset password
      final resetPasswordRequest = ResetPasswordRequest(
        token: resetToken,
        newPassword: 'NewPassword123',
      );
      final resetResponse = await authApiClient.resetPassword(resetPasswordRequest);
      expect(resetResponse.success, isTrue);

      // Step 5: Login with new password
      final loginRequest = LoginRequest(
        email: email,
        password: 'NewPassword123',
      );
      final loginResponse = await authApiClient.login(loginRequest);
      expect(loginResponse.success, isTrue);
    });

    testWidgets('Four modes differentiation test', (WidgetTester tester) async {
      final baseEmail = 'mode_test_${DateTime.now().millisecondsSinceEpoch}';
      
      for (final mode in UserMode.values) {
        // 註冊不同模式的使用者
        final registerRequest = RegisterRequest(
          email: '${baseEmail}_${mode.toString().split('.').last}@example.com',
          password: 'TestPassword123',
          userMode: mode,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        final registerResponse = await authApiClient.register(registerRequest);
        expect(registerResponse.success, isTrue);

        // 登入並檢查回應差異
        final loginRequest = LoginRequest(
          email: registerRequest.email,
          password: registerRequest.password,
        );

        final loginResponse = await authApiClient.login(loginRequest);
        expect(loginResponse.success, isTrue);

        // 根據模式驗證回應內容
        switch (mode) {
          case UserMode.expert:
            expect(loginResponse.data?.loginHistory, isNotNull);
            expect(loginResponse.data?.securityInfo, isNotNull);
            expect(loginResponse.data?.advancedOptions, isNotNull);
            break;
          case UserMode.cultivation:
            expect(loginResponse.data?.streakInfo, isNotNull);
            expect(loginResponse.data?.achievements, isNotNull);
            expect(loginResponse.data?.motivationalContent, isNotNull);
            break;
          case UserMode.guiding:
            expect(loginResponse.data?.simpleMessage, isNotNull);
            expect(loginResponse.data?.loginHistory, isNull);
            expect(loginResponse.data?.streakInfo, isNull);
            break;
          default:
            // Inertial 模式標準回應
            expect(loginResponse.data?.token, isNotNull);
            expect(loginResponse.data?.user, isNotNull);
            break;
        }
      }
    });

    testWidgets('Error handling test', (WidgetTester tester) async {
      // Test validation errors
      final invalidRegisterRequest = RegisterRequest(
        email: 'invalid-email',
        password: '123',
        userMode: UserMode.expert,
        acceptTerms: false,
        acceptPrivacy: false,
      );

      final registerResponse = await authApiClient.register(invalidRegisterRequest);
      expect(registerResponse.success, isFalse);
      expect(registerResponse.metadata.error?.code, equals('VALIDATION_ERROR'));

      // Test unauthorized error
      final invalidLoginRequest = LoginRequest(
        email: 'nonexistent@example.com',
        password: 'wrongpassword',
      );

      final loginResponse = await authApiClient.login(invalidLoginRequest);
      expect(loginResponse.success, isFalse);
      expect(loginResponse.metadata.error?.code, equals('INVALID_CREDENTIALS'));
    });
  });
}
```

---

## 附錄

### A. 資料模型定義 (Dart)
```dart
enum UserMode {
  expert,
  inertial,
  cultivation,
  guiding,
}

enum AccountStatus {
  active,
  inactive,
  locked,
  suspended,
}

enum AuthProvider {
  email,
  google,
  line,
}

class UserPreferences {
  final String language;
  final String timezone;
  final String theme;

  UserPreferences({
    required this.language,
    required this.timezone,
    required this.theme,
  });

  factory UserPreferences.defaultSettings() {
    return UserPreferences(
      language: 'zh-TW',
      timezone: 'Asia/Taipei',
      theme: 'auto',
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'language': language,
      'timezone': timezone,
      'theme': theme,
    };
  }

  factory UserPreferences.fromMap(Map<String, dynamic> map) {
    return UserPreferences(
      language: map['language'] ?? 'zh-TW',
      timezone: map['timezone'] ?? 'Asia/Taipei',
      theme: map['theme'] ?? 'auto',
    );
  }
}

class SecuritySettings {
  final int loginFailures;
  final DateTime? lastFailureAt;
  final DateTime? lockedUntil;
  final DateTime? lastLoginAt;
  final int loginCount;

  SecuritySettings({
    required this.loginFailures,
    this.lastFailureAt,
    this.lockedUntil,
    this.lastLoginAt,
    required this.loginCount,
  });

  factory SecuritySettings.defaultSettings() {
    return SecuritySettings(
      loginFailures: 0,
      loginCount: 0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'loginFailures': loginFailures,
      'lastFailureAt': lastFailureAt?.toIso8601String(),
      'lockedUntil': lockedUntil?.toIso8601String(),
      'lastLoginAt': lastLoginAt?.toIso8601String(),
      'loginCount': loginCount,
    };
  }

  factory SecuritySettings.fromMap(Map<String, dynamic> map) {
    return SecuritySettings(
      loginFailures: map['loginFailures'] ?? 0,
      lastFailureAt: map['lastFailureAt'] != null 
          ? DateTime.parse(map['lastFailureAt'])
          : null,
      lockedUntil: map['lockedUntil'] != null 
          ? DateTime.parse(map['lockedUntil'])
          : null,
      lastLoginAt: map['lastLoginAt'] != null 
          ? DateTime.parse(map['lastLoginAt'])
          : null,
      loginCount: map['loginCount'] ?? 0,
    );
  }
}

// 四模式專用資料模型
class LoginHistory {
  final DateTime lastLogin;
  final int loginCount;
  final bool newDeviceDetected;
  final List<LoginRecord> recentLogins;

  LoginHistory({
    required this.lastLogin,
    required this.loginCount,
    required this.newDeviceDetected,
    required this.recentLogins,
  });
}

class SecurityInfo {
  final DateTime lastPasswordChange;
  final int activeDevices;
  final int securityScore;

  SecurityInfo({
    required this.lastPasswordChange,
    required this.activeDevices,
    required this.securityScore,
  });
}

class AdvancedOptions {
  final bool biometricEnabled;
  final bool twoFactorEnabled;
  final Duration sessionTimeout;

  AdvancedOptions({
    required this.biometricEnabled,
    required this.twoFactorEnabled,
    required this.sessionTimeout,
  });
}

class StreakInfo {
  final int currentStreak;
  final int longestStreak;
  final String streakMessage;
  final String nextReward;

  StreakInfo({
    required this.currentStreak,
    required this.longestStreak,
    required this.streakMessage,
    required this.nextReward,
  });
}

class Achievement {
  final String id;
  final String title;
  final String description;
  final DateTime unlockedAt;

  Achievement({
    required this.id,
    required this.title,
    required this.description,
    required this.unlockedAt,
  });
}

class MotivationalContent {
  final String message;
  final String tip;

  MotivationalContent({
    required this.message,
    required this.tip,
  });
}
```

### B. 配置管理 (Dart)
```dart
class AuthConfig {
  static const String apiBaseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.lcas.com',
  );
  
  static const Duration connectTimeout = Duration(seconds: 30);
  static const Duration receiveTimeout = Duration(seconds: 30);
  static const Duration tokenRefreshThreshold = Duration(minutes: 5);
  
  static const int maxRetryAttempts = 3;
  static const Duration retryDelay = Duration(seconds: 1);
  
  static const bool enableLogging = bool.fromEnvironment(
    'ENABLE_LOGGING',
    defaultValue: true,
  );
  
  static const String logLevel = String.fromEnvironment(
    'LOG_LEVEL',
    defaultValue: 'INFO',
  );

  // 密碼規則配置
  static const int minPasswordLength = 8;
  static const bool requireUppercase = true;
  static const bool requireLowercase = true;
  static const bool requireNumbers = true;
  static const bool requireSpecialChars = false;

  // Token 配置
  static const Duration accessTokenDuration = Duration(hours: 1);
  static const Duration refreshTokenDuration = Duration(days: 30);
  
  // 驗證配置
  static const Duration emailVerificationExpiry = Duration(hours: 24);
  static const Duration passwordResetExpiry = Duration(hours: 1);
  static const int maxVerificationAttempts = 5;
}
```

---

**文件完成日期**: 2025-01-27  
**版本**: 1.1.0  
**維護者**: LCAS 開發團隊  
**規範遵循**: 完全遵循 8020、8088、8101 文件規範
