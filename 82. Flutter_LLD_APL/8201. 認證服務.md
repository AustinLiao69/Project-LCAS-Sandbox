
# LCAS 2.0 認證服務 API - Low Level Design (LLD)

## 版本資訊
- 文件版本: 1.0.0
- API 版本: 1.1.0
- 日期: 2025-01-27
- 作者: LCAS 開發團隊

---

## 目錄
1. 簡介
2. 架構設計
3. 模組與類別設計
4. API 清單
5. API 詳細實作設計
6. 資料庫設計
7. 安全與驗證
8. 錯誤處理
9. 日誌與監控
10. 測試設計

---

## 1. 簡介

### 1.1 API 目的與範圍
認證服務 API 提供 LCAS 2.0 系統的完整認證功能，包括使用者註冊、登入、密碼管理、跨平台綁定等核心認證機制。本文件採用 **Dart** 語言實作客戶端 API 介面。

### 1.2 核心功能列表
- **使用者認證**：註冊、登入、登出
- **密碼管理**：忘記密碼、重設密碼、密碼加密
- **Token 管理**：JWT 生成、驗證、刷新
- **OAuth 整合**：Google OAuth 登入
- **跨平台綁定**：LINE 帳號綁定與狀態查詢
- **Email 驗證**：註冊驗證、地址驗證

### 1.3 支援的四種使用者模式
- **Expert**：完整認證選項、詳細安全資訊、進階設定
- **Inertial**：標準認證流程、基本安全提示、固定選項
- **Cultivation**：引導式認證、安全教育內容、進度追蹤
- **Guiding**：極簡認證、最少必要步驟、簡化流程

---

## 2. 架構設計

### 2.1 系統架構圖
```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│    (Flutter APP + LINE OA)             │
├─────────────────────────────────────────┤
│         API Gateway Layer               │
│    ┌─────────────────────────────────┐  │
│    │  認證中介層 (Auth Middleware)    │  │
│    │  - JWT 驗證                     │  │
│    │  - 模式判斷                     │  │
│    │  - 請求日誌                     │  │
│    └─────────────────────────────────┘  │
├─────────────────────────────────────────┤
│         Service Layer                   │
│    ┌─────────────────────────────────┐  │
│    │  認證服務 (AuthService)          │  │
│    │  - 登入/註冊邏輯                │  │
│    │  - 密碼管理                     │  │
│    │  - Token 管理                   │  │
│    └─────────────────────────────────┘  │
│    ┌─────────────────────────────────┐  │
│    │  OAuth 服務 (OAuthService)      │  │
│    │  - Google OAuth                 │  │
│    │  - 第三方驗證                   │  │
│    └─────────────────────────────────┘  │
│    ┌─────────────────────────────────┐  │
│    │  綁定服務 (BindingService)      │  │
│    │  - LINE 綁定                    │  │
│    │  - 綁定狀態管理                 │  │
│    └─────────────────────────────────┘  │
├─────────────────────────────────────────┤
│         Data Layer                      │
│           (Firestore)                   │
│    - Users Collection                   │
│    - AuthTokens Collection              │
│    - PasswordResetTokens Collection     │
│    - AccountBindings Collection         │
└─────────────────────────────────────────┘
```

### 2.2 模組間依賴圖
```
AuthController
    ├── AuthService
    │   ├── UserRepository
    │   ├── TokenService
    │   └── EmailService
    ├── OAuthService
    │   ├── GoogleOAuthProvider
    │   └── TokenService
    └── BindingService
        ├── LineAPIClient
        └── BindingRepository
```

### 2.3 外部服務整合
- **Google OAuth 2.0**：第三方登入驗證
- **LINE API**：帳號綁定與狀態查詢
- **Email Service**：驗證信發送
- **Firestore**：使用者資料儲存

---

## 3. 模組與類別設計

### 3.1 AuthController 類別 (Dart)
```dart
class AuthController {
  final AuthService _authService;
  final OAuthService _oauthService;
  final BindingService _bindingService;

  AuthController({
    required AuthService authService,
    required OAuthService oauthService,
    required BindingService bindingService,
  }) : _authService = authService,
       _oauthService = oauthService,
       _bindingService = bindingService;

  Future<ApiResponse<RegisterResponse>> register(RegisterRequest request) async {
    // 註冊邏輯實作
    try {
      final result = await _authService.registerUser(request);
      return ApiResponse.success(result);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<LoginResponse>> login(LoginRequest request) async {
    // 登入邏輯實作
    try {
      final result = await _authService.authenticateUser(
        request.email,
        request.password,
      );
      return ApiResponse.success(result);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<void>> logout(LogoutRequest request) async {
    // 登出邏輯實作
    try {
      await _authService.logoutUser(request);
      return ApiResponse.success(null);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<RefreshTokenResponse>> refreshToken(String refreshToken) async {
    // Token 刷新實作
    try {
      final result = await _authService.refreshToken(refreshToken);
      return ApiResponse.success(result);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<void>> forgotPassword(ForgotPasswordRequest request) async {
    // 忘記密碼實作
    try {
      await _authService.sendPasswordResetEmail(request.email);
      return ApiResponse.success(null);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<void>> resetPassword(ResetPasswordRequest request) async {
    // 重設密碼實作
    try {
      await _authService.resetPassword(request.token, request.newPassword);
      return ApiResponse.success(null);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<void>> verifyEmail(VerifyEmailRequest request) async {
    // Email 驗證實作
    try {
      await _authService.verifyEmail(request.email, request.verificationCode);
      return ApiResponse.success(null);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<LoginResponse>> googleLogin(GoogleLoginRequest request) async {
    // Google OAuth 登入實作
    try {
      final result = await _oauthService.authenticateWithGoogle(request.googleToken);
      return ApiResponse.success(result);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<BindingResponse>> bindLine(BindLineRequest request) async {
    // LINE 綁定實作
    try {
      final result = await _bindingService.bindLineAccount(
        request.lineUserId,
        request.lineAccessToken,
      );
      return ApiResponse.success(result);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }

  Future<ApiResponse<BindingStatusResponse>> getBindStatus() async {
    // 綁定狀態查詢實作
    try {
      final result = await _bindingService.getBindingStatus();
      return ApiResponse.success(result);
    } catch (e) {
      return ApiResponse.error(e.toString());
    }
  }
}
```

### 3.2 AuthService 類別 (Dart)
```dart
class AuthService {
  final UserRepository _userRepository;
  final TokenService _tokenService;
  final EmailService _emailService;
  final PasswordHashService _passwordHashService;

  AuthService({
    required UserRepository userRepository,
    required TokenService tokenService,
    required EmailService emailService,
    required PasswordHashService passwordHashService,
  }) : _userRepository = userRepository,
       _tokenService = tokenService,
       _emailService = emailService,
       _passwordHashService = passwordHashService;

  Future<RegisterResponse> registerUser(RegisterRequest request) async {
    // 使用者註冊邏輯
    // 1. 驗證輸入資料
    await _validateRegistrationData(request);
    
    // 2. 檢查 Email 是否已存在
    final existingUser = await _userRepository.findByEmail(request.email);
    if (existingUser != null) {
      throw AuthException('EMAIL_ALREADY_EXISTS', 'Email already registered');
    }
    
    // 3. 加密密碼
    final hashedPassword = await _passwordHashService.hashPassword(request.password);
    
    // 4. 建立使用者記錄
    final userData = UserData(
      id: _generateUUID(),
      email: request.email,
      password: hashedPassword,
      userMode: request.userMode ?? UserMode.inertial,
      emailVerified: false,
      createdAt: DateTime.now(),
      status: AccountStatus.active,
    );
    
    final user = await _userRepository.create(userData);
    
    // 5. 發送驗證信
    await _emailService.sendVerificationEmail(
      request.email,
      _generateVerificationCode(),
    );
    
    // 6. 生成 Token
    final tokens = await _tokenService.generateTokenPair(user);
    
    return RegisterResponse(
      userId: user.id,
      email: user.email,
      userMode: user.userMode,
      verificationSent: true,
      needsAssessment: false,
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt: tokens.expiresAt,
    );
  }

  Future<LoginResponse> authenticateUser(String email, String password) async {
    // 使用者認證邏輯
    // 1. 查詢使用者
    final user = await _userRepository.findByEmail(email);
    if (user == null) {
      throw AuthException('INVALID_CREDENTIALS', 'Invalid email or password');
    }
    
    // 2. 驗證密碼
    final isValidPassword = await _passwordHashService.verifyPassword(
      password,
      user.password,
    );
    if (!isValidPassword) {
      throw AuthException('INVALID_CREDENTIALS', 'Invalid email or password');
    }
    
    // 3. 檢查帳號狀態
    if (user.status == AccountStatus.locked) {
      throw AuthException('ACCOUNT_LOCKED', 'Account is locked');
    }
    
    // 4. 生成 Token
    final tokens = await _tokenService.generateTokenPair(user);
    
    // 5. 更新登入記錄
    await _userRepository.updateLoginHistory(user.id, LoginRecord(
      loginTime: DateTime.now(),
      deviceInfo: null, // 從請求中獲取
      ipAddress: null,  // 從請求中獲取
    ));
    
    return LoginResponse(
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt: tokens.expiresAt,
      user: UserProfile.fromUser(user),
    );
  }

  Future<void> sendPasswordResetEmail(String email) async {
    // 生成密碼重設 Token
    final user = await _userRepository.findByEmail(email);
    if (user == null) {
      // 為了安全性，即使 email 不存在也回傳成功
      return;
    }
    
    final resetToken = _generateSecureToken();
    await _userRepository.savePasswordResetToken(
      email,
      resetToken,
      DateTime.now().add(Duration(hours: 1)),
    );
    
    await _emailService.sendPasswordResetEmail(email, resetToken);
  }

  Future<void> resetPassword(String token, String newPassword) async {
    // 重設使用者密碼
    final resetRecord = await _userRepository.findPasswordResetToken(token);
    if (resetRecord == null || resetRecord.isExpired || resetRecord.isUsed) {
      throw AuthException('INVALID_RESET_TOKEN', 'Invalid or expired reset token');
    }
    
    final hashedPassword = await _passwordHashService.hashPassword(newPassword);
    await _userRepository.updatePassword(resetRecord.email, hashedPassword);
    await _userRepository.markResetTokenAsUsed(token);
  }

  Future<void> verifyEmail(String email, String verificationCode) async {
    // 驗證 Email 地址
    final isValid = await _userRepository.validateVerificationCode(email, verificationCode);
    if (!isValid) {
      throw AuthException('INVALID_VERIFICATION_CODE', 'Invalid verification code');
    }
    
    await _userRepository.markEmailAsVerified(email);
  }

  Future<RefreshTokenResponse> refreshToken(String refreshToken) async {
    // 刷新 Token
    final payload = await _tokenService.verifyRefreshToken(refreshToken);
    if (payload == null) {
      throw AuthException('INVALID_REFRESH_TOKEN', 'Invalid refresh token');
    }
    
    final user = await _userRepository.findById(payload.userId);
    if (user == null || user.status != AccountStatus.active) {
      throw AuthException('USER_NOT_FOUND', 'User not found or inactive');
    }
    
    final tokens = await _tokenService.generateTokenPair(user);
    await _tokenService.revokeToken(refreshToken);
    
    return RefreshTokenResponse(
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt: tokens.expiresAt,
    );
  }

  String _generateUUID() => Uuid().v4();
  String _generateVerificationCode() => Random().nextInt(999999).toString().padLeft(6, '0');
  String _generateSecureToken() => Uuid().v4();

  Future<void> _validateRegistrationData(RegisterRequest request) async {
    if (!_isValidEmail(request.email)) {
      throw AuthException('INVALID_EMAIL', 'Invalid email format');
    }
    
    if (request.password.length < 8) {
      throw AuthException('WEAK_PASSWORD', 'Password must be at least 8 characters');
    }
    
    if (!request.acceptTerms) {
      throw AuthException('TERMS_NOT_ACCEPTED', 'Must accept terms of service');
    }
  }

  bool _isValidEmail(String email) {
    return RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$').hasMatch(email);
  }
}
```

### 3.3 TokenService 類別 (Dart)
```dart
class TokenService {
  final String _accessTokenSecret;
  final String _refreshTokenSecret;
  final Duration _accessTokenDuration;
  final Duration _refreshTokenDuration;

  TokenService({
    required String accessTokenSecret,
    required String refreshTokenSecret,
    this._accessTokenDuration = const Duration(hours: 1),
    this._refreshTokenDuration = const Duration(days: 30),
  }) : _accessTokenSecret = accessTokenSecret,
       _refreshTokenSecret = refreshTokenSecret;

  Future<TokenPair> generateTokenPair(UserData user) async {
    final now = DateTime.now();
    final accessTokenExpiry = now.add(_accessTokenDuration);
    final refreshTokenExpiry = now.add(_refreshTokenDuration);

    final accessToken = await _generateAccessToken(user, accessTokenExpiry);
    final refreshToken = await _generateRefreshToken(user, refreshTokenExpiry);

    return TokenPair(
      accessToken: accessToken,
      refreshToken: refreshToken,
      expiresAt: accessTokenExpiry,
    );
  }

  Future<String> _generateAccessToken(UserData user, DateTime expiresAt) async {
    final payload = {
      'userId': user.id,
      'email': user.email,
      'userMode': user.userMode.toString(),
      'type': 'access',
      'iat': DateTime.now().millisecondsSinceEpoch ~/ 1000,
      'exp': expiresAt.millisecondsSinceEpoch ~/ 1000,
    };

    // 使用 JWT package 來生成 token
    final jwt = JWT(payload);
    return jwt.sign(SecretKey(_accessTokenSecret));
  }

  Future<String> _generateRefreshToken(UserData user, DateTime expiresAt) async {
    final payload = {
      'userId': user.id,
      'type': 'refresh',
      'iat': DateTime.now().millisecondsSinceEpoch ~/ 1000,
      'exp': expiresAt.millisecondsSinceEpoch ~/ 1000,
    };

    final jwt = JWT(payload);
    return jwt.sign(SecretKey(_refreshTokenSecret));
  }

  Future<TokenPayload?> verifyAccessToken(String token) async {
    try {
      final jwt = JWT.verify(token, SecretKey(_accessTokenSecret));
      return TokenPayload.fromJson(jwt.payload);
    } catch (e) {
      return null;
    }
  }

  Future<TokenPayload?> verifyRefreshToken(String token) async {
    try {
      final jwt = JWT.verify(token, SecretKey(_refreshTokenSecret));
      return TokenPayload.fromJson(jwt.payload);
    } catch (e) {
      return null;
    }
  }

  Future<void> revokeToken(String token) async {
    // 實作 token 撤銷邏輯
    // 通常會維護一個黑名單或在資料庫中標記為已撤銷
  }
}
```

### 3.4 UserModeAdapter 類別 (Dart)
```dart
class UserModeAdapter {
  static Map<String, dynamic> adaptResponse(
    Map<String, dynamic> data,
    UserMode userMode,
  ) {
    switch (userMode) {
      case UserMode.expert:
        return _adaptExpertMode(data);
      case UserMode.inertial:
        return _adaptInertialMode(data);
      case UserMode.cultivation:
        return _adaptCultivationMode(data);
      case UserMode.guiding:
        return _adaptGuidingMode(data);
    }
  }

  static Map<String, dynamic> _adaptExpertMode(Map<String, dynamic> data) {
    // 完整詳細資訊
    return {
      ...data,
      'securityInfo': data['securityInfo'],
      'loginHistory': data['loginHistory'],
      'advancedOptions': data['advancedOptions'],
    };
  }

  static Map<String, dynamic> _adaptInertialMode(Map<String, dynamic> data) {
    // 標準資訊
    return {
      'token': data['token'],
      'user': data['user'],
      'message': data['message'],
    };
  }

  static Map<String, dynamic> _adaptCultivationMode(Map<String, dynamic> data) {
    // 引導式資訊
    return {
      ...data,
      'streakInfo': data['streakInfo'],
      'achievements': data['achievements'],
      'motivationalContent': data['motivationalContent'],
    };
  }

  static Map<String, dynamic> _adaptGuidingMode(Map<String, dynamic> data) {
    // 極簡化資訊
    return {
      'token': data['token'],
      'message': '登入成功',
    };
  }
}
```

---

## 4. API 清單

### 4.1 認證服務 API 端點總覽

本節列出認證服務的所有 API 端點，嚴格遵循 8020. API list.md 和 8088. API設計規範.md 的規範。

| 端點 | HTTP 方法 | 描述 | 對應畫面 | 優先級 |
|------|----------|------|----------|--------|
| `/auth/register` | POST | 使用者註冊 | S-103 | P1 |
| `/auth/login` | POST | 使用者登入 | S-104 | P1 |
| `/auth/google-login` | POST | Google OAuth 登入 | S-104 | P1 |
| `/auth/logout` | POST | 使用者登出 | - | P1 |
| `/auth/refresh` | POST | 刷新 Token | - | P1 |
| `/auth/forgot-password` | POST | 忘記密碼 | S-105 | P1 |
| `/auth/verify-reset-token` | GET | 驗證重設連結 | S-105 | P1 |
| `/auth/reset-password` | POST | 重設密碼 | S-105 | P1 |
| `/auth/verify-email` | POST | 驗證 Email 地址 | S-103 | P1 |
| `/auth/bind-line` | POST | LINE 綁定 | S-107 | P1 |
| `/auth/bind-status` | GET | 綁定狀態查詢 | S-107 | P1 |

### 4.2 API 分類說明

#### 4.2.1 核心認證 API
- **註冊登入**：`register`, `login`, `google-login`
- **登出管理**：`logout`
- **Token 管理**：`refresh`

#### 4.2.2 密碼管理 API
- **密碼重設**：`forgot-password`, `verify-reset-token`, `reset-password`
- **Email 驗證**：`verify-email`

#### 4.2.3 跨平台綁定 API
- **LINE 整合**：`bind-line`, `bind-status`

### 4.3 API 設計規範遵循

#### 4.3.1 URL 設計規範（遵循 8088 文件）
```
https://api.lcas.app/v1/auth/{action}
```

所有端點均遵循以下設計原則：
- 使用 RESTful 架構
- 統一 `/auth` 前綴
- 動詞形式的操作（如 `login`, `logout`）
- 符合語義化命名

#### 4.3.2 HTTP 方法使用（遵循 8088 文件）
- **POST**：用於狀態變更操作（註冊、登入、登出等）
- **GET**：用於查詢操作（綁定狀態查詢、Token 驗證）

#### 4.3.3 四模式支援（遵循 8020 文件）
所有 API 端點均支援四種使用者模式的差異化回應：
- **Expert**：完整詳細資訊
- **Inertial**：標準資訊
- **Cultivation**：引導式資訊
- **Guiding**：極簡資訊

通過 `X-User-Mode` 標頭識別模式：
```http
X-User-Mode: Expert|Inertial|Cultivation|Guiding
```

### 4.4 回應格式標準（遵循 8088 文件）

#### 成功回應格式
```dart
class ApiResponse<T> {
  final bool success;
  final T? data;
  final ApiMetadata metadata;

  ApiResponse({
    required this.success,
    this.data,
    required this.metadata,
  });

  factory ApiResponse.success(T data) {
    return ApiResponse(
      success: true,
      data: data,
      metadata: ApiMetadata(
        timestamp: DateTime.now(),
        requestId: Uuid().v4(),
        userMode: UserMode.expert, // 從 context 獲取
      ),
    );
  }

  factory ApiResponse.error(String message, {String? code}) {
    return ApiResponse(
      success: false,
      data: null,
      metadata: ApiMetadata(
        timestamp: DateTime.now(),
        requestId: Uuid().v4(),
        error: ApiError(
          code: code ?? 'UNKNOWN_ERROR',
          message: message,
          timestamp: DateTime.now(),
        ),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    if (success) {
      return {
        'success': success,
        'data': data,
        'metadata': metadata.toJson(),
      };
    } else {
      return {
        'success': success,
        'error': metadata.error?.toJson(),
      };
    }
  }
}
```

#### 錯誤回應格式
```dart
class ApiError {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;
  final String? requestId;

  ApiError({
    required this.code,
    required this.message,
    this.field,
    required this.timestamp,
    this.requestId,
  });

  Map<String, dynamic> toJson() {
    return {
      'code': code,
      'message': message,
      if (field != null) 'field': field,
      'timestamp': timestamp.toIso8601String(),
      if (requestId != null) 'requestId': requestId,
    };
  }
}
```

### 4.5 API 契約規範

所有 API 端點必須遵循以下契約：
1. **請求標頭**：包含 `Authorization`, `X-User-Mode`, `X-Request-ID`
2. **內容格式**：`Content-Type: application/json; charset=utf-8`
3. **狀態碼**：遵循標準 HTTP 狀態碼規範
4. **錯誤處理**：統一錯誤回應格式
5. **安全性**：所有端點均實作適當的安全驗證

---

## 5. API 詳細實作設計

### 5.1 Endpoint: `/auth/register` (Dart Client)

#### Dart 客戶端實作
```dart
class AuthApiClient {
  final String baseUrl;
  final Dio _dio;

  AuthApiClient({required this.baseUrl}) : _dio = Dio() {
    _dio.options.baseUrl = baseUrl;
    _dio.options.connectTimeout = Duration(seconds: 30);
    _dio.options.receiveTimeout = Duration(seconds: 30);
    
    // 添加攔截器
    _dio.interceptors.add(LogInterceptor());
    _dio.interceptors.add(AuthInterceptor());
  }

  Future<ApiResponse<RegisterResponse>> register(RegisterRequest request) async {
    try {
      final response = await _dio.post(
        '/auth/register',
        data: request.toJson(),
        options: Options(
          headers: {
            'Content-Type': 'application/json; charset=utf-8',
            'X-User-Mode': request.userMode.toString().split('.').last,
            'X-Request-ID': Uuid().v4(),
          },
        ),
      );

      if (response.statusCode == 201) {
        final responseData = RegisterResponse.fromJson(response.data['data']);
        return ApiResponse.success(responseData);
      } else {
        return ApiResponse.error('Registration failed');
      }
    } on DioException catch (e) {
      return _handleDioError(e);
    } catch (e) {
      return ApiResponse.error('Unexpected error: $e');
    }
  }
}
```

#### Request/Response 模型
```dart
class RegisterRequest {
  final String email;
  final String password;
  final String? confirmPassword;
  final String? displayName;
  final UserMode userMode;
  final bool acceptTerms;
  final bool acceptPrivacy;
  final String? timezone;
  final String? language;

  RegisterRequest({
    required this.email,
    required this.password,
    this.confirmPassword,
    this.displayName,
    required this.userMode,
    required this.acceptTerms,
    required this.acceptPrivacy,
    this.timezone,
    this.language,
  });

  Map<String, dynamic> toJson() {
    return {
      'email': email,
      'password': password,
      if (confirmPassword != null) 'confirmPassword': confirmPassword,
      if (displayName != null) 'displayName': displayName,
      'userMode': userMode.toString().split('.').last,
      'acceptTerms': acceptTerms,
      'acceptPrivacy': acceptPrivacy,
      if (timezone != null) 'timezone': timezone,
      if (language != null) 'language': language,
    };
  }
}

class RegisterResponse {
  final String userId;
  final String email;
  final UserMode userMode;
  final bool verificationSent;
  final bool needsAssessment;
  final String token;
  final String refreshToken;
  final DateTime expiresAt;

  RegisterResponse({
    required this.userId,
    required this.email,
    required this.userMode,
    required this.verificationSent,
    required this.needsAssessment,
    required this.token,
    required this.refreshToken,
    required this.expiresAt,
  });

  factory RegisterResponse.fromJson(Map<String, dynamic> json) {
    return RegisterResponse(
      userId: json['userId'],
      email: json['email'],
      userMode: UserMode.values.firstWhere(
        (mode) => mode.toString().split('.').last == json['userMode'],
      ),
      verificationSent: json['verificationSent'],
      needsAssessment: json['needsAssessment'],
      token: json['token'],
      refreshToken: json['refreshToken'],
      expiresAt: DateTime.parse(json['expiresAt']),
    );
  }
}
```

### 5.2 Endpoint: `/auth/login` (Dart Client)

#### Dart 客戶端實作
```dart
Future<ApiResponse<LoginResponse>> login(LoginRequest request) async {
  try {
    final response = await _dio.post(
      '/auth/login',
      data: request.toJson(),
      options: Options(
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'X-Request-ID': Uuid().v4(),
        },
      ),
    );

    if (response.statusCode == 200) {
      final responseData = LoginResponse.fromJson(response.data['data']);
      
      // 根據使用者模式適配回應
      final adaptedData = UserModeAdapter.adaptResponse(
        response.data['data'],
        responseData.user.userMode,
      );
      
      return ApiResponse.success(LoginResponse.fromJson(adaptedData));
    } else {
      return ApiResponse.error('Login failed');
    }
  } on DioException catch (e) {
    return _handleDioError(e);
  }
}
```

#### Request/Response 模型
```dart
class LoginRequest {
  final String email;
  final String password;
  final bool rememberMe;
  final DeviceInfo? deviceInfo;

  LoginRequest({
    required this.email,
    required this.password,
    this.rememberMe = false,
    this.deviceInfo,
  });

  Map<String, dynamic> toJson() {
    return {
      'email': email,
      'password': password,
      'rememberMe': rememberMe,
      if (deviceInfo != null) 'deviceInfo': deviceInfo!.toJson(),
    };
  }
}

class LoginResponse {
  final String token;
  final String refreshToken;
  final DateTime expiresAt;
  final UserProfile user;
  final LoginHistory? loginHistory; // Expert 模式專用
  final StreakInfo? streakInfo;     // Cultivation 模式專用

  LoginResponse({
    required this.token,
    required this.refreshToken,
    required this.expiresAt,
    required this.user,
    this.loginHistory,
    this.streakInfo,
  });

  factory LoginResponse.fromJson(Map<String, dynamic> json) {
    return LoginResponse(
      token: json['token'],
      refreshToken: json['refreshToken'],
      expiresAt: DateTime.parse(json['expiresAt']),
      user: UserProfile.fromJson(json['user']),
      loginHistory: json['loginHistory'] != null 
          ? LoginHistory.fromJson(json['loginHistory'])
          : null,
      streakInfo: json['streakInfo'] != null
          ? StreakInfo.fromJson(json['streakInfo'])
          : null,
    );
  }
}
```

### 5.3 錯誤處理實作 (Dart)

```dart
ApiResponse<T> _handleDioError<T>(DioException e) {
  switch (e.type) {
    case DioExceptionType.connectionTimeout:
    case DioExceptionType.sendTimeout:
    case DioExceptionType.receiveTimeout:
      return ApiResponse.error(
        'Connection timeout',
        code: 'TIMEOUT_ERROR',
      );
    
    case DioExceptionType.badResponse:
      final statusCode = e.response?.statusCode;
      final errorData = e.response?.data;
      
      if (errorData != null && errorData['error'] != null) {
        return ApiResponse.error(
          errorData['error']['message'] ?? 'Unknown error',
          code: errorData['error']['code'] ?? 'UNKNOWN_ERROR',
        );
      }
      
      switch (statusCode) {
        case 400:
          return ApiResponse.error('Bad request', code: 'BAD_REQUEST');
        case 401:
          return ApiResponse.error('Unauthorized', code: 'UNAUTHORIZED');
        case 403:
          return ApiResponse.error('Forbidden', code: 'FORBIDDEN');
        case 404:
          return ApiResponse.error('Not found', code: 'NOT_FOUND');
        case 409:
          return ApiResponse.error('Conflict', code: 'CONFLICT');
        case 422:
          return ApiResponse.error('Validation error', code: 'VALIDATION_ERROR');
        case 500:
          return ApiResponse.error('Internal server error', code: 'SERVER_ERROR');
        default:
          return ApiResponse.error('HTTP error $statusCode', code: 'HTTP_ERROR');
      }
    
    case DioExceptionType.cancel:
      return ApiResponse.error('Request cancelled', code: 'CANCELLED');
    
    case DioExceptionType.unknown:
      return ApiResponse.error('Network error', code: 'NETWORK_ERROR');
    
    default:
      return ApiResponse.error('Unknown error', code: 'UNKNOWN_ERROR');
  }
}
```

---

## 6. 資料庫設計

### 6.1 Firestore Collection 結構

#### Users Collection
```dart
class UserData {
  final String id;
  final String email;
  final String password;
  final String? displayName;
  final String? avatar;
  final UserMode userMode;
  final bool emailVerified;
  final AccountStatus status;
  final AuthProvider authProvider;
  final String? googleId;
  final UserPreferences preferences;
  final SecuritySettings security;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastActiveAt;

  UserData({
    required this.id,
    required this.email,
    required this.password,
    this.displayName,
    this.avatar,
    required this.userMode,
    required this.emailVerified,
    required this.status,
    required this.authProvider,
    this.googleId,
    required this.preferences,
    required this.security,
    required this.createdAt,
    required this.updatedAt,
    this.lastActiveAt,
  });

  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'email': email,
      'password': password,
      'displayName': displayName,
      'avatar': avatar,
      'userMode': userMode.toString().split('.').last,
      'emailVerified': emailVerified,
      'status': status.toString().split('.').last,
      'authProvider': authProvider.toString().split('.').last,
      'googleId': googleId,
      'preferences': preferences.toMap(),
      'security': security.toMap(),
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'lastActiveAt': lastActiveAt != null ? Timestamp.fromDate(lastActiveAt!) : null,
    };
  }

  factory UserData.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserData(
      id: data['id'],
      email: data['email'],
      password: data['password'],
      displayName: data['displayName'],
      avatar: data['avatar'],
      userMode: UserMode.values.firstWhere(
        (mode) => mode.toString().split('.').last == data['userMode'],
      ),
      emailVerified: data['emailVerified'],
      status: AccountStatus.values.firstWhere(
        (status) => status.toString().split('.').last == data['status'],
      ),
      authProvider: AuthProvider.values.firstWhere(
        (provider) => provider.toString().split('.').last == data['authProvider'],
      ),
      googleId: data['googleId'],
      preferences: UserPreferences.fromMap(data['preferences']),
      security: SecuritySettings.fromMap(data['security']),
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp).toDate(),
      lastActiveAt: data['lastActiveAt'] != null 
          ? (data['lastActiveAt'] as Timestamp).toDate()
          : null,
    );
  }
}
```

#### AuthTokens Collection
```dart
class AuthTokenData {
  final String id;
  final String userId;
  final TokenType tokenType;
  final String tokenHash;
  final DeviceInfo? deviceInfo;
  final String? ipAddress;
  final DateTime issuedAt;
  final DateTime expiresAt;
  final DateTime? revokedAt;
  final DateTime? lastUsedAt;

  AuthTokenData({
    required this.id,
    required this.userId,
    required this.tokenType,
    required this.tokenHash,
    this.deviceInfo,
    this.ipAddress,
    required this.issuedAt,
    required this.expiresAt,
    this.revokedAt,
    this.lastUsedAt,
  });

  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'userId': userId,
      'tokenType': tokenType.toString().split('.').last,
      'tokenHash': tokenHash,
      'deviceInfo': deviceInfo?.toMap(),
      'ipAddress': ipAddress,
      'issuedAt': Timestamp.fromDate(issuedAt),
      'expiresAt': Timestamp.fromDate(expiresAt),
      'revokedAt': revokedAt != null ? Timestamp.fromDate(revokedAt!) : null,
      'lastUsedAt': lastUsedAt != null ? Timestamp.fromDate(lastUsedAt!) : null,
    };
  }

  factory AuthTokenData.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return AuthTokenData(
      id: data['id'],
      userId: data['userId'],
      tokenType: TokenType.values.firstWhere(
        (type) => type.toString().split('.').last == data['tokenType'],
      ),
      tokenHash: data['tokenHash'],
      deviceInfo: data['deviceInfo'] != null 
          ? DeviceInfo.fromMap(data['deviceInfo'])
          : null,
      ipAddress: data['ipAddress'],
      issuedAt: (data['issuedAt'] as Timestamp).toDate(),
      expiresAt: (data['expiresAt'] as Timestamp).toDate(),
      revokedAt: data['revokedAt'] != null 
          ? (data['revokedAt'] as Timestamp).toDate()
          : null,
      lastUsedAt: data['lastUsedAt'] != null 
          ? (data['lastUsedAt'] as Timestamp).toDate()
          : null,
    );
  }
}
```

### 6.2 Repository 實作 (Dart)
```dart
class UserRepository {
  final FirebaseFirestore _firestore;
  final String _collectionName = 'users';

  UserRepository({required FirebaseFirestore firestore}) 
      : _firestore = firestore;

  Future<UserData?> findByEmail(String email) async {
    try {
      final querySnapshot = await _firestore
          .collection(_collectionName)
          .where('email', isEqualTo: email)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return null;
      }

      return UserData.fromFirestore(querySnapshot.docs.first);
    } catch (e) {
      throw RepositoryException('Failed to find user by email: $e');
    }
  }

  Future<UserData?> findById(String id) async {
    try {
      final doc = await _firestore
          .collection(_collectionName)
          .doc(id)
          .get();

      if (!doc.exists) {
        return null;
      }

      return UserData.fromFirestore(doc);
    } catch (e) {
      throw RepositoryException('Failed to find user by ID: $e');
    }
  }

  Future<UserData> create(UserData userData) async {
    try {
      final docRef = _firestore.collection(_collectionName).doc(userData.id);
      await docRef.set(userData.toFirestore());
      
      final createdDoc = await docRef.get();
      return UserData.fromFirestore(createdDoc);
    } catch (e) {
      throw RepositoryException('Failed to create user: $e');
    }
  }

  Future<void> updateLoginHistory(String userId, LoginRecord loginRecord) async {
    try {
      await _firestore
          .collection(_collectionName)
          .doc(userId)
          .update({
        'lastActiveAt': Timestamp.fromDate(loginRecord.loginTime),
        'security.lastLoginAt': Timestamp.fromDate(loginRecord.loginTime),
        'security.loginCount': FieldValue.increment(1),
      });
    } catch (e) {
      throw RepositoryException('Failed to update login history: $e');
    }
  }

  Future<void> updatePassword(String email, String hashedPassword) async {
    try {
      final userQuery = await _firestore
          .collection(_collectionName)
          .where('email', isEqualTo: email)
          .limit(1)
          .get();

      if (userQuery.docs.isEmpty) {
        throw RepositoryException('User not found');
      }

      await userQuery.docs.first.reference.update({
        'password': hashedPassword,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
    } catch (e) {
      throw RepositoryException('Failed to update password: $e');
    }
  }

  Future<void> markEmailAsVerified(String email) async {
    try {
      final userQuery = await _firestore
          .collection(_collectionName)
          .where('email', isEqualTo: email)
          .limit(1)
          .get();

      if (userQuery.docs.isEmpty) {
        throw RepositoryException('User not found');
      }

      await userQuery.docs.first.reference.update({
        'emailVerified': true,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
    } catch (e) {
      throw RepositoryException('Failed to mark email as verified: $e');
    }
  }
}
```

---

## 7. 安全與驗證

### 7.1 JWT Token 處理 (Dart)
```dart
class JWTHandler {
  static Map<String, dynamic>? decodeToken(String token) {
    try {
      final parts = token.split('.');
      if (parts.length != 3) {
        return null;
      }

      final payload = parts[1];
      final normalizedPayload = base64Url.normalize(payload);
      final decodedBytes = base64Url.decode(normalizedPayload);
      final decodedString = utf8.decode(decodedBytes);
      
      return json.decode(decodedString) as Map<String, dynamic>;
    } catch (e) {
      return null;
    }
  }

  static bool isTokenExpired(String token) {
    final payload = decodeToken(token);
    if (payload == null) return true;

    final exp = payload['exp'] as int?;
    if (exp == null) return true;

    final expirationDate = DateTime.fromMillisecondsSinceEpoch(exp * 1000);
    return DateTime.now().isAfter(expirationDate);
  }

  static String? getUserIdFromToken(String token) {
    final payload = decodeToken(token);
    return payload?['userId'] as String?;
  }

  static UserMode? getUserModeFromToken(String token) {
    final payload = decodeToken(token);
    final modeString = payload?['userMode'] as String?;
    
    if (modeString == null) return null;
    
    return UserMode.values.firstWhere(
      (mode) => mode.toString().split('.').last == modeString,
      orElse: () => UserMode.inertial,
    );
  }
}
```

### 7.2 密碼加密服務 (Dart)
```dart
class PasswordHashService {
  static const int _saltRounds = 12;

  Future<String> hashPassword(String password) async {
    try {
      final salt = BCrypt.gensalt(logRounds: _saltRounds);
      return BCrypt.hashpw(password, salt);
    } catch (e) {
      throw SecurityException('Failed to hash password: $e');
    }
  }

  Future<bool> verifyPassword(String password, String hashedPassword) async {
    try {
      return BCrypt.checkpw(password, hashedPassword);
    } catch (e) {
      throw SecurityException('Failed to verify password: $e');
    }
  }

  bool validatePasswordStrength(String password) {
    // 至少 8 個字元
    if (password.length < 8) return false;
    
    // 包含大寫字母
    if (!RegExp(r'[A-Z]').hasMatch(password)) return false;
    
    // 包含小寫字母
    if (!RegExp(r'[a-z]').hasMatch(password)) return false;
    
    // 包含數字
    if (!RegExp(r'[0-9]').hasMatch(password)) return false;
    
    return true;
  }

  List<String> getPasswordStrengthErrors(String password) {
    final errors = <String>[];
    
    if (password.length < 8) {
      errors.add('密碼長度至少需要 8 個字元');
    }
    
    if (!RegExp(r'[A-Z]').hasMatch(password)) {
      errors.add('密碼需包含至少一個大寫字母');
    }
    
    if (!RegExp(r'[a-z]').hasMatch(password)) {
      errors.add('密碼需包含至少一個小寫字母');
    }
    
    if (!RegExp(r'[0-9]').hasMatch(password)) {
      errors.add('密碼需包含至少一個數字');
    }
    
    return errors;
  }
}
```

### 7.3 OAuth 服務 (Dart)
```dart
class OAuthService {
  final GoogleSignIn _googleSignIn;
  final UserRepository _userRepository;
  final TokenService _tokenService;

  OAuthService({
    required GoogleSignIn googleSignIn,
    required UserRepository userRepository,
    required TokenService tokenService,
  }) : _googleSignIn = googleSignIn,
       _userRepository = userRepository,
       _tokenService = tokenService;

  Future<LoginResponse> authenticateWithGoogle(String googleToken) async {
    try {
      // 驗證 Google Token
      final googleUser = await _verifyGoogleToken(googleToken);
      if (googleUser == null) {
        throw AuthException('INVALID_GOOGLE_TOKEN', 'Invalid Google token');
      }

      // 檢查使用者是否已存在
      var user = await _userRepository.findByEmail(googleUser.email);
      
      if (user == null) {
        // 創建新使用者
        user = await _createUserFromGoogle(googleUser);
      } else {
        // 更新 Google 資訊
        await _updateGoogleInfo(user, googleUser);
      }

      // 生成 Token
      final tokens = await _tokenService.generateTokenPair(user);

      return LoginResponse(
        token: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        expiresAt: tokens.expiresAt,
        user: UserProfile.fromUser(user),
      );
    } catch (e) {
      throw AuthException('GOOGLE_AUTH_FAILED', 'Google authentication failed: $e');
    }
  }

  Future<GoogleUserInfo?> _verifyGoogleToken(String token) async {
    try {
      // 使用 Google APIs 驗證 token
      final response = await http.get(
        Uri.parse('https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=$token'),
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body) as Map<String, dynamic>;
        return GoogleUserInfo.fromJson(data);
      }
      
      return null;
    } catch (e) {
      return null;
    }
  }

  Future<UserData> _createUserFromGoogle(GoogleUserInfo googleUser) async {
    final userData = UserData(
      id: Uuid().v4(),
      email: googleUser.email,
      password: '', // Google 使用者不需要密碼
      displayName: googleUser.name,
      avatar: googleUser.picture,
      userMode: UserMode.inertial,
      emailVerified: googleUser.emailVerified,
      status: AccountStatus.active,
      authProvider: AuthProvider.google,
      googleId: googleUser.id,
      preferences: UserPreferences.defaultSettings(),
      security: SecuritySettings.defaultSettings(),
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );

    return await _userRepository.create(userData);
  }

  Future<void> _updateGoogleInfo(UserData user, GoogleUserInfo googleUser) async {
    // 更新 Google 相關資訊
    await _userRepository.update(user.id, {
      'googleId': googleUser.id,
      'avatar': googleUser.picture,
      'updatedAt': DateTime.now(),
    });
  }
}
```

---

## 8. 錯誤處理

### 8.1 自定義例外類別 (Dart)
```dart
abstract class LCASException implements Exception {
  final String code;
  final String message;
  final String? field;
  final DateTime timestamp;

  LCASException(this.code, this.message, {this.field}) 
      : timestamp = DateTime.now();

  @override
  String toString() => 'LCASException: [$code] $message';

  Map<String, dynamic> toJson() {
    return {
      'code': code,
      'message': message,
      if (field != null) 'field': field,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}

class AuthException extends LCASException {
  AuthException(String code, String message, {String? field}) 
      : super(code, message, field: field);
}

class ValidationException extends LCASException {
  final List<ValidationError> validationErrors;

  ValidationException(String code, String message, this.validationErrors, {String? field}) 
      : super(code, message, field: field);

  @override
  Map<String, dynamic> toJson() {
    return {
      ...super.toJson(),
      'details': {
        'validation': validationErrors.map((e) => e.toJson()).toList(),
      },
    };
  }
}

class ValidationError {
  final String field;
  final String message;
  final String? code;
  final dynamic value;

  ValidationError({
    required this.field,
    required this.message,
    this.code,
    this.value,
  });

  Map<String, dynamic> toJson() {
    return {
      'field': field,
      'message': message,
      if (code != null) 'code': code,
      if (value != null) 'value': value,
    };
  }
}

class BusinessLogicException extends LCASException {
  BusinessLogicException(String code, String message, {String? field}) 
      : super(code, message, field: field);
}

class SecurityException extends LCASException {
  SecurityException(String message) 
      : super('SECURITY_ERROR', message);
}

class RepositoryException extends LCASException {
  RepositoryException(String message) 
      : super('REPOSITORY_ERROR', message);
}
```

### 8.2 錯誤攔截器 (Dart)
```dart
class AuthInterceptor extends Interceptor {
  final TokenService _tokenService;
  final AuthStorage _authStorage;

  AuthInterceptor({
    required TokenService tokenService,
    required AuthStorage authStorage,
  }) : _tokenService = tokenService,
       _authStorage = authStorage;

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    // 添加 Authorization header
    final token = await _authStorage.getAccessToken();
    if (token != null && !JWTHandler.isTokenExpired(token)) {
      options.headers['Authorization'] = 'Bearer $token';
    }

    // 添加使用者模式 header
    final userMode = await _authStorage.getUserMode();
    if (userMode != null) {
      options.headers['X-User-Mode'] = userMode.toString().split('.').last;
    }

    super.onRequest(options, handler);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    // 處理 401 錯誤，嘗試刷新 token
    if (err.response?.statusCode == 401) {
      final refreshToken = await _authStorage.getRefreshToken();
      
      if (refreshToken != null && !JWTHandler.isTokenExpired(refreshToken)) {
        try {
          final newTokens = await _tokenService.refreshTokens(refreshToken);
          await _authStorage.saveTokens(newTokens);
          
          // 重新發送原始請求
          final clonedRequest = await _cloneRequest(err.requestOptions);
          clonedRequest.headers['Authorization'] = 'Bearer ${newTokens.accessToken}';
          
          final response = await Dio().fetch(clonedRequest);
          return handler.resolve(response);
        } catch (e) {
          // Token 刷新失敗，清除本地存儲並導向登入
          await _authStorage.clearTokens();
          // 觸發登出事件
        }
      }
    }

    super.onError(err, handler);
  }

  Future<RequestOptions> _cloneRequest(RequestOptions options) async {
    return RequestOptions(
      path: options.path,
      method: options.method,
      data: options.data,
      queryParameters: options.queryParameters,
      headers: Map.from(options.headers),
      connectTimeout: options.connectTimeout,
      receiveTimeout: options.receiveTimeout,
      sendTimeout: options.sendTimeout,
    );
  }
}
```

---

## 9. 日誌與監控

### 9.1 日誌服務 (Dart)
```dart
class LogService {
  static final Logger _logger = Logger('AuthService');

  static void logAuthAttempt({
    required String email,
    required bool success,
    String? reason,
    String? deviceInfo,
    String? ipAddress,
  }) {
    final logData = {
      'event': 'AUTH_ATTEMPT',
      'email': _maskEmail(email),
      'success': success,
      'reason': reason,
      'deviceInfo': deviceInfo,
      'ipAddress': ipAddress,
      'timestamp': DateTime.now().toIso8601String(),
    };

    if (success) {
      _logger.info('Authentication successful: ${json.encode(logData)}');
    } else {
      _logger.warning('Authentication failed: ${json.encode(logData)}');
    }
  }

  static void logTokenEvent({
    required String tokenId,
    required String userId,
    required String action,
    String? endpoint,
  }) {
    final logData = {
      'event': 'TOKEN_EVENT',
      'tokenId': tokenId,
      'userId': userId,
      'action': action,
      'endpoint': endpoint,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.info('Token event: ${json.encode(logData)}');
  }

  static void logSecurityEvent({
    required String eventType,
    required String userId,
    required String description,
    Map<String, dynamic>? details,
  }) {
    final logData = {
      'event': 'SECURITY_EVENT',
      'eventType': eventType,
      'userId': userId,
      'description': description,
      'details': details,
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.warning('Security event: ${json.encode(logData)}');
  }

  static void logError({
    required String error,
    required String context,
    String? userId,
    StackTrace? stackTrace,
  }) {
    final logData = {
      'event': 'ERROR',
      'error': error,
      'context': context,
      'userId': userId,
      'stackTrace': stackTrace?.toString(),
      'timestamp': DateTime.now().toIso8601String(),
    };

    _logger.severe('Error occurred: ${json.encode(logData)}');
  }

  static String _maskEmail(String email) {
    final parts = email.split('@');
    if (parts.length != 2) return '***';
    
    final local = parts[0];
    final domain = parts[1];
    
    if (local.length <= 2) {
      return '***@$domain';
    }
    
    return '${local.substring(0, 2)}***@$domain';
  }
}
```

### 9.2 效能監控 (Dart)
```dart
class PerformanceMonitor {
  static final Map<String, Stopwatch> _timers = {};

  static void startTimer(String operation) {
    _timers[operation] = Stopwatch()..start();
  }

  static void endTimer(String operation, {Map<String, dynamic>? metadata}) {
    final timer = _timers.remove(operation);
    if (timer == null) return;

    timer.stop();
    final duration = timer.elapsedMilliseconds;

    LogService._logger.info('Performance: $operation took ${duration}ms', metadata);

    // 如果操作時間過長，記錄警告
    if (duration > 5000) {
      LogService.logError(
        error: 'Slow operation detected',
        context: '$operation took ${duration}ms',
      );
    }
  }

  static T measureOperation<T>(String operation, T Function() function) {
    startTimer(operation);
    try {
      return function();
    } finally {
      endTimer(operation);
    }
  }

  static Future<T> measureAsyncOperation<T>(
    String operation,
    Future<T> Function() function,
  ) async {
    startTimer(operation);
    try {
      return await function();
    } finally {
      endTimer(operation);
    }
  }
}
```

---

## 10. 測試設計

### 10.1 單元測試 (Dart)
```dart
import 'package:test/test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

@GenerateMocks([
  UserRepository,
  TokenService,
  EmailService,
  PasswordHashService,
])
import 'auth_service_test.mocks.dart';

void main() {
  group('AuthService Tests', () {
    late AuthService authService;
    late MockUserRepository mockUserRepository;
    late MockTokenService mockTokenService;
    late MockEmailService mockEmailService;
    late MockPasswordHashService mockPasswordHashService;

    setUp(() {
      mockUserRepository = MockUserRepository();
      mockTokenService = MockTokenService();
      mockEmailService = MockEmailService();
      mockPasswordHashService = MockPasswordHashService();

      authService = AuthService(
        userRepository: mockUserRepository,
        tokenService: mockTokenService,
        emailService: mockEmailService,
        passwordHashService: mockPasswordHashService,
      );
    });

    group('registerUser', () {
      test('should successfully register a new user', () async {
        // Arrange
        final request = RegisterRequest(
          email: 'test@example.com',
          password: 'securePassword123',
          userMode: UserMode.expert,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => null);
        
        when(mockPasswordHashService.hashPassword(any))
            .thenAnswer((_) async => 'hashed_password');
        
        when(mockUserRepository.create(any))
            .thenAnswer((_) async => UserData(
              id: 'user-123',
              email: request.email,
              password: 'hashed_password',
              userMode: request.userMode,
              emailVerified: false,
              status: AccountStatus.active,
              authProvider: AuthProvider.email,
              preferences: UserPreferences.defaultSettings(),
              security: SecuritySettings.defaultSettings(),
              createdAt: DateTime.now(),
              updatedAt: DateTime.now(),
            ));

        when(mockEmailService.sendVerificationEmail(any, any))
            .thenAnswer((_) async => {});

        when(mockTokenService.generateTokenPair(any))
            .thenAnswer((_) async => TokenPair(
              accessToken: 'access_token',
              refreshToken: 'refresh_token',
              expiresAt: DateTime.now().add(Duration(hours: 1)),
            ));

        // Act
        final result = await authService.registerUser(request);

        // Assert
        expect(result.userId, equals('user-123'));
        expect(result.email, equals(request.email));
        expect(result.userMode, equals(request.userMode));
        expect(result.verificationSent, isTrue);
        
        verify(mockUserRepository.findByEmail(request.email)).called(1);
        verify(mockPasswordHashService.hashPassword(request.password)).called(1);
        verify(mockUserRepository.create(any)).called(1);
        verify(mockEmailService.sendVerificationEmail(request.email, any)).called(1);
        verify(mockTokenService.generateTokenPair(any)).called(1);
      });

      test('should throw exception when email already exists', () async {
        // Arrange
        final request = RegisterRequest(
          email: 'existing@example.com',
          password: 'securePassword123',
          userMode: UserMode.expert,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        final existingUser = UserData(
          id: 'existing-user',
          email: request.email,
          password: 'existing_password',
          userMode: UserMode.inertial,
          emailVerified: true,
          status: AccountStatus.active,
          authProvider: AuthProvider.email,
          preferences: UserPreferences.defaultSettings(),
          security: SecuritySettings.defaultSettings(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => existingUser);

        // Act & Assert
        expect(
          () => authService.registerUser(request),
          throwsA(isA<AuthException>()
              .having((e) => e.code, 'code', 'EMAIL_ALREADY_EXISTS')),
        );
      });
    });

    group('authenticateUser', () {
      test('should successfully authenticate valid credentials', () async {
        // Arrange
        const email = 'test@example.com';
        const password = 'correctPassword';
        const hashedPassword = 'hashed_correct_password';

        final user = UserData(
          id: 'user-123',
          email: email,
          password: hashedPassword,
          userMode: UserMode.expert,
          emailVerified: true,
          status: AccountStatus.active,
          authProvider: AuthProvider.email,
          preferences: UserPreferences.defaultSettings(),
          security: SecuritySettings.defaultSettings(),
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        when(mockUserRepository.findByEmail(email))
            .thenAnswer((_) async => user);
        
        when(mockPasswordHashService.verifyPassword(password, hashedPassword))
            .thenAnswer((_) async => true);

        when(mockTokenService.generateTokenPair(user))
            .thenAnswer((_) async => TokenPair(
              accessToken: 'access_token',
              refreshToken: 'refresh_token',
              expiresAt: DateTime.now().add(Duration(hours: 1)),
            ));

        when(mockUserRepository.updateLoginHistory(any, any))
            .thenAnswer((_) async => {});

        // Act
        final result = await authService.authenticateUser(email, password);

        // Assert
        expect(result.token, equals('access_token'));
        expect(result.refreshToken, equals('refresh_token'));
        expect(result.user.email, equals(email));
        
        verify(mockUserRepository.findByEmail(email)).called(1);
        verify(mockPasswordHashService.verifyPassword(password, hashedPassword)).called(1);
        verify(mockTokenService.generateTokenPair(user)).called(1);
        verify(mockUserRepository.updateLoginHistory(user.id, any)).called(1);
      });

      test('should throw exception for invalid credentials', () async {
        // Arrange
        when(mockUserRepository.findByEmail(any))
            .thenAnswer((_) async => null);

        // Act & Assert
        expect(
          () => authService.authenticateUser('invalid@example.com', 'wrongPassword'),
          throwsA(isA<AuthException>()
              .having((e) => e.code, 'code', 'INVALID_CREDENTIALS')),
        );
      });
    });
  });
}
```

### 10.2 整合測試 (Dart)
```dart
import 'package:integration_test/integration_test.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Auth API Integration Tests', () {
    late AuthApiClient authApiClient;

    setUpAll(() {
      authApiClient = AuthApiClient(
        baseUrl: 'https://api-staging.lcas.com',
      );
    });

    testWidgets('Complete registration to login flow', (WidgetTester tester) async {
      // Step 1: Register
      final registerRequest = RegisterRequest(
        email: 'integration_test_${DateTime.now().millisecondsSinceEpoch}@example.com',
        password: 'TestPassword123',
        userMode: UserMode.expert,
        acceptTerms: true,
        acceptPrivacy: true,
      );

      final registerResponse = await authApiClient.register(registerRequest);
      
      expect(registerResponse.success, isTrue);
      expect(registerResponse.data?.userId, isNotNull);
      
      final userId = registerResponse.data!.userId;

      // Step 2: Verify Email (使用測試環境的固定驗證碼)
      final verifyEmailRequest = VerifyEmailRequest(
        email: registerRequest.email,
        verificationCode: '123456', // 測試環境固定碼
      );

      final verifyResponse = await authApiClient.verifyEmail(verifyEmailRequest);
      expect(verifyResponse.success, isTrue);

      // Step 3: Login
      final loginRequest = LoginRequest(
        email: registerRequest.email,
        password: registerRequest.password,
      );

      final loginResponse = await authApiClient.login(loginRequest);
      
      expect(loginResponse.success, isTrue);
      expect(loginResponse.data?.user.id, equals(userId));
      expect(loginResponse.data?.token, isNotNull);

      // Step 4: Use token to access protected resource
      final token = loginResponse.data!.token;
      
      // 設置 token 並測試受保護的端點
      authApiClient.setAuthToken(token);
      
      final bindStatusResponse = await authApiClient.getBindStatus();
      expect(bindStatusResponse.success, isTrue);
    });

    testWidgets('Four modes differentiation test', (WidgetTester tester) async {
      final baseEmail = 'mode_test_${DateTime.now().millisecondsSinceEpoch}';
      
      for (final mode in UserMode.values) {
        // 註冊不同模式的使用者
        final registerRequest = RegisterRequest(
          email: '${baseEmail}_${mode.toString().split('.').last}@example.com',
          password: 'TestPassword123',
          userMode: mode,
          acceptTerms: true,
          acceptPrivacy: true,
        );

        final registerResponse = await authApiClient.register(registerRequest);
        expect(registerResponse.success, isTrue);

        // 登入並檢查回應差異
        final loginRequest = LoginRequest(
          email: registerRequest.email,
          password: registerRequest.password,
        );

        final loginResponse = await authApiClient.login(loginRequest);
        expect(loginResponse.success, isTrue);

        // 根據模式驗證回應內容
        switch (mode) {
          case UserMode.expert:
            expect(loginResponse.data?.loginHistory, isNotNull);
            break;
          case UserMode.cultivation:
            expect(loginResponse.data?.streakInfo, isNotNull);
            break;
          case UserMode.guiding:
            // Guiding 模式應該有極簡回應
            expect(loginResponse.data?.loginHistory, isNull);
            expect(loginResponse.data?.streakInfo, isNull);
            break;
          default:
            // Inertial 模式標準回應
            break;
        }
      }
    });
  });
}
```

### 10.3 效能測試 (Dart)
```dart
import 'package:test/test.dart';

void main() {
  group('Auth Service Performance Tests', () {
    late AuthApiClient authApiClient;

    setUpAll(() {
      authApiClient = AuthApiClient(
        baseUrl: 'https://api-staging.lcas.com',
      );
    });

    test('should handle concurrent login requests', () async {
      // 建立多個測試使用者
      final users = <LoginRequest>[];
      
      for (int i = 0; i < 10; i++) {
        final email = 'perf_test_$i@example.com';
        
        // 先註冊使用者
        await authApiClient.register(RegisterRequest(
          email: email,
          password: 'TestPassword123',
          userMode: UserMode.inertial,
          acceptTerms: true,
          acceptPrivacy: true,
        ));

        users.add(LoginRequest(
          email: email,
          password: 'TestPassword123',
        ));
      }

      final startTime = DateTime.now();

      // 同時進行多個登入請求
      final futures = users.map((user) => authApiClient.login(user));
      final responses = await Future.wait(futures);

      final endTime = DateTime.now();
      final totalTime = endTime.difference(startTime).inMilliseconds;

      // 檢查所有請求都成功
      for (final response in responses) {
        expect(response.success, isTrue);
      }

      // 檢查總執行時間（應該小於 10 秒）
      expect(totalTime, lessThan(10000));
      
      print('Concurrent login test completed in ${totalTime}ms');
    });

    test('should maintain performance under load', () async {
      const iterations = 100;
      final durations = <int>[];

      for (int i = 0; i < iterations; i++) {
        final startTime = DateTime.now();
        
        final loginRequest = LoginRequest(
          email: 'load_test@example.com',
          password: 'TestPassword123',
        );

        await authApiClient.login(loginRequest);
        
        final endTime = DateTime.now();
        durations.add(endTime.difference(startTime).inMilliseconds);
      }

      final averageDuration = durations.reduce((a, b) => a + b) / durations.length;
      final maxDuration = durations.reduce((a, b) => a > b ? a : b);

      print('Average login duration: ${averageDuration}ms');
      print('Max login duration: ${maxDuration}ms');

      // 平均回應時間應該小於 2 秒
      expect(averageDuration, lessThan(2000));
      // 最大回應時間應該小於 5 秒
      expect(maxDuration, lessThan(5000));
    });
  });
}
```

---

## 附錄

### A. 資料模型定義 (Dart)
```dart
enum UserMode {
  expert,
  inertial,
  cultivation,
  guiding,
}

enum AccountStatus {
  active,
  inactive,
  locked,
  suspended,
}

enum AuthProvider {
  email,
  google,
  line,
}

enum TokenType {
  access,
  refresh,
}

class UserPreferences {
  final String language;
  final String timezone;
  final String theme;

  UserPreferences({
    required this.language,
    required this.timezone,
    required this.theme,
  });

  factory UserPreferences.defaultSettings() {
    return UserPreferences(
      language: 'zh-TW',
      timezone: 'Asia/Taipei',
      theme: 'auto',
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'language': language,
      'timezone': timezone,
      'theme': theme,
    };
  }

  factory UserPreferences.fromMap(Map<String, dynamic> map) {
    return UserPreferences(
      language: map['language'] ?? 'zh-TW',
      timezone: map['timezone'] ?? 'Asia/Taipei',
      theme: map['theme'] ?? 'auto',
    );
  }
}

class SecuritySettings {
  final int loginFailures;
  final DateTime? lastFailureAt;
  final DateTime? lockedUntil;
  final DateTime? lastLoginAt;
  final int loginCount;

  SecuritySettings({
    required this.loginFailures,
    this.lastFailureAt,
    this.lockedUntil,
    this.lastLoginAt,
    required this.loginCount,
  });

  factory SecuritySettings.defaultSettings() {
    return SecuritySettings(
      loginFailures: 0,
      loginCount: 0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'loginFailures': loginFailures,
      'lastFailureAt': lastFailureAt?.toIso8601String(),
      'lockedUntil': lockedUntil?.toIso8601String(),
      'lastLoginAt': lastLoginAt?.toIso8601String(),
      'loginCount': loginCount,
    };
  }

  factory SecuritySettings.fromMap(Map<String, dynamic> map) {
    return SecuritySettings(
      loginFailures: map['loginFailures'] ?? 0,
      lastFailureAt: map['lastFailureAt'] != null 
          ? DateTime.parse(map['lastFailureAt'])
          : null,
      lockedUntil: map['lockedUntil'] != null 
          ? DateTime.parse(map['lockedUntil'])
          : null,
      lastLoginAt: map['lastLoginAt'] != null 
          ? DateTime.parse(map['lastLoginAt'])
          : null,
      loginCount: map['loginCount'] ?? 0,
    );
  }
}

class DeviceInfo {
  final String? deviceId;
  final String? platform;
  final String? appVersion;
  final String? userAgent;

  DeviceInfo({
    this.deviceId,
    this.platform,
    this.appVersion,
    this.userAgent,
  });

  Map<String, dynamic> toMap() {
    return {
      'deviceId': deviceId,
      'platform': platform,
      'appVersion': appVersion,
      'userAgent': userAgent,
    };
  }

  factory DeviceInfo.fromMap(Map<String, dynamic> map) {
    return DeviceInfo(
      deviceId: map['deviceId'],
      platform: map['platform'],
      appVersion: map['appVersion'],
      userAgent: map['userAgent'],
    );
  }

  Map<String, dynamic> toJson() => toMap();
}

class TokenPair {
  final String accessToken;
  final String refreshToken;
  final DateTime expiresAt;

  TokenPair({
    required this.accessToken,
    required this.refreshToken,
    required this.expiresAt,
  });
}

class TokenPayload {
  final String userId;
  final String? email;
  final UserMode? userMode;
  final String type;
  final int issuedAt;
  final int expiresAt;

  TokenPayload({
    required this.userId,
    this.email,
    this.userMode,
    required this.type,
    required this.issuedAt,
    required this.expiresAt,
  });

  factory TokenPayload.fromJson(Map<String, dynamic> json) {
    return TokenPayload(
      userId: json['userId'],
      email: json['email'],
      userMode: json['userMode'] != null 
          ? UserMode.values.firstWhere(
              (mode) => mode.toString().split('.').last == json['userMode'],
            )
          : null,
      type: json['type'],
      issuedAt: json['iat'],
      expiresAt: json['exp'],
    );
  }
}
```

### B. 配置管理 (Dart)
```dart
class AuthConfig {
  static const String apiBaseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.lcas.com',
  );
  
  static const Duration connectTimeout = Duration(seconds: 30);
  static const Duration receiveTimeout = Duration(seconds: 30);
  static const Duration tokenRefreshThreshold = Duration(minutes: 5);
  
  static const int maxRetryAttempts = 3;
  static const Duration retryDelay = Duration(seconds: 1);
  
  static const bool enableLogging = bool.fromEnvironment(
    'ENABLE_LOGGING',
    defaultValue: true,
  );
  
  static const String logLevel = String.fromEnvironment(
    'LOG_LEVEL',
    defaultValue: 'INFO',
  );
}
```

---

**文件完成日期**: 2025-01-27  
**版本**: 1.0.0  
**維護者**: LCAS 開發團隊
