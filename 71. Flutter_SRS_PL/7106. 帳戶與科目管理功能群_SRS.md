# 7106. 帳戶與科目管理功能群_SRS.md

**文件編號**: 7106  
**版本**: v1.0.0  
**建立日期**: 2025-11-17  
**建立者**: LCAS PM Team  
**最後更新**: 2025-11-17  

---

## 📑 目次 (Table of Contents)

1. [模組概述 (Module Overview)](#10-模組概述module-overview)

2. [功能需求 (Functional Requirements)](#20-功能需求functional-requirements)
   - 2.1 帳戶資料管理邏輯
   - 2.2 科目階層管理邏輯
   - 2.3 帳戶餘額計算邏輯
   - 2.4 科目使用統計邏輯
   - 2.5 四模式差異化業務邏輯處理
   - 2.6 本地資料快取與同步邏輯

3. [輸入/輸出規格 (Input & Output Specifications)](#30-輸入輸出規格input--output-specifications)
   - 3.1 APL Gateway輸入規格
   - 3.2 APL Gateway輸出規格
   - 3.3 WCM.js模組介面規格
   - 3.4 四模式差異化處理規格
   - 3.5 本地快取與同步規格

4. [錯誤處理與例外狀況 (Error Handling & Edge Cases)](#40-錯誤處理與例外狀況error-handling--edge-cases)
   - 4.1 統一錯誤處理架構
   - 4.2 帳戶管理相關錯誤
   - 4.3 科目管理相關錯誤
   - 4.4 網路連線錯誤
   - 4.5 業務邏輯層特殊處理

---

## 1.0 模組概述（Module Overview）

### 1.1 模組定位與職責

**帳戶與科目管理功能群**是LCAS 2.0專案Presentation Layer的關鍵業務邏輯模組群，負責處理帳戶與科目管理的完整業務邏輯流程。本功能群對應0090 Sprint計畫的**Phase 3**範圍，專注於PL層的**功能群業務邏輯**，而非UI頁面群。

**核心職責範圍**：
- 🏦 **帳戶管理邏輯**：API調用、資料驗證、狀態管理
- 📂 **科目管理邏輯**：階層結構處理、樹狀同步
- 💰 **餘額計算邏輯**：即時計算、快取更新
- 📊 **使用統計邏輯**：頻率分析、智慧推薦
- 🎯 **四模式適配**：差異化業務邏輯處理
- 💾 **資料同步**：本地快取與API同步機制

### 1.2 功能群範圍定義

本功能群專注於**業務邏輯層**，不涉及UI頁面群，對應7302記帳核心功能群的架構模式：

| 職責層級 | 功能範圍 | 對應模組 | 備註 |
|----------|----------|----------|------|
| **業務邏輯處理** | API調用、狀態管理、資料轉換 | 7106 | 本模組核心 |
| **API服務對接** | 8105帳戶管理、8106科目管理服務 | APL層 | 介面依賴 |
| **BL層整合** | 1350. WCM.js模組 | BL層 | 後端服務 |
| **UI頁面群** | S-304、S-305、S-306頁面 | 頁面群模組 | 非本模組範圍 |

### 1.3 四模式差異化策略

基於0015文件的四模式理論，本功能群實現以下**業務邏輯層**差異化策略：

#### 1.3.1 Expert模式（專家模式）業務邏輯
- **資料處理**：完整API參數、詳細驗證邏輯、進階篩選條件
- **快取策略**：全量資料快取、複雜查詢緩存、即時同步
- **狀態管理**：多維度狀態追蹤、操作歷史記錄

#### 1.3.2 Inertial模式（慣性模式）業務邏輯  
- **資料處理**：標準化API調用、基本驗證邏輯、固定篩選
- **快取策略**：標準快取機制、定期同步
- **狀態管理**：穩定狀態維護、一致性優先

#### 1.3.3 Cultivation模式（養成模式）業務邏輯
- **資料處理**：引導式資料準備、智慧推薦邏輯、行為分析
- **快取策略**：習慣資料優先、使用頻率分析
- **狀態管理**：成長追蹤狀態、進度計算

#### 1.3.4 Guiding模式（引導模式）業務邏輯
- **資料處理**：極簡資料處理、自動預設值、最少選項
- **快取策略**：預設資料快取、簡化同步
- **狀態管理**：簡化狀態結構、自動化處理

### 1.4 技術架構整合

#### 1.4.1 與APL.dart Gateway及WCM.js模組整合關係

本功能群作為PL層業務邏輯，透過APL.dart統一Gateway與BL層1350. WCM.js模組建立清晰的整合架構：

```
7106功能群 (PL業務邏輯層)
    ↓ 統一API調用
APL.dart Gateway (統一API轉發窗口)
    ↓ RESTful轉發
ASL.js (API服務層)
    ↓ 業務邏輯調用
1350. WCM.js (BL層模組)
    ↓ 資料存取
Firebase (DL層)
```

**核心整合點**：
- **帳戶管理**：7106 → APL.account → ASL.js → WCM_createWallet、WCM_getWalletList等函數
- **科目管理**：7106 → APL.category（P3） → ASL.js → WCM_createCategory、WCM_getCategoryList等函數
- **餘額查詢**：7106 → APL.account → ASL.js → WCM_getWalletBalance函數
- **資料驗證**：7106 → APL統一Gateway → ASL.js → WCM_validateWalletExists、WCM_validateCategoryExists函數

**架構優勢**：
- **統一管理**：透過APL.dart單一窗口管理所有API請求
- **標準化**：遵循RESTful API標準，提供一致的介面規範
- **可擴展性**：APL Gateway為P3-P7階段預留擴展基礎

#### 1.4.2 API服務對應規範

基於8020文件API規格與APL.dart統一Gateway架構，本功能群**嚴格對應**以下API服務：

| 業務邏輯功能 | APL.dart Gateway服務 | API端點路徑 | WCM.js函數 |
|-------------|---------------------|------------|------------|
| 帳戶資料管理 | APL.account服務 | `/api/v1/accounts` | WCM_createWallet, WCM_getWalletList |
| 科目階層管理 | APL.category服務（P3預留） | `/api/v1/categories` | WCM_createCategory, WCM_getCategoryList |
| 帳戶餘額計算 | APL.account服務 | `/api/v1/accounts/{id}/balance` | WCM_getWalletBalance |
| 帳戶驗證邏輯 | APL.account服務 | `/api/v1/accounts/{id}` | WCM_validateWalletExists |
| 科目驗證邏輯 | APL.category服務（P3預留） | `/api/v1/categories/{id}` | WCM_validateCategoryExists |

**APL Gateway整合說明**：
- **統一入口**：所有API請求透過APL.dart統一Gateway處理
- **服務分組**：APL.account、APL.category等服務類別封裝相關API
- **標準化路徑**：遵循`/api/v1/*`標準RESTful路徑規範
- **P3階段預留**：科目管理服務將在Phase 3階段完整實現

#### 1.4.3 狀態管理架構

```dart
// 帳戶與科目管理狀態結構
AccountCategoryStateManager/
├── AccountState           // 帳戶資料狀態
│   ├── accountList        // 帳戶列表
│   ├── selectedAccount    // 選中帳戶
│   ├── accountBalance     // 餘額快取
│   └── loadingState       // 載入狀態
├── CategoryState          // 科目資料狀態
│   ├── categoryTree       // 科目樹狀結構
│   ├── selectedCategory   // 選中科目
│   ├── frequentCategories // 常用科目快取
│   └── syncState          // 同步狀態
├── CacheState            // 快取管理狀態
│   ├── cacheTimestamp     // 快取時間戳
│   ├── syncStatus         // 同步狀態
│   └── offlineData        // 離線資料
└── ModeState             // 四模式狀態
    ├── currentMode        // 當前模式
    ├── modeConfig         // 模式配置
    └── adaptiveData       // 適配資料
```

### 1.5 品質與安全要求

#### 1.5.1 業務邏輯效能要求
- **API響應處理**：≤ 500ms（API調用處理）、≤ 200ms（本地狀態更新）
- **快取機制**：≤ 100ms（快取讀取）、≤ 300ms（快取更新）
- **四模式切換**：≤ 200ms（模式適配邏輯）

#### 1.5.2 資料一致性要求  
- **狀態同步**：API回應與本地狀態即時同步
- **快取一致性**：定期校驗本地快取與遠端資料一致性
- **模式適配**：確保四模式間資料結構一致

#### 1.5.3 錯誤處理機制
- **API異常處理**：網路中斷、服務異常的優雅降級
- **資料驗證**：前端業務邏輯驗證，防止無效資料傳送
- **重試機制**：失敗操作的自動重試與手動重試選項

### 1.6 與其他功能群的協作

#### 1.6.1 功能群介面依賴
- **← 系統進入功能群**：接收認證狀態、用戶模式配置
- **→ 記帳核心功能群**：提供帳戶與科目選擇邏輯、驗證服務
- **→ 帳本協作功能群**：帳本權限驗證、協作狀態管理
- **→ 預算管理功能群**：帳戶科目關聯、預算執行邏輯

#### 1.6.2 業務邏輯資料流
```
API請求準備 → 四模式適配 → API調用 → 回應處理 → 狀態更新 → 快取同步
    ↓                                                              ↑
錯誤處理 ←  資料驗證  ←  業務邏輯處理  ←  模式差異化  ←  本地快取
```

---

## 2.0 功能需求（Functional Requirements）

### 2.1 帳戶資料管理邏輯

#### 2.1.1 帳戶資料創建邏輯
**業務邏輯職責**：處理帳戶創建的完整業務流程，包含API調用、資料驗證與狀態管理。

**核心處理流程**：
```
用戶輸入 → 前端驗證 → 格式化處理 → APL.account調用 → BL層處理 → 回應解析 → 狀態更新 → UI反饋
```

**具體功能需求**：
- **FR-2.1.1-01**：接收使用者輸入的帳戶基本資訊（名稱、類型、初始餘額、幣別、描述）
- **FR-2.1.1-02**：執行前端業務邏輯驗證：
  - 帳戶名稱：1-50字元，不可重複
  - 帳戶類型：從預定義清單選擇（現金、銀行卡、信用卡、電子錢包）
  - 初始餘額：數值格式驗證，允許負值（信用卡）
  - 幣別：支援多幣別選擇，預設TWD
- **FR-2.1.1-03**：調用APL.account.createAccount()進行後端創建
- **FR-2.1.1-04**：處理創建回應並更新本地狀態：
  - 成功：更新帳戶清單、顯示成功訊息、跳轉至帳戶詳情頁
  - 失敗：顯示錯誤訊息、保留表單資料、提供重試選項

**四模式差異化處理**：
- **Expert模式**：完整表單欄位、進階設定選項、多幣別支援
- **Inertial模式**：標準欄位組合、預設值填充、固定幣別
- **Cultivation模式**：引導式填寫、預設建議、進度提示
- **Guiding模式**：極簡欄位（僅名稱與類型）、自動預設值

#### 2.1.2 帳戶資料更新邏輯
**業務邏輯職責**：處理帳戶資訊修改的業務流程，確保資料一致性與同步。

**核心處理流程**：
```
編輯觸發 → 載入現有資料 → 修改處理 → 變更驗證 → APL調用 → 狀態同步 → 快取更新
```

**具體功能需求**：
- **FR-2.1.2-01**：載入現有帳戶資料並填入編輯表單
- **FR-2.1.2-02**：偵測資料變更並執行差異驗證
- **FR-2.1.2-03**：調用APL.account.updateAccount()執行更新
- **FR-2.1.2-04**：處理更新結果並同步相關狀態：
  - 帳戶清單狀態更新
  - 相關交易記錄的帳戶資訊更新
  - 快取資料同步

#### 2.1.3 帳戶資料驗證邏輯
**業務邏輯職責**：確保帳戶資料的正確性與完整性，防止無效資料進入系統。

**具體功能需求**：
- **FR-2.1.3-01**：即時驗證機制：
  - 帳戶名稱重複性檢查（本地快取 + API驗證）
  - 餘額格式與範圍驗證
  - 必填欄位完整性檢查
- **FR-2.1.3-02**：調用APL.account服務進行後端驗證
- **FR-2.1.3-03**：驗證錯誤處理：
  - 即時顯示驗證錯誤訊息
  - 阻止無效資料提交
  - 提供修正建議

#### 2.1.4 帳戶資料快取邏輯
**業務邏輯職責**：管理帳戶資料的本地快取，提升使用者體驗與離線能力。

**具體功能需求**：
- **FR-2.1.4-01**：快取策略實施：
  - 帳戶清單：載入後快取60分鐘
  - 帳戶詳情：載入後快取30分鐘
  - 餘額資訊：載入後快取10分鐘（高頻更新）
- **FR-2.1.4-02**：快取更新觸發條件：
  - 主動刷新：使用者下拉刷新
  - 自動更新：背景定時同步（15分鐘）
  - 事件更新：帳戶相關操作後立即更新
- **FR-2.1.4-03**：離線支援：
  - 離線模式下顯示快取資料
  - 離線操作佇列機制
  - 網路恢復後自動同步

#### 2.1.5 帳戶資料同步邏輯
**業務邏輯職責**：確保本地資料與遠端資料的一致性。

**具體功能需求**：
- **FR-2.1.5-01**：同步觸發機制：
  - APP前景時自動檢查更新
  - 使用者主動刷新
  - 重要操作後強制同步
- **FR-2.1.5-02**：衝突解決策略：
  - 遠端優先：一般資料更新
  - 本地優先：使用者正在編輯的資料
  - 合併策略：非衝突欄位個別處理
- **FR-2.1.5-03**：同步狀態管理：
  - 同步進度指示器
  - 同步狀態資訊顯示
  - 同步失敗重試機制

### 2.2 科目階層管理邏輯

#### 2.2.1 科目樹狀結構處理邏輯  
**業務邏輯職責**：處理科目的階層關係，維護樹狀結構的完整性與一致性。

**核心處理流程**：
```
科目資料載入 → 階層關係解析 → 樹狀結構建構 → 展開/收合邏輯 → 搜尋/篩選處理
```

**具體功能需求**：
- **FR-2.2.1-01**：樹狀結構建構：
  - 從平面科目資料建立父子關係
  - 支援最多3層階層深度
  - 自動排序：預設科目優先，自訂科目其次，按使用頻率排序
- **FR-2.2.1-02**：樹狀互動邏輯：
  - 展開/收合狀態記憶
  - 父節點選擇時顯示子科目選項
  - 子科目反向導航至父科目
- **FR-2.2.1-03**：搜尋與篩選：
  - 科目名稱模糊搜尋
  - 收支類型篩選
  - 使用頻率篩選
  - 搜尋結果階層路徑顯示

**四模式差異化處理**：
- **Expert模式**：完整樹狀結構、自訂排序、進階篩選
- **Inertial模式**：常用科目平鋪顯示、固定排序
- **Cultivation模式**：智慧推薦優先、使用引導
- **Guiding模式**：基本科目清單、最簡選擇

#### 2.2.2 科目階層同步邏輯
**業務邏輯職責**：確保科目階層資料的同步性，處理階層關係變更。

**具體功能需求**：
- **FR-2.2.2-01**：階層同步策略：
  - 完整樹狀結構重建：初次載入或重大變更
  - 增量更新：單一科目變更
  - 關係修復：發現資料不一致時的自動修復
- **FR-2.2.2-02**：同步衝突處理：
  - 階層迴圈檢測與修復
  - 孤兒科目的重新歸類
  - 重複科目的合併處理
- **FR-2.2.2-03**：同步效能優化：
  - 差異比較演算法
  - 批量更新處理
  - 背景同步機制

#### 2.2.3 科目關係驗證邏輯
**業務邏輯職責**：驗證科目階層關係的邏輯正確性。

**具體功能需求**：
- **FR-2.2.3-01**：階層關係驗證：
  - 父子關係合理性檢查
  - 迴圈引用檢測
  - 深度限制驗證（最多3層）
- **FR-2.2.3-02**：業務邏輯驗證：
  - 收支類型一致性：子科目必須與父科目類型相同
  - 科目名稱唯一性：同層級科目名稱不可重複
  - 預設科目保護：系統預設科目不可刪除或修改階層

#### 2.2.4 科目資料快取邏輯
**業務邏輯職責**：管理科目樹狀結構的快取與更新策略。

**具體功能需求**：
- **FR-2.2.4-01**：分層快取策略：
  - 完整科目樹：快取120分鐘
  - 常用科目清單：快取60分鐘  
  - 使用統計資料：快取30分鐘
- **FR-2.2.4-02**：智慧預載機制：
  - 記帳頁面預載常用科目
  - 背景預載完整科目樹
  - 預測性載入：基於使用習慣預載可能使用的科目

### 2.3 帳戶餘額計算邏輯

#### 2.3.1 即時餘額計算邏輯
**業務邏輯職責**：提供準確的帳戶餘額計算與顯示功能。

**核心處理流程**：
```
餘額查詢觸發 → 快取檢查 → APL調用 → 計算處理 → 格式化顯示 → 快取更新
```

**具體功能需求**：
- **FR-2.3.1-01**：餘額計算模式：
  - 即時計算：調用APL.account.getAccountBalance()取得最新餘額
  - 快速顯示：優先顯示快取餘額，背景更新最新值
  - 差異提示：快取與最新值差異超過閾值時的提示機制
- **FR-2.3.1-02**：多幣別處理：
  - 原幣別顯示：顯示帳戶原始幣別餘額
  - 換算顯示：提供主要幣別（TWD）換算金額
  - 匯率更新：定期更新匯率資料
- **FR-2.3.1-03**：餘額顯示邏輯：
  - 格式化顯示：千分位符號、小數點處理
  - 負值顯示：紅色顯示負餘額，特殊標示
  - 隱私模式：支援餘額隱藏功能

#### 2.3.2 餘額快取更新邏輯
**業務邏輯職責**：管理帳戶餘額的快取策略，平衡準確性與效能。

**具體功能需求**：
- **FR-2.3.2-01**：快取更新觸發：
  - 交易完成後立即更新相關帳戶餘額
  - 定時背景更新（每10分鐘）
  - 使用者主動刷新
- **FR-2.3.2-02**：快取策略：
  - 短期快取：5分鐘內直接使用快取值
  - 中期快取：5-15分鐘顯示快取值但背景更新
  - 長期快取：超過15分鐘強制重新載入
- **FR-2.3.2-03**：更新優先級：
  - 高優先級：當前檢視的帳戶
  - 中優先級：最近使用的帳戶
  - 低優先級：其他所有帳戶

#### 2.3.3 餘額一致性檢查邏輯
**業務邏輯職責**：確保餘額資料的準確性與一致性。

**具體功能需求**：
- **FR-2.3.3-01**：一致性檢查機制：
  - 定期校驗：每日背景檢查餘額一致性
  - 即時檢查：重要操作後的即時校驗
  - 異常偵測：餘額異常變動的自動偵測
- **FR-2.3.3-02**：不一致處理：
  - 自動修復：小額差異的自動調整
  - 警示提醒：大額差異的使用者提醒
  - 手動確認：重大不一致的手動確認機制

### 2.4 科目使用統計邏輯

#### 2.4.1 使用頻率分析邏輯
**業務邏輯職責**：分析使用者的科目使用模式，提供個人化體驗。

**核心處理流程**：
```
交易記錄 → 科目使用追蹤 → 頻率統計計算 → 排序排名 → 推薦邏輯 → 顯示優化
```

**具體功能需求**：
- **FR-2.4.1-01**：統計資料收集：
  - 記錄每次科目選擇行為
  - 追蹤科目使用的時間分布
  - 統計科目與金額的關聯性
- **FR-2.4.1-02**：頻率計算演算法：
  - 時間加權：近期使用給予更高權重
  - 頻次統計：計算絕對使用次數
  - 金額權重：高金額交易給予額外權重
- **FR-2.4.1-03**：統計週期管理：
  - 短期統計：最近7天的使用模式
  - 中期統計：最近30天的使用模式
  - 長期統計：最近180天的使用模式

#### 2.4.2 智慧推薦邏輯
**業務邏輯職責**：基於使用統計提供智慧科目推薦功能。

**具體功能需求**：
- **FR-2.4.2-01**：推薦演算法：
  - 時間模式：基於記帳時間推薦常用科目
  - 金額模式：基於交易金額推薦相似科目
  - 組合模式：基於科目組合使用模式推薦
- **FR-2.4.2-02**：推薦顯示邏輯：
  - 快速選擇：在科目選擇頁面頂部顯示推薦科目
  - 智慧預填：基於金額或描述自動推薦科目
  - 學習適應：根據使用者接受度調整推薦策略
- **FR-2.4.2-03**：四模式差異化推薦：
  - **Expert模式**：複雜推薦演算法、多維度分析
  - **Inertial模式**：固定推薦清單、穩定排序
  - **Cultivation模式**：引導式推薦、習慣養成建議
  - **Guiding模式**：單一最佳推薦、極簡選擇

#### 2.4.3 統計資料快取邏輯
**業務邏輯職責**：管理統計資料的快取與更新策略。

**具體功能需求**：
- **FR-2.4.3-01**：統計快取策略：
  - 頻率統計：快取30分鐘，背景更新
  - 推薦結果：快取60分鐘，交易後更新
  - 使用模式：快取24小時，定時更新
- **FR-2.4.3-02**：增量更新機制：
  - 新交易記錄時增量更新統計
  - 避免全量重算，提升效能
  - 批量處理多筆交易的統計更新

### 2.5 四模式差異化業務邏輯處理

#### 2.5.1 Expert模式業務邏輯
**目標使用者**：需要完整功能控制的進階使用者
**業務邏輯特色**：完整功能、深度設定、專業分析

**具體業務邏輯需求**：
- **FR-2.5.1-01**：完整資料處理：
  - 帳戶管理：支援所有帳戶類型、多幣別、詳細設定
  - 科目管理：完整階層結構、自訂分類、進階篩選
  - 統計分析：詳細使用統計、趨勢分析、個人化洞察
- **FR-2.5.1-02**：進階功能啟用：
  - 批量操作：批量建立、編輯、刪除功能
  - 匯入匯出：支援資料匯入匯出功能
  - 自訂規則：自訂分類規則、自動化邏輯
- **FR-2.5.1-03**：效能最佳化：
  - 預載機制：預載所有相關資料
  - 並行處理：支援多工處理複雜操作
  - 快取策略：長時間快取以支援快速存取

#### 2.5.2 Inertial模式業務邏輯
**目標使用者**：習慣固定流程的穩定使用者
**業務邏輯特色**：固定流程、一致體驗、穩定介面

**具體業務邏輯需求**：
- **FR-2.5.2-01**：標準化處理流程：
  - 固定操作流程：標準化的操作步驟，避免變化
  - 預設值優先：大量使用預設值，減少選擇
  - 一致性保證：介面與流程保持高度一致性
- **FR-2.5.2-02**：穩定功能集合：
  - 核心功能：僅提供核心帳戶與科目管理功能
  - 簡化選項：減少設定選項，提供標準配置
  - 經典介面：使用傳統、穩定的介面設計
- **FR-2.5.2-03**：可預測行為：
  - 固定排序：帳戶與科目使用固定排序邏輯
  - 穩定推薦：推薦結果保持穩定，避免頻繁變化
  - 一致回饋：操作回饋保持一致的格式與內容

#### 2.5.3 Cultivation模式業務邏輯
**目標使用者**：需要習慣養成與激勵機制的成長使用者
**業務邏輯特色**：引導學習、進度追蹤、激勵回饋

**具體業務邏輯需求**：
- **FR-2.5.3-01**：引導式學習邏輯：
  - 步驟引導：分步驟引導複雜操作
  - 提示系統：適時提供操作提示與建議
  - 學習追蹤：追蹤使用者學習進度與熟練度
- **FR-2.5.3-02**：習慣養成機制：
  - 目標設定：設定帳戶與科目管理目標
  - 進度追蹤：視覺化顯示目標達成進度
  - 成就系統：完成特定任務獲得成就獎勵
- **FR-2.5.3-03**：智慧建議系統：
  - 個人化建議：基於使用習慣提供改善建議
  - 最佳實務：推薦業界最佳實務做法
  - 週期回顧：定期提供使用情況回顧與建議

#### 2.5.4 Guiding模式業務邏輯
**目標使用者**：需要極簡介面與自動化處理的入門使用者
**業務邏輯特色**：極簡操作、自動處理、被動引導

**具體業務邏輯需求**：
- **FR-2.5.4-01**：極簡操作邏輯：
  - 最少輸入：僅要求必要資訊輸入
  - 自動預設：大量使用智慧預設值
  - 單步操作：避免複雜的多步驟操作流程
- **FR-2.5.4-02**：自動化處理：
  - 智慧分類：自動推薦最佳科目選擇
  - 預設帳戶：自動選擇最常用帳戶
  - 自動完成：自動完成重複性操作
- **FR-2.5.4-03**：被動引導系統：
  - 上下文提示：在適當時機提供必要提示
  - 錯誤預防：預防性檢查避免使用者犯錯
  - 簡化回饋：提供簡潔明確的操作回饋

### 2.6 本地資料快取與同步邏輯

#### 2.6.1 本地快取機制
**業務邏輯職責**：提供高效的本地資料快取策略，確保良好的使用者體驗。

**核心快取架構**：
```
記憶體快取層 (Hot Cache) → 持久化快取層 (Warm Cache) → 遠端資料層 (Cold Data)
```

**具體功能需求**：
- **FR-2.6.1-01**：多層快取策略：
  - **L1記憶體快取**：存放當前頁面資料，APP生命週期內有效
  - **L2本地儲存快取**：存放常用資料，跨APP啟動有效
  - **L3離線快取**：存放關鍵資料，支援離線操作
- **FR-2.6.1-02**：快取資料分級：
  - **熱點資料**：帳戶清單、常用科目（記憶體快取）
  - **溫資料**：完整科目樹、餘額資訊（本地儲存快取）
  - **冷資料**：歷史統計、詳細設定（離線快取）
- **FR-2.6.1-03**：快取生命週期管理：
  - 自動過期：根據資料類型設定不同過期時間
  - 主動清理：記憶體不足時的快取清理機制
  - 手動刷新：使用者觸發的強制更新機制

#### 2.6.2 資料同步策略
**業務邏輯職責**：確保本地資料與遠端資料的一致性與同步性。

**同步觸發機制**：
- **即時同步**：關鍵操作（建立、修改、刪除）後立即同步
- **定時同步**：背景定時檢查與同步（15分鐘間隔）
- **事件同步**：APP啟動、網路恢復、使用者主動刷新觸發

**具體功能需求**：
- **FR-2.6.2-01**：同步策略分類：
  - **強一致性同步**：帳戶餘額、重要設定變更
  - **最終一致性同步**：使用統計、科目排序
  - **衝突解決同步**：併發修改時的衝突處理
- **FR-2.6.2-02**：增量同步機制：
  - 變更追蹤：追蹤本地資料變更記錄
  - 差異比較：比較本地與遠端資料差異
  - 最小化傳輸：僅同步變更的資料欄位
- **FR-2.6.2-03**：同步狀態管理：
  - 同步進度追蹤：顯示同步進度與狀態
  - 失敗重試機制：網路失敗時的自動重試
  - 衝突通知：資料衝突時的使用者通知

#### 2.6.3 衝突解決機制
**業務邏輯職責**：處理本地與遠端資料衝突，確保資料完整性。

**衝突偵測機制**：
- **時間戳比較**：基於最後修改時間判斷資料新舊
- **版本號控制**：使用版本號追蹤資料變更
- **雜湊比較**：比較資料內容雜湊值偵測變更

**具體功能需求**：
- **FR-2.6.3-01**：自動衝突解決：
  - **遠端優先**：系統設定、帳戶基本資訊優先使用遠端版本
  - **本地優先**：使用者正在編輯的資料優先使用本地版本
  - **時間優先**：根據最後修改時間選擇較新版本
- **FR-2.6.3-02**：手動衝突解決：
  - **衝突提醒**：偵測到衝突時提醒使用者選擇
  - **版本比較**：並列顯示衝突版本供使用者比較
  - **合併選項**：提供欄位級別的合併選擇
- **FR-2.6.3-03**：衝突預防機制：
  - **樂觀鎖定**：使用版本控制預防併發衝突
  - **操作序列化**：關鍵操作採用序列化處理
  - **衝突告警**：預警可能發生衝突的操作

---

## 3.0 輸入/輸出規格（Input & Output Specifications）

### 3.1 APL Gateway輸入規格

#### 3.1.1 帳戶管理輸入規格
基於APL.dart Gateway統一介面，本功能群處理以下輸入格式：

**FR-3.1.1-01 帳戶創建輸入規格**
```dart
// PL層接收格式
class AccountCreationInput {
  String name;                    // 帳戶名稱 (1-50字元)
  String type;                   // 帳戶類型 (cash|bank|credit|ewallet)
  double initialBalance;         // 初始餘額 (-999999.99 ~ 999999.99)
  String currency;              // 幣別 (TWD|USD|CNY等)
  String? description;          // 描述 (0-255字元)
  String userId;               // 用戶ID
  String? ledgerId;            // 帳本ID（選填，使用預設帳本）
}

// 業務邏輯驗證規則
ValidationRules accountValidation = {
  'name': {
    'required': true,
    'minLength': 1,
    'maxLength': 50,
    'pattern': r'^[a-zA-Z0-9\u4e00-\u9fff\s]+$'
  },
  'type': {
    'required': true,
    'enum': ['cash', 'bank', 'credit', 'ewallet']
  },
  'initialBalance': {
    'required': true,
    'type': 'double',
    'min': -999999.99,
    'max': 999999.99
  },
  'currency': {
    'required': true,
    'enum': ['TWD', 'USD', 'CNY', 'EUR', 'JPY']
  }
};
```

**FR-3.1.1-02 帳戶查詢輸入規格**
```dart
class AccountQueryInput {
  String userId;               // 用戶ID（必填）
  String? ledgerId;           // 帳本ID篩選
  List<String>? types;        // 帳戶類型篩選
  String? currency;           // 幣別篩選
  bool? activeOnly;           // 僅查詢有效帳戶
  int? limit;                 // 限制筆數 (1-100)
  int? offset;               // 分頁偏移
  String? sortBy;            // 排序欄位
  String? sortOrder;         // 排序方向 (asc|desc)
}
```

#### 3.1.2 科目管理輸入規格

**FR-3.1.2-01 科目創建輸入規格**
```dart
class CategoryCreationInput {
  String name;                 // 科目名稱 (1-30字元)
  String type;                // 科目類型 (income|expense)
  String? parentId;           // 父科目ID（選填）
  String userId;              // 用戶ID
  String? description;        // 描述
  String? color;              // 顏色代碼 (#RRGGBB)
  String? icon;               // 圖示名稱
  int? sortOrder;             // 排序順序
}

// 業務邏輯驗證規則
ValidationRules categoryValidation = {
  'name': {
    'required': true,
    'minLength': 1,
    'maxLength': 30,
    'pattern': r'^[a-zA-Z0-9\u4e00-\u9fff\s]+$'
  },
  'type': {
    'required': true,
    'enum': ['income', 'expense']
  },
  'color': {
    'pattern': r'^#[0-9A-Fa-f]{6}$'
  }
};
```

#### 3.1.3 四模式差異化輸入處理

**Expert模式輸入擴展**
```dart
class ExpertModeInput extends BaseInput {
  Map<String, dynamic>? advancedSettings;
  List<String>? customFields;
  Map<String, String>? metadata;
  bool? enableAdvancedValidation;
}
```

**Guiding模式輸入簡化**
```dart
class GuidingModeInput {
  String name;                 // 僅必要欄位
  String type;
  String userId;
  // 其他欄位自動填入預設值
}
```

### 3.2 APL Gateway輸出規格

#### 3.2.1 標準成功回應格式
基於8088 API設計規範，業務邏輯層統一處理以下輸出格式：

```dart
class StandardResponse<T> {
  bool success;                // 操作成功標識
  T? data;                    // 實際資料內容
  ResponseMetadata metadata;   // 回應元資料
  PaginationInfo? pagination; // 分頁資訊（列表查詢）

  // 四模式差異化內容
  ModeSpecificData? modeData; // 模式特定資料
}

class ResponseMetadata {
  String timestamp;           // 回應時間戳 (ISO 8601)
  String requestId;          // 請求追蹤ID
  String userMode;           // 使用者模式
  double processingTime;     // 處理時間 (毫秒)
}

class ModeSpecificData {
  // Expert模式：詳細分析資料
  Map<String, dynamic>? analytics;
  List<String>? availableActions;

  // Cultivation模式：進度與成就
  ProgressInfo? progress;
  List<Achievement>? achievements;

  // Guiding模式：簡化訊息
  String? simpleMessage;
  List<SimpleAction>? quickActions;
}
```

#### 3.2.2 帳戶管理輸出規格

**FR-3.2.2-01 帳戶創建成功回應**
```dart
class AccountCreationResponse {
  bool success = true;
  AccountData data;
  ResponseMetadata metadata;

  // 四模式差異化內容
  ExpertModeData? expertData;      // Expert: 詳細設定選項
  CultivationModeData? cultData;   // Cultivation: 建議與進度
  String? guidingMessage;          // Guiding: 簡化確認訊息
}

class AccountData {
  String accountId;            // 帳戶ID
  String name;                // 帳戶名稱
  String type;                // 帳戶類型
  double balance;             // 當前餘額
  String currency;            // 幣別
  DateTime createdAt;         // 建立時間
  DateTime updatedAt;         // 更新時間

  // 關聯資料
  LedgerInfo? ledgerInfo;     // 所屬帳本資訊
  List<RecentTransaction>? recentTransactions; // 最近交易（Expert模式）
}
```

**FR-3.2.2-02 帳戶列表查詢回應**
```dart
class AccountListResponse {
  bool success = true;
  AccountListData data;
  PaginationInfo pagination;
  ResponseMetadata metadata;
}

class AccountListData {
  List<AccountSummary> accounts;
  AccountStatistics? statistics;  // Expert模式統計資料
  List<String>? recommendations;   // Cultivation模式推薦
}

class AccountSummary {
  String accountId;
  String name;
  String type;
  double balance;
  String currency;
  bool isDefault;
  DateTime lastUsed;

  // 四模式差異化內容
  Map<String, dynamic>? expertDetails;    // Expert: 完整詳細資訊
  String? cultivationTip;                  // Cultivation: 使用建議
  String? guidingLabel;                    // Guiding: 簡化標籤
}
```

#### 3.2.3 科目管理輸出規格

**FR-3.2.3-01 科目樹狀結構回應**
```dart
class CategoryTreeResponse {
  bool success = true;
  CategoryTreeData data;
  ResponseMetadata metadata;
}

class CategoryTreeData {
  List<CategoryNode> incomeCategories;   // 收入科目樹
  List<CategoryNode> expenseCategories;  // 支出科目樹
  CategoryStatistics? statistics;        // Expert模式統計
  List<CategoryRecommendation>? recommendations; // 推薦科目
}

class CategoryNode {
  String categoryId;
  String name;
  String type;
  int level;                    // 階層深度 (1-3)
  String? parentId;
  List<CategoryNode>? children; // 子科目

  // 使用統計
  int usageCount;              // 使用次數
  DateTime? lastUsed;          // 最後使用時間
  double? totalAmount;         // 總交易金額（Expert模式）

  // 顯示屬性
  String color;                // 顏色代碼
  String icon;                 // 圖示
  int sortOrder;              // 排序順序

  // 四模式差異化
  bool isFrequent;            // 常用科目標記
  String? cultivationTip;     // Cultivation模式提示
}
```

#### 3.2.4 快取與狀態管理輸出

**FR-3.2.4-01 快取狀態資訊**
```dart
class CacheStateInfo {
  Map<String, CacheStatus> cacheStatus;
  DateTime lastSyncTime;
  bool isOnline;
  List<PendingOperation>? pendingOperations;
}

class CacheStatus {
  String resourceType;        // 資源類型 (accounts|categories|etc)
  DateTime cacheTime;         // 快取時間
  DateTime expireTime;        // 過期時間
  bool isValid;              // 是否有效
  int itemCount;             // 快取項目數量
}
```

### 3.3 WCM.js模組介面規格

#### 3.3.1 BL層函數調用介面
基於WCM.js模組提供的函數，業務邏輯層建立以下介面規範：

**FR-3.3.1-01 帳戶管理BL介面**
```dart
// PL層調用APL Gateway，APL Gateway調用WCM.js
class WCMAccountInterface {
  // 對應WCM_createWallet函數
  Future<StandardResponse<AccountData>> createAccount(
    AccountCreationInput input
  ) async {
    // 業務邏輯處理
    final processedInput = _preprocessAccountInput(input);

    // APL Gateway調用
    final aplResponse = await aplGateway.post(
      '/api/v1/accounts',
      body: processedInput
    );

    // 回應處理與四模式適配
    return _processAccountResponse(aplResponse, input.userMode);
  }

  // 對應WCM_getWalletList函數
  Future<StandardResponse<AccountListData>> getAccountList(
    AccountQueryInput input
  );

  // 對應WCM_validateWalletExists函數
  Future<StandardResponse<ValidationResult>> validateAccountExists(
    String accountId, String userId
  );

  // 對應WCM_getWalletBalance函數
  Future<StandardResponse<BalanceData>> getAccountBalance(
    String accountId, String userId
  );
}
```

**FR-3.3.1-02 科目管理BL介面**
```dart
class WCMCategoryInterface {
  // 對應WCM_createCategory函數
  Future<StandardResponse<CategoryData>> createCategory(
    CategoryCreationInput input
  );

  // 對應WCM_getCategoryList函數
  Future<StandardResponse<CategoryTreeData>> getCategoryTree(
    CategoryQueryInput input
  );

  // 對應WCM_validateCategoryExists函數
  Future<StandardResponse<ValidationResult>> validateCategoryExists(
    String categoryId, String userId
  );
}
```

#### 3.3.2 資料格式轉換規範

**FR-3.3.2-01 PL → APL資料轉換**
```dart
class DataTransformer {
  // 帳戶資料轉換
  Map<String, dynamic> transformAccountInput(AccountCreationInput input) {
    return {
      'name': input.name.trim(),
      'type': input.type,
      'balance': input.initialBalance,
      'currency': input.currency,
      'description': input.description?.trim() ?? '',
      'userId': input.userId,
      'ledgerId': input.ledgerId,
      // 業務邏輯擴展欄位
      'source': 'app',
      'version': '1.0.0',
      'userMode': getCurrentUserMode(),
      'timestamp': DateTime.now().toIso8601String()
    };
  }

  // APL → PL資料轉換
  AccountData transformAccountResponse(Map<String, dynamic> response) {
    return AccountData(
      accountId: response['walletId'] ?? response['accountId'],
      name: response['name'],
      type: response['type'],
      balance: response['balance']?.toDouble() ?? 0.0,
      currency: response['currency'] ?? 'TWD',
      createdAt: DateTime.parse(response['createdAt']),
      updatedAt: DateTime.parse(response['updatedAt'])
    );
  }
}
```

### 3.4 四模式差異化處理規格

#### 3.4.1 輸入處理差異化

**FR-3.4.1-01 模式別輸入預處理**
```dart
class ModeInputProcessor {
  AccountCreationInput processExpertMode(AccountCreationInput input) {
    // Expert模式：完整驗證，保留所有欄位
    return input..validate(strictMode: true);
  }

  AccountCreationInput processInertialMode(AccountCreationInput input) {
    // Inertial模式：標準化處理，填入固定預設值
    return input
      ..currency ??= 'TWD'
      ..type = _standardizeAccountType(input.type);
  }

  AccountCreationInput processCultivationMode(AccountCreationInput input) {
    // Cultivation模式：引導式填充，智慧預設值
    return input
      ..description ??= _generateSmartDescription(input)
      ..type = _recommendAccountType(input);
  }

  AccountCreationInput processGuidingMode(AccountCreationInput input) {
    // Guiding模式：極簡處理，大量預設值
    return AccountCreationInput(
      name: input.name,
      type: input.type ?? 'cash',
      initialBalance: input.initialBalance ?? 0.0,
      currency: 'TWD',
      description: '',
      userId: input.userId
    );
  }
}
```

#### 3.4.2 輸出格式差異化

**FR-3.4.2-01 模式別輸出後處理**
```dart
class ModeOutputProcessor {
  AccountCreationResponse processExpertOutput(
    AccountCreationResponse base
  ) {
    return base..expertData = ExpertModeData(
      detailedAnalytics: _generateAccountAnalytics(base.data),
      availableActions: _getAdvancedAccountActions(),
      relatedAccounts: _findRelatedAccounts(base.data),
      budgetImpact: _calculateBudgetImpact(base.data)
    );
  }

  AccountCreationResponse processCultivationOutput(
    AccountCreationResponse base
  ) {
    return base..cultData = CultivationModeData(
      achievement: _checkAchievements(base.data),
      progress: _calculateProgress(base.data),
      nextGoal: _suggestNextGoal(base.data),
      motivationalMessage: _generateMotivation()
    );
  }

  AccountCreationResponse processGuidingOutput(
    AccountCreationResponse base
  ) {
    return base..guidingMessage = _generateSimpleMessage(base.data);
  }
}
```

### 3.5 本地快取與同步規格

#### 3.5.1 快取資料結構

**FR-3.5.1-01 帳戶快取結構**
```dart
class AccountCache {
  Map<String, AccountData> accounts;      // 帳戶資料快取
  Map<String, double> balances;           // 餘額快取
  Map<String, DateTime> lastUpdated;      // 最後更新時間
  Set<String> dirtyIds;                   // 待同步ID集合

  // 快取策略配置
  Duration accountCacheExpiry = Duration(hours: 1);
  Duration balanceCacheExpiry = Duration(minutes: 10);
}

class CategoryCache {
  Map<String, CategoryNode> categories;   // 科目資料快取
  List<CategoryNode> treeStructure;       // 樹狀結構快取
  Map<String, int> usageStats;           // 使用統計快取
  DateTime treeLastBuilt;                 // 樹狀結構建立時間

  // 快取策略配置
  Duration categoryCacheExpiry = Duration(hours: 2);
  Duration usageStatsCacheExpiry = Duration(minutes: 30);
}
```

#### 3.5.2 同步策略規格

**FR-3.5.2-01 同步觸發機制**
```dart
class SyncStrategy {
  // 自動同步觸發條件
  List<SyncTrigger> autoSyncTriggers = [
    SyncTrigger.appForeground,      // APP進入前景
    SyncTrigger.networkReconnect,   // 網路重連
    SyncTrigger.cacheExpired,       // 快取過期
    SyncTrigger.userAction,         // 使用者操作
    SyncTrigger.scheduled           // 定時同步（15分鐘）
  ];

  // 同步優先級
  Map<String, SyncPriority> syncPriority = {
    'account_balance': SyncPriority.high,
    'account_list': SyncPriority.medium,
    'category_tree': SyncPriority.medium,
    'usage_stats': SyncPriority.low
  };
}
```

---

## 4.0 錯誤處理與例外狀況（Error Handling & Edge Cases）

### 4.1 統一錯誤處理架構

#### 4.1.1 錯誤分類體系
基於8088 API設計規範，業務邏輯層建立完整的錯誤處理體系：

```dart
enum ErrorCategory {
  validation,        // 資料驗證錯誤
  business,         // 業務邏輯錯誤
  network,          // 網路連線錯誤
  authentication,   // 認證授權錯誤
  system,          // 系統級錯誤
  cache,           // 快取相關錯誤
  sync             // 同步錯誤
}

enum ErrorSeverity {
  low,             // 可忽略，不影響主要功能
  medium,          // 部分功能受影響，可降級處理
  high,            // 主要功能受影響，需要處理
  critical         // 系統無法正常運作
}
```

#### 4.1.2 標準錯誤格式

**FR-4.1.2-01 統一錯誤回應格式**
```dart
class ErrorResponse {
  bool success = false;
  ErrorData error;
  ResponseMetadata metadata;

  // 四模式差異化錯誤處理
  ModeSpecificError? modeError;
}

class ErrorData {
  String code;                 // 錯誤代碼
  String message;              // 錯誤訊息
  String? field;               // 相關欄位（驗證錯誤）
  ErrorCategory category;      // 錯誤分類
  ErrorSeverity severity;      // 錯誤嚴重程度
  DateTime timestamp;          // 錯誤發生時間
  String requestId;            // 請求追蹤ID
  Map<String, dynamic>? details; // 詳細錯誤資訊

  // 錯誤處理建議
  List<ErrorAction>? suggestedActions;
  String? userFriendlyMessage;
}

class ErrorAction {
  String actionType;           // retry|fallback|navigate|contact
  String label;               // 使用者看到的按鈕文字
  Map<String, dynamic>? parameters; // 動作參數
}
```

#### 4.1.3 四模式差異化錯誤處理

**FR-4.1.3-01 模式別錯誤回應策略**
```dart
class ModeSpecificError {
  // Expert模式：詳細技術資訊
  ExpertErrorData? expertData;
  // Cultivation模式：引導式錯誤處理
  CultivationErrorData? cultivationData;
  // Guiding模式：極簡錯誤訊息
  String? simpleMessage;
}

class ExpertErrorData {
  String? stackTrace;          // 錯誤堆疊（開發模式）
  Map<String, dynamic>? debugInfo; // 除錯資訊
  List<String>? technicalSolutions; // 技術解決方案
  ErrorStatistics? errorStats; // 錯誤統計
}

class CultivationErrorData {
  String? guidanceMessage;     // 引導訊息
  List<LearningTip>? tips;     // 學習提示
  String? preventionAdvice;    // 預防建議
  bool? showTutorial;         // 是否顯示教學
}
```

### 4.2 帳戶管理相關錯誤

#### 4.2.1 帳戶驗證錯誤

**FR-4.2.1-01 帳戶名稱驗證錯誤**
```dart
class AccountValidationErrors {
  static const String ACCOUNT_NAME_REQUIRED = 'ACCOUNT_NAME_REQUIRED';
  static const String ACCOUNT_NAME_TOO_SHORT = 'ACCOUNT_NAME_TOO_SHORT';
  static const String ACCOUNT_NAME_TOO_LONG = 'ACCOUNT_NAME_TOO_LONG';
  static const String ACCOUNT_NAME_INVALID_CHARS = 'ACCOUNT_NAME_INVALID_CHARS';
  static const String ACCOUNT_NAME_DUPLICATE = 'ACCOUNT_NAME_DUPLICATE';

  // 錯誤處理邏輯
  static ErrorResponse handleNameValidation(
    String? name, 
    String userMode, 
    List<String>? existingNames
  ) {
    if (name == null || name.trim().isEmpty) {
      return _createValidationError(
        ACCOUNT_NAME_REQUIRED,
        _getLocalizedMessage('帳戶名稱不能為空', userMode),
        'name',
        _getSuggestedActions(userMode, 'name_required')
      );
    }

    if (name.trim().length > 50) {
      return _createValidationError(
        ACCOUNT_NAME_TOO_LONG,
        _getLocalizedMessage('帳戶名稱不能超過50字元', userMode),
        'name',
        _getSuggestedActions(userMode, 'name_too_long')
      );
    }

    if (existingNames?.contains(name.trim()) == true) {
      return _createValidationError(
        ACCOUNT_NAME_DUPLICATE,
        _getLocalizedMessage('帳戶名稱已存在', userMode),
        'name',
        _getSuggestedActions(userMode, 'name_duplicate')
      );
    }

    return ErrorResponse.noError();
  }
}
```

**FR-4.2.1-02 帳戶餘額驗證錯誤**
```dart
class BalanceValidationErrors {
  static const String BALANCE_INVALID_FORMAT = 'BALANCE_INVALID_FORMAT';
  static const String BALANCE_OUT_OF_RANGE = 'BALANCE_OUT_OF_RANGE';
  static const String BALANCE_NEGATIVE_NOT_ALLOWED = 'BALANCE_NEGATIVE_NOT_ALLOWED';

  static ErrorResponse validateBalance(
    dynamic balance, 
    String accountType,
    String userMode
  ) {
    if (balance == null) {
      return _createValidationError(
        'BALANCE_REQUIRED',
        _getModeMessage(userMode, {
          'Expert': '請輸入帳戶初始餘額',
          'Inertial': '餘額為必填項目',
          'Cultivation': '設定初始餘額有助於預算規劃',
          'Guiding': '請填入餘額'
        }),
        'initialBalance'
      );
    }

    double? numBalance = _parseBalance(balance);
    if (numBalance == null) {
      return _createValidationError(
        BALANCE_INVALID_FORMAT,
        _getModeMessage(userMode, {
          'Expert': '餘額格式無效，請輸入有效數字',
          'Guiding': '請輸入正確的金額'
        }),
        'initialBalance'
      );
    }

    // 信用卡帳戶允許負值
    if (accountType != 'credit' && numBalance < 0) {
      return _createValidationError(
        BALANCE_NEGATIVE_NOT_ALLOWED,
        _getModeMessage(userMode, {
          'Expert': '此帳戶類型不允許負餘額',
          'Guiding': '餘額不能是負數'
        }),
        'initialBalance'
      );
    }

    return ErrorResponse.noError();
  }
}
```

#### 4.2.2 帳戶業務邏輯錯誤

**FR-4.2.2-01 帳戶存取權限錯誤**
```dart
class AccountAccessErrors {
  static const String ACCOUNT_NOT_FOUND = 'ACCOUNT_NOT_FOUND';
  static const String ACCOUNT_ACCESS_DENIED = 'ACCOUNT_ACCESS_DENIED';
  static const String ACCOUNT_INACTIVE = 'ACCOUNT_INACTIVE';
  static const String ACCOUNT_LEDGER_MISMATCH = 'ACCOUNT_LEDGER_MISMATCH';

  static ErrorResponse handleAccountAccess(
    String? accountId,
    String userId,
    String? ledgerId,
    String userMode
  ) {
    final account = _findAccount(accountId);

    if (account == null) {
      return ErrorResponse(
        success: false,
        error: ErrorData(
          code: ACCOUNT_NOT_FOUND,
          message: _getModeMessage(userMode, {
            'Expert': '指定的帳戶不存在 (ID: $accountId)',
            'Inertial': '找不到該帳戶',
            'Cultivation': '該帳戶可能已被刪除，請檢查帳戶清單',
            'Guiding': '帳戶不存在'
          }),
          category: ErrorCategory.business,
          severity: ErrorSeverity.medium,
          suggestedActions: _getAccessErrorActions(userMode)
        )
      );
    }

    if (account.userId != userId) {
      return ErrorResponse(
        success: false,
        error: ErrorData(
          code: ACCOUNT_ACCESS_DENIED,
          message: _getModeMessage(userMode, {
            'Expert': '無權限存取此帳戶',
            'Guiding': '無法存取該帳戶'
          }),
          category: ErrorCategory.authentication,
          severity: ErrorSeverity.high,
          suggestedActions: [
            ErrorAction(
              actionType: 'navigate',
              label: '返回帳戶列表',
              parameters: {'route': '/accounts'}
            )
          ]
        )
      );
    }

    return ErrorResponse.noError();
  }
}
```

### 4.3 科目管理相關錯誤

#### 4.3.1 科目階層錯誤

**FR-4.3.1-01 科目階層邏輯錯誤**
```dart
class CategoryHierarchyErrors {
  static const String CATEGORY_CIRCULAR_REFERENCE = 'CATEGORY_CIRCULAR_REFERENCE';
  static const String CATEGORY_MAX_DEPTH_EXCEEDED = 'CATEGORY_MAX_DEPTH_EXCEEDED';
  static const String CATEGORY_TYPE_MISMATCH = 'CATEGORY_TYPE_MISMATCH';
  static const String CATEGORY_PARENT_NOT_FOUND = 'CATEGORY_PARENT_NOT_FOUND';

  static ErrorResponse validateHierarchy(
    String? parentId,
    String categoryType,
    String userId,
    String userMode
  ) {
    if (parentId != null) {
      final parent = _findCategory(parentId, userId);

      if (parent == null) {
        return _createBusinessError(
          CATEGORY_PARENT_NOT_FOUND,
          _getModeMessage(userMode, {
            'Expert': '指定的父科目不存在',
            'Cultivation': '所選的上層科目已不存在，請重新選擇',
            'Guiding': '請重新選擇科目分類'
          }),
          [
            ErrorAction(
              actionType: 'retry',
              label: '重新選擇',
              parameters: {'action': 'select_parent'}
            )
          ]
        );
      }

      // 檢查收支類型一致性
      if (parent.type != categoryType) {
        return _createBusinessError(
          CATEGORY_TYPE_MISMATCH,
          _getModeMessage(userMode, {
            'Expert': '子科目類型必須與父科目一致',
            'Cultivation': '收入和支出科目不能混合，請重新選擇',
            'Guiding': '類型不符，請重新選擇'
          }),
          _getTypeErrorActions(userMode)
        );
      }

      // 檢查階層深度（最多3層）
      if (_calculateDepth(parent) >= 3) {
        return _createBusinessError(
          CATEGORY_MAX_DEPTH_EXCEEDED,
          _getModeMessage(userMode, {
            'Expert': '科目階層深度不能超過3層',
            'Cultivation': '為了清晰管理，科目最多只能有3層',
            'Guiding': '層級太深，請選擇上層科目'
          }),
          _getDepthErrorActions(userMode)
        );
      }
    }

    return ErrorResponse.noError();
  }
}
```

#### 4.3.2 科目使用統計錯誤

**FR-4.3.2-01 統計資料錯誤處理**
```dart
class CategoryStatisticsErrors {
  static ErrorResponse handleStatisticsError(
    Exception exception,
    String userMode,
    {bool isBackground = false}
  ) {
    if (isBackground && userMode == 'Guiding') {
      // Guiding模式背景統計錯誤不影響主要功能
      return ErrorResponse.silent();
    }

    return ErrorResponse(
      success: false,
      error: ErrorData(
        code: 'STATISTICS_CALCULATION_ERROR',
        message: _getModeMessage(userMode, {
          'Expert': '統計資料計算失敗：${exception.toString()}',
          'Inertial': '統計資料暫時無法取得',
          'Cultivation': '正在重新計算使用統計，請稍候',
          'Guiding': '載入中，請稍候'
        }),
        category: ErrorCategory.system,
        severity: isBackground ? ErrorSeverity.low : ErrorSeverity.medium,
        suggestedActions: _getStatisticsErrorActions(userMode, isBackground)
      )
    );
  }
}
```

### 4.4 網路連線錯誤

#### 4.4.1 網路狀態檢測

**FR-4.4.1-01 連線狀態處理**
```dart
class NetworkErrorHandler {
  static const String NETWORK_UNAVAILABLE = 'NETWORK_UNAVAILABLE';
  static const String REQUEST_TIMEOUT = 'REQUEST_TIMEOUT';
  static const String SERVER_UNAVAILABLE = 'SERVER_UNAVAILABLE';
  static const String API_RATE_LIMIT = 'API_RATE_LIMIT';

  static ErrorResponse handleNetworkError(
    NetworkException exception,
    String userMode,
    {bool hasCache = false}
  ) {
    switch (exception.type) {
      case NetworkExceptionType.noConnection:
        return _handleOfflineMode(userMode, hasCache);

      case NetworkExceptionType.timeout:
        return _handleTimeout(userMode);

      case NetworkExceptionType.serverError:
        return _handleServerError(exception, userMode);

      case NetworkExceptionType.rateLimited:
        return _handleRateLimit(userMode);

      default:
        return _handleGenericNetworkError(exception, userMode);
    }
  }

  static ErrorResponse _handleOfflineMode(String userMode, bool hasCache) {
    if (hasCache) {
      return ErrorResponse.warning(
        code: 'OFFLINE_MODE_CACHED',
        message: _getModeMessage(userMode, {
          'Expert': '離線模式：顯示快取資料，部分功能受限',
          'Inertial': '網路斷線，顯示已儲存的資料',
          'Cultivation': '目前離線中，顯示最後同步的資料',
          'Guiding': '離線中，顯示之前的資料'
        }),
        actions: [
          ErrorAction(
            actionType: 'retry',
            label: '重新連線',
            parameters: {'auto_retry': true}
          )
        ]
      );
    }

    return ErrorResponse(
      success: false,
      error: ErrorData(
        code: NETWORK_UNAVAILABLE,
        message: _getModeMessage(userMode, {
          'Expert': '網路連線失敗，無可用快取資料',
          'Inertial': '網路連線有問題',
          'Cultivation': '請檢查網路連線，確保能正常使用功能',
          'Guiding': '無法連線，請檢查網路'
        }),
        category: ErrorCategory.network,
        severity: ErrorSeverity.high,
        suggestedActions: _getNetworkErrorActions(userMode)
      )
    );
  }
}
```

#### 4.4.2 重試機制

**FR-4.4.2-01 智慧重試策略**
```dart
class RetryStrategy {
  static const int MAX_RETRY_ATTEMPTS = 3;
  static const Duration INITIAL_BACKOFF = Duration(seconds: 1);
  static const Duration MAX_BACKOFF = Duration(seconds: 30);

  static Future<T> executeWithRetry<T>(
    Future<T> Function() operation,
    {
      int maxAttempts = MAX_RETRY_ATTEMPTS,
      Duration initialDelay = INITIAL_BACKOFF,
      String userMode = 'Expert'
    }
  ) async {
    int attempts = 0;
    Duration delay = initialDelay;

    while (attempts < maxAttempts) {
      try {
        return await operation();
      } catch (exception) {
        attempts++;

        if (attempts >= maxAttempts) {
          throw RetryExhaustedException(
            originalException: exception,
            attempts: attempts,
            userMode: userMode
          );
        }

        // 四模式差異化重試延遲
        final actualDelay = _getModeRetryDelay(delay, userMode);
        await Future.delayed(actualDelay);

        delay = Duration(
          milliseconds: (delay.inMilliseconds * 1.5).round()
        );
        if (delay > MAX_BACKOFF) delay = MAX_BACKOFF;
      }
    }

    throw StateError('Unexpected retry loop exit');
  }

  static Duration _getModeRetryDelay(Duration baseDelay, String mode) {
    switch (mode) {
      case 'Expert':
        return baseDelay; // 標準重試間隔
      case 'Inertial':
        return baseDelay * 1.2; // 稍長間隔，避免頻繁重試
      case 'Cultivation':
        return baseDelay * 0.8; // 稍短間隔，快速回饋
      case 'Guiding':
        return baseDelay * 1.5; // 較長間隔，減少干擾
      default:
        return baseDelay;
    }
  }
}
```

### 4.5 業務邏輯層特殊處理

#### 4.5.1 快取同步錯誤

**FR-4.5.1-01 快取一致性錯誤**
```dart
class CacheSyncErrors {
  static const String CACHE_CORRUPTED = 'CACHE_CORRUPTED';
  static const String SYNC_CONFLICT = 'SYNC_CONFLICT';
  static const String CACHE_FULL = 'CACHE_FULL';

  static ErrorResponse handleCacheError(
    CacheException exception,
    String userMode
  ) {
    switch (exception.type) {
      case CacheExceptionType.corrupted:
        return _handleCorruptedCache(userMode);

      case CacheExceptionType.syncConflict:
        return _handleSyncConflict(exception, userMode);

      case CacheExceptionType.storageFull:
        return _handleStorageFull(userMode);

      default:
        return _handleGenericCacheError(exception, userMode);
    }
  }

  static ErrorResponse _handleSyncConflict(
    CacheException exception,
    String userMode
  ) {
    return ErrorResponse(
      success: false,
      error: ErrorData(
        code: SYNC_CONFLICT,
        message: _getModeMessage(userMode, {
          'Expert': '資料同步衝突：本地與遠端資料不一致',
          'Inertial': '資料同步有問題',
          'Cultivation': '發現資料差異，正在為您處理',
          'Guiding': '正在同步資料'
        }),
        category: ErrorCategory.sync,
        severity: ErrorSeverity.medium,
        details: {
          'conflictType': exception.details?['conflictType'],
          'affectedItems': exception.details?['affectedItems']
        },
        suggestedActions: _getSyncConflictActions(userMode, exception)
      )
    );
  }
}
```

#### 4.5.2 四模式錯誤恢復策略

**FR-4.5.2-01 模式特定恢復機制**
```dart
class ModeSpecificRecovery {
  static ErrorResponse processErrorForMode(
    ErrorResponse baseError,
    String userMode
  ) {
    switch (userMode) {
      case 'Expert':
        return _expertModeRecovery(baseError);
      case 'Inertial':
        return _inertialModeRecovery(baseError);
      case 'Cultivation':
        return _cultivationModeRecovery(baseError);
      case 'Guiding':
        return _guidingModeRecovery(baseError);
      default:
        return baseError;
    }
  }

  static ErrorResponse _expertModeRecovery(ErrorResponse error) {
    // Expert模式：提供詳細資訊與多種解決方案
    return error.copyWith(
      modeError: ModeSpecificError(
        expertData: ExpertErrorData(
          technicalSolutions: [
            '檢查網路連線狀態',
            '清除應用程式快取',
            '重新登入以更新認證',
            '聯繫技術支援'
          ],
          debugInfo: {
            'errorContext': _getErrorContext(),
            'systemInfo': _getSystemInfo()
          }
        )
      )
    );
  }

  static ErrorResponse _cultivationModeRecovery(ErrorResponse error) {
    // Cultivation模式：轉化錯誤為學習機會
    return error.copyWith(
      modeError: ModeSpecificError(
        cultivationData: CultivationErrorData(
          guidanceMessage: '這是學習如何處理問題的好機會！',
          tips: [
            LearningTip(
              title: '錯誤處理小技巧',
              content: '遇到問題時，先檢查網路連線是常見的解決方法'
            )
          ],
          preventionAdvice: '建議定期檢查APP更新，可預防類似問題',
          showTutorial: _shouldShowTutorial(error)
        )
      )
    );
  }

  static ErrorResponse _guidingModeRecovery(ErrorResponse error) {
    // Guiding模式：極簡錯誤處理，自動恢復
    if (_canAutoRecover(error)) {
      _initiateAutoRecovery(error);
      return ErrorResponse.recoveryInProgress('正在自動修復...');
    }

    return error.copyWith(
      modeError: ModeSpecificError(
        simpleMessage: _simplifyErrorMessage(error.error.message)
      )
    );
  }
}
</new_str>
</changes>