
# SRS_AuthService_èªè­‰æœå‹™_v1.0.0

**æ–‡ä»¶ç·¨è™Ÿ**: 8901  
**ç‰ˆæœ¬**: 1.0.0  
**å»ºç«‹æ—¥æœŸ**: 2025-01-26  
**å»ºç«‹è€…**: LCAS SA Team  
**æœ€å¾Œæ›´æ–°**: 2025-01-26 14:00:00 UTC+8

---

## ç›®æ¬¡

1. [æ¨¡çµ„æ¦‚è¿°](#10-æ¨¡çµ„æ¦‚è¿°module-overview)
2. [èªè­‰æœå‹™ç°¡ä»‹](#20-èªè­‰æœå‹™ç°¡ä»‹authentication-service-introduction)
3. [åŠŸèƒ½éœ€æ±‚](#30-åŠŸèƒ½éœ€æ±‚functional-requirements)
4. [æŠ€è¡“æ¶æ§‹](#40-æŠ€è¡“æ¶æ§‹technical-architecture)
5. [APIç«¯é»è¦æ ¼](#50-apiç«¯é»è¦æ ¼api-endpoints-specification)
6. [å®‰å…¨æ€§è¦æ±‚](#60-å®‰å…¨æ€§è¦æ±‚security-requirements)
7. [éŒ¯èª¤è™•ç†ç­–ç•¥](#70-éŒ¯èª¤è™•ç†ç­–ç•¥error-handling-strategy)
8. [èˆ‡Flutter UIå±¤æ•´åˆ](#80-èˆ‡flutter-uiå±¤æ•´åˆflutter-ui-integration)
9. [å››æ¨¡å¼å·®ç•°åŒ–æ”¯æ´](#90-å››æ¨¡å¼å·®ç•°åŒ–æ”¯æ´four-mode-support)
10. [æ¸¬è©¦è¨ˆç•«](#100-æ¸¬è©¦è¨ˆç•«testing-plan)
11. [ç‰ˆæœ¬å‡ç´šè¨ˆç•«](#110-ç‰ˆæœ¬å‡ç´šè¨ˆç•«version-upgrade-plan)

---

## 1.0 æ¨¡çµ„æ¦‚è¿°ï¼ˆModule Overviewï¼‰

### 1.1 ç”¢å“å®šä½
AuthService èªè­‰æœå‹™æ˜¯ LCAS 2.0 Flutter AP Layer çš„æ ¸å¿ƒèªè­‰æ¨¡çµ„ï¼Œè² è²¬è™•ç†ä½¿ç”¨è€…èªè­‰ã€Tokenç®¡ç†ã€å®‰å…¨é©—è­‰ç­‰åŠŸèƒ½ï¼Œç‚º Flutter Presentation Layer æä¾›çµ±ä¸€ä¸”å®‰å…¨çš„èªè­‰æœå‹™ä»‹é¢ã€‚

### 1.2 æ ¸å¿ƒè·è²¬
- **ä½¿ç”¨è€…èªè­‰**: æ”¯æ´ LINE OAuth å’Œ Email/Password é›™é‡èªè­‰æ–¹å¼
- **Tokenç®¡ç†**: JWT Token ç”Ÿæˆã€é©—è­‰ã€åˆ·æ–°ã€æ’¤éŠ·æ©Ÿåˆ¶
- **å®‰å…¨é˜²è­·**: é˜²é‡æ”¾æ”»æ“Šã€åŠ å¯†ç°½ç« é©—è­‰ã€å¤šé‡å®‰å…¨æª¢æŸ¥
- **å››æ¨¡å¼æ•´åˆ**: æ”¯æ´ Controller/Logger/Struggler/Sleeper å››ç¨®ä½¿ç”¨è€…æ¨¡å¼
- **ç„¡ç¸«æ•´åˆ**: èˆ‡ Flutter Presentation Layer ç·Šå¯†æ•´åˆ

### 1.3 æŠ€è¡“æ¶æ§‹æ¦‚è¦½
```
AuthService Architecture
â”œâ”€â”€ Authentication Core (èªè­‰æ ¸å¿ƒå±¤)
â”‚   â”œâ”€â”€ AuthManager â†’ èªè­‰ç®¡ç†å™¨
â”‚   â”œâ”€â”€ TokenManager â†’ Tokenç®¡ç†å™¨
â”‚   â””â”€â”€ SecurityValidator â†’ å®‰å…¨é©—è­‰å™¨
â”œâ”€â”€ Provider Integration (æä¾›è€…æ•´åˆå±¤)
â”‚   â”œâ”€â”€ LINE OAuth Provider â†’ LINEèªè­‰æä¾›è€…
â”‚   â”œâ”€â”€ Email Auth Provider â†’ Emailèªè­‰æä¾›è€…
â”‚   â””â”€â”€ Multi-Factor Auth â†’ å¤šé‡èªè­‰
â”œâ”€â”€ Flutter Integration (Flutteræ•´åˆå±¤)
â”‚   â”œâ”€â”€ AuthService Interface â†’ æœå‹™ä»‹é¢
â”‚   â”œâ”€â”€ State Management â†’ ç‹€æ…‹ç®¡ç†
â”‚   â””â”€â”€ UI Mode Adapter â†’ æ¨¡å¼é©é…å™¨
â””â”€â”€ Security Layer (å®‰å…¨å±¤)
    â”œâ”€â”€ Encryption Service â†’ åŠ å¯†æœå‹™
    â”œâ”€â”€ Signature Validator â†’ ç°½ç« é©—è­‰
    â””â”€â”€ Anti-Replay Protection â†’ é˜²é‡æ”¾æ”»æ“Š
```

---

## 2.0 èªè­‰æœå‹™ç°¡ä»‹ï¼ˆAuthentication Service Introductionï¼‰

### 2.1 ç›®æ¨™èˆ‡è§’è‰²
èªè­‰æœå‹™åœ¨ LCAS 2.0 Flutter æ¶æ§‹ä¸­æ‰®æ¼”å®‰å…¨å®ˆè­·è€…çš„è§’è‰²ï¼Œå°ˆé–€è² è²¬ï¼š
- **çµ±ä¸€èªè­‰å…¥å£**: ç‚ºæ‰€æœ‰ Flutter UI æä¾›çµ±ä¸€çš„èªè­‰ä»‹é¢
- **å¤šé‡èªè­‰æ”¯æ´**: æ•´åˆ LINE OAuth å’Œå‚³çµ± Email/Password èªè­‰
- **å®‰å…¨æ©Ÿåˆ¶å¯¦ä½œ**: å¯¦ç¾é‡‘èç´šåˆ¥çš„å®‰å…¨é˜²è­·æ©Ÿåˆ¶
- **ä½¿ç”¨è€…é«”é©—æœ€ä½³åŒ–**: ç¢ºä¿èªè­‰æµç¨‹é †æš¢ä¸”å®‰å…¨

### 2.2 æ”¯æ´çš„èªè­‰æ–¹å¼
- **ä¸»è¦èªè­‰**: LINE OAuth 2.0ï¼ˆæ¨è–¦ä½¿ç”¨ï¼‰
- **å‚™ç”¨èªè­‰**: Email + Passwordï¼ˆå‚³çµ±èªè­‰ï¼‰
- **å®‰å…¨å¢å¼·**: å¯é¸çš„å¤šé‡é©—è­‰ï¼ˆ2FAï¼‰
- **ç”Ÿç‰©è­˜åˆ¥**: æŒ‡ç´‹/Face ID å¿«é€Ÿç™»å…¥ï¼ˆæœªä¾†åŠŸèƒ½ï¼‰

### 2.3 æ¶æ§‹å±¤ç´šå®šä½
```
LCAS 2.0 Flutter ä¸‰å±¤æ¶æ§‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation Layer (å±•ç¤ºå±¤)       â”‚
â”‚   - Login/Register Screens          â”‚
â”‚   - Profile Settings                â”‚
â”‚   - Authentication UI               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   AP Layer (æ‡‰ç”¨é‚è¼¯å±¤)              â”‚ â† 8901æ–‡ä»¶ç¯„åœ
â”‚   - AuthService (èªè­‰æœå‹™)           â”‚
â”‚   - TokenManager (Tokenç®¡ç†)        â”‚
â”‚   - SecurityValidator (å®‰å…¨é©—è­‰)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Business Layer (å•†æ¥­é‚è¼¯å±¤)        â”‚
â”‚   - AMæ¨¡çµ„ (å¸³è™Ÿç®¡ç†)                â”‚
â”‚   - Security Services               â”‚
â”‚   - User Management                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.0 åŠŸèƒ½éœ€æ±‚ï¼ˆFunctional Requirementsï¼‰

### 3.1 èªè­‰ç®¡ç†APIç¾¤çµ„ï¼ˆF001-F005ï¼‰

#### 3.1.1 F001: ä½¿ç”¨è€…è¨»å†Š
**åŠŸèƒ½æè¿°**: æ”¯æ´æ–°ä½¿ç”¨è€…è¨»å†Šæµç¨‹ï¼ŒåŒ…å«è³‡æ–™é©—è­‰å’Œåˆå§‹è¨­å®š

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST
- **ç«¯é»**: `/auth/register`
- **è¼¸å…¥åƒæ•¸**:
```dart
class RegisterRequest {
  final String displayName;      // é¡¯ç¤ºåç¨±ï¼ˆå¿…å¡«ï¼‰
  final String? email;           // Emailï¼ˆå¯é¸ï¼‰
  final String? password;        // å¯†ç¢¼ï¼ˆå¯é¸ï¼‰
  final String? lineUserId;      // LINE User IDï¼ˆLINEè¨»å†Šæ™‚å¿…å¡«ï¼‰
  final String? lineAccessToken; // LINE Access Token
  final UserMode defaultMode;    // é è¨­ä½¿ç”¨è€…æ¨¡å¼
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class RegisterResponse {
  final bool success;
  final String userId;
  final String accessToken;
  final String refreshToken;
  final DateTime expiresAt;
  final UserProfile userProfile;
  final String? errorMessage;
}
```

**æ¥­å‹™é‚è¼¯**:
1. é©—è­‰è¼¸å…¥è³‡æ–™æ ¼å¼å’Œå®Œæ•´æ€§
2. æª¢æŸ¥ Email æˆ– LINE ID æ˜¯å¦å·²å­˜åœ¨
3. å»ºç«‹ä½¿ç”¨è€…å¸³è™Ÿä¸¦ç”Ÿæˆ UID
4. åˆå§‹åŒ–é è¨­å¸³æœ¬å’Œä½¿ç”¨è€…è¨­å®š
5. ç”Ÿæˆ JWT Token ä¸¦è¿”å›èªè­‰è³‡è¨Š

#### 3.1.2 F002: ä½¿ç”¨è€…ç™»å…¥
**åŠŸèƒ½æè¿°**: æ”¯æ´å¤šé‡ç™»å…¥æ–¹å¼ï¼ŒåŒ…å« LINE OAuth å’Œ Email/Password

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST
- **ç«¯é»**: `/auth/login`
- **è¼¸å…¥åƒæ•¸**:
```dart
class LoginRequest {
  final AuthType authType;       // èªè­‰é¡å‹
  final String? email;           // Emailç™»å…¥
  final String? password;        // å¯†ç¢¼ç™»å…¥
  final String? lineCode;        // LINEæˆæ¬Šç¢¼
  final String? lineAccessToken; // LINE Access Token
  final bool rememberMe;         // è¨˜ä½ç™»å…¥ç‹€æ…‹
}

enum AuthType { email, line }
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class LoginResponse {
  final bool success;
  final String accessToken;
  final String refreshToken;
  final DateTime expiresAt;
  final UserProfile userProfile;
  final List<String> permissions;
  final String? errorCode;
  final String? errorMessage;
}
```

**æ¥­å‹™é‚è¼¯**:
1. æ ¹æ“šèªè­‰é¡å‹åŸ·è¡Œç›¸æ‡‰é©—è­‰æµç¨‹
2. LINE èªè­‰ï¼šé©—è­‰æˆæ¬Šç¢¼ä¸¦å–å¾—ä½¿ç”¨è€…è³‡è¨Š
3. Email èªè­‰ï¼šé©—è­‰å¯†ç¢¼ä¸¦æª¢æŸ¥å¸³è™Ÿç‹€æ…‹
4. ç”Ÿæˆæ–°çš„ JWT Token
5. æ›´æ–°æœ€å¾Œç™»å…¥æ™‚é–“å’Œè£ç½®è³‡è¨Š

#### 3.1.3 F003: ä½¿ç”¨è€…ç™»å‡º
**åŠŸèƒ½æè¿°**: å®‰å…¨ç™»å‡ºä¸¦æ’¤éŠ· Token

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST
- **ç«¯é»**: `/auth/logout`
- **è¼¸å…¥åƒæ•¸**:
```dart
class LogoutRequest {
  final String accessToken;
  final bool logoutAllDevices; // æ˜¯å¦ç™»å‡ºæ‰€æœ‰è£ç½®
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class LogoutResponse {
  final bool success;
  final String message;
}
```

**æ¥­å‹™é‚è¼¯**:
1. é©—è­‰ Token æœ‰æ•ˆæ€§
2. å°‡ Token åŠ å…¥é»‘åå–®
3. æ¸…é™¤ä¼ºæœå™¨ç«¯ Session è³‡è¨Š
4. å¯é¸ï¼šæ’¤éŠ·æ‰€æœ‰è£ç½®çš„ Token

#### 3.1.4 F004: å¸³è™Ÿåˆªé™¤
**åŠŸèƒ½æè¿°**: å®Œæ•´åˆªé™¤ä½¿ç”¨è€…å¸³è™Ÿå’Œç›¸é—œè³‡æ–™

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: DELETE
- **ç«¯é»**: `/auth/account`
- **è¼¸å…¥åƒæ•¸**:
```dart
class DeleteAccountRequest {
  final String password;      // å¯†ç¢¼ç¢ºèª
  final String confirmText;   // ç¢ºèªæ–‡å­—
  final bool deleteAllData;   // æ˜¯å¦åˆªé™¤æ‰€æœ‰è³‡æ–™
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class DeleteAccountResponse {
  final bool success;
  final String message;
  final DateTime scheduledDeletionDate; // é è¨ˆåˆªé™¤æ—¥æœŸ
}
```

**æ¥­å‹™é‚è¼¯**:
1. è¦æ±‚å¯†ç¢¼å†æ¬¡ç¢ºèª
2. æ¨™è¨˜å¸³è™Ÿç‚ºå¾…åˆªé™¤ç‹€æ…‹
3. æ’ç¨‹ 30 å¤©å¾Œå®Œå…¨åˆªé™¤
4. ç«‹å³æ’¤éŠ·æ‰€æœ‰ Token
5. ç™¼é€åˆªé™¤ç¢ºèª Email

#### 3.1.5 F005: å¯†ç¢¼é‡è¨­
**åŠŸèƒ½æè¿°**: å®‰å…¨çš„å¯†ç¢¼é‡è¨­æµç¨‹

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST
- **ç«¯é»**: `/auth/reset-password`
- **è¼¸å…¥åƒæ•¸**:
```dart
class ResetPasswordRequest {
  final String email;
  final String? resetToken;    // é‡è¨­ Tokenï¼ˆç¬¬äºŒæ­¥æ™‚æä¾›ï¼‰
  final String? newPassword;   // æ–°å¯†ç¢¼ï¼ˆç¬¬äºŒæ­¥æ™‚æä¾›ï¼‰
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class ResetPasswordResponse {
  final bool success;
  final String message;
  final bool tokenSent;        // æ˜¯å¦å·²ç™¼é€é‡è¨­ Token
}
```

**æ¥­å‹™é‚è¼¯**:
1. ç¬¬ä¸€æ­¥ï¼šé©—è­‰ Email ä¸¦ç™¼é€é‡è¨­ Token
2. ç¬¬äºŒæ­¥ï¼šé©—è­‰ Token ä¸¦æ›´æ–°å¯†ç¢¼
3. Token æœ‰æ•ˆæœŸé™ï¼š15 åˆ†é˜
4. å¯†ç¢¼æ›´æ–°å¾Œç«‹å³æ’¤éŠ·æ‰€æœ‰ Token

### 3.2 Tokenç®¡ç†æ©Ÿåˆ¶

#### 3.2.1 JWT Token çµæ§‹
```dart
class JWTPayload {
  final String userId;
  final String sessionId;
  final UserMode userMode;
  final List<String> permissions;
  final DateTime issuedAt;
  final DateTime expiresAt;
  final String deviceId;
  final String appVersion;
}
```

#### 3.2.2 Token åˆ·æ–°æ©Ÿåˆ¶
```dart
class TokenRefreshService {
  // è‡ªå‹•æª¢æ¸¬ Token å³å°‡éæœŸ
  Future<bool> checkTokenExpiry();
  
  // è‡ªå‹•åˆ·æ–° Token
  Future<AuthResult> refreshToken(String refreshToken);
  
  // Token æ’¤éŠ·
  Future<void> revokeToken(String token);
}
```

---

## 4.0 æŠ€è¡“æ¶æ§‹ï¼ˆTechnical Architectureï¼‰

### 4.1 æ ¸å¿ƒæœå‹™é¡åˆ¥è¨­è¨ˆ

#### 4.1.1 AuthService ä¸»æœå‹™é¡åˆ¥
```dart
class AuthService {
  final TokenManager _tokenManager;
  final SecurityValidator _securityValidator;
  final AuthProviderManager _providerManager;
  
  // è¨»å†Š
  Future<AuthResult> register(RegisterRequest request);
  
  // ç™»å…¥
  Future<AuthResult> login(LoginRequest request);
  
  // ç™»å‡º
  Future<void> logout(LogoutRequest request);
  
  // åˆªé™¤å¸³è™Ÿ
  Future<void> deleteAccount(DeleteAccountRequest request);
  
  // é‡è¨­å¯†ç¢¼
  Future<void> resetPassword(ResetPasswordRequest request);
  
  // å–å¾—ç›®å‰ä½¿ç”¨è€…
  User? get currentUser;
  
  // æª¢æŸ¥ç™»å…¥ç‹€æ…‹
  bool get isAuthenticated;
}
```

#### 4.1.2 TokenManager Tokenç®¡ç†å™¨
```dart
class TokenManager {
  final SecureStorage _secureStorage;
  final ApiClient _apiClient;
  
  // å„²å­˜ Token
  Future<void> storeTokens(String accessToken, String refreshToken);
  
  // å–å¾— Token
  Future<String?> getAccessToken();
  
  // åˆ·æ–° Token
  Future<String> refreshAccessToken();
  
  // æ¸…é™¤ Token
  Future<void> clearTokens();
  
  // æª¢æŸ¥ Token æœ‰æ•ˆæ€§
  bool isTokenValid(String token);
  
  // Token è‡ªå‹•åˆ·æ–°
  Stream<AuthState> get authStateStream;
}
```

#### 4.1.3 SecurityValidator å®‰å…¨é©—è­‰å™¨
```dart
class SecurityValidator {
  // å¯†ç¢¼å¼·åº¦é©—è­‰
  ValidationResult validatePassword(String password);
  
  // Email æ ¼å¼é©—è­‰
  ValidationResult validateEmail(String email);
  
  // é˜²é‡æ”¾æ”»æ“Šæª¢æŸ¥
  bool checkReplayAttack(String nonce, DateTime timestamp);
  
  // ç°½ç« é©—è­‰
  bool verifySignature(String data, String signature);
  
  // è£ç½®æŒ‡ç´‹é©—è­‰
  bool validateDeviceFingerprint(DeviceInfo deviceInfo);
}
```

### 4.2 èªè­‰æä¾›è€…æ•´åˆ

#### 4.2.1 LINE OAuth Provider
```dart
class LINEAuthProvider implements AuthProvider {
  // LINE ç™»å…¥
  Future<AuthResult> signInWithLINE();
  
  // å–å¾— LINE ä½¿ç”¨è€…è³‡è¨Š
  Future<LINEUserInfo> getLINEUserInfo(String accessToken);
  
  // æ’¤éŠ· LINE æˆæ¬Š
  Future<void> revokeLINEAuth();
}
```

#### 4.2.2 Email Auth Provider
```dart
class EmailAuthProvider implements AuthProvider {
  // Email ç™»å…¥
  Future<AuthResult> signInWithEmail(String email, String password);
  
  // Email è¨»å†Š
  Future<AuthResult> registerWithEmail(String email, String password);
  
  // ç™¼é€é©—è­‰ Email
  Future<void> sendVerificationEmail(String email);
}
```

### 4.3 ç‹€æ…‹ç®¡ç†æ•´åˆ

#### 4.3.1 AuthState ç‹€æ…‹å®šç¾©
```dart
enum AuthStatus {
  initial,
  loading,
  authenticated,
  unauthenticated,
  error,
}

class AuthState {
  final AuthStatus status;
  final User? user;
  final String? token;
  final String? errorMessage;
  
  bool get isAuthenticated => status == AuthStatus.authenticated;
  bool get isLoading => status == AuthStatus.loading;
}
```

#### 4.3.2 AuthNotifier ç‹€æ…‹é€šçŸ¥å™¨
```dart
class AuthNotifier extends StateNotifier<AuthState> {
  final AuthService _authService;
  
  AuthNotifier(this._authService) : super(AuthState.initial());
  
  Future<void> login(LoginRequest request) async {
    state = state.copyWith(status: AuthStatus.loading);
    
    try {
      final result = await _authService.login(request);
      state = AuthState.authenticated(
        user: result.user,
        token: result.token,
      );
    } catch (e) {
      state = AuthState.error(e.toString());
    }
  }
  
  Future<void> logout() async {
    await _authService.logout();
    state = AuthState.unauthenticated();
  }
}
```

---

## 5.0 APIç«¯é»è¦æ ¼ï¼ˆAPI Endpoints Specificationï¼‰

### 5.1 èªè­‰ç«¯é»è©³ç´°è¦æ ¼

#### 5.1.1 POST /auth/register - ä½¿ç”¨è€…è¨»å†Š
**Request Headers**:
```
Content-Type: application/json
X-App-Version: 1.0.0
X-Device-ID: [device_uuid]
X-Timestamp: [unix_timestamp]
```

**Request Body**:
```json
{
  "displayName": "å¼µå°æ˜",
  "email": "user@example.com",
  "password": "SecurePass123!",
  "authType": "email",
  "defaultMode": "logger",
  "deviceInfo": {
    "platform": "iOS",
    "version": "15.0",
    "model": "iPhone 13"
  }
}
```

**Response 200 OK**:
```json
{
  "success": true,
  "data": {
    "userId": "usr_abc123",
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "ref_xyz789",
    "expiresAt": "2025-01-27T14:00:00Z",
    "user": {
      "id": "usr_abc123",
      "displayName": "å¼µå°æ˜",
      "email": "user@example.com",
      "userMode": "logger",
      "createdAt": "2025-01-26T14:00:00Z"
    }
  },
  "message": "è¨»å†ŠæˆåŠŸ"
}
```

**Error Responses**:
```json
// 400 Bad Request - è³‡æ–™é©—è­‰å¤±æ•—
{
  "success": false,
  "errorCode": "VALIDATION_ERROR",
  "message": "Email æ ¼å¼ä¸æ­£ç¢º",
  "details": {
    "field": "email",
    "value": "invalid-email"
  }
}

// 409 Conflict - Email å·²å­˜åœ¨
{
  "success": false,
  "errorCode": "EMAIL_EXISTS",
  "message": "æ­¤ Email å·²ç¶“è¨»å†Šé"
}
```

#### 5.1.2 POST /auth/login - ä½¿ç”¨è€…ç™»å…¥
**Request Body (Emailç™»å…¥)**:
```json
{
  "authType": "email",
  "email": "user@example.com",
  "password": "SecurePass123!",
  "rememberMe": true
}
```

**Request Body (LINEç™»å…¥)**:
```json
{
  "authType": "line",
  "lineCode": "auth_code_from_line",
  "rememberMe": true
}
```

**Response 200 OK**:
```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "ref_xyz789",
    "expiresAt": "2025-01-27T14:00:00Z",
    "user": {
      "id": "usr_abc123",
      "displayName": "å¼µå°æ˜",
      "email": "user@example.com",
      "userMode": "logger",
      "lastLoginAt": "2025-01-26T14:00:00Z"
    },
    "permissions": ["read", "write", "delete"]
  },
  "message": "ç™»å…¥æˆåŠŸ"
}
```

### 5.2 Token ç›¸é—œç«¯é»

#### 5.2.1 POST /auth/refresh - Token åˆ·æ–°
**Request Headers**:
```
Authorization: Bearer [refresh_token]
```

**Response 200 OK**:
```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "expiresAt": "2025-01-27T14:00:00Z"
  }
}
```

#### 5.2.2 POST /auth/validate - Token é©—è­‰
**Request Headers**:
```
Authorization: Bearer [access_token]
```

**Response 200 OK**:
```json
{
  "success": true,
  "data": {
    "valid": true,
    "userId": "usr_abc123",
    "expiresAt": "2025-01-27T14:00:00Z",
    "permissions": ["read", "write"]
  }
}
```

---

## 6.0 å®‰å…¨æ€§è¦æ±‚ï¼ˆSecurity Requirementsï¼‰

### 6.1 åŠ å¯†èˆ‡ç°½ç« æ©Ÿåˆ¶

#### 6.1.1 å¯†ç¢¼åŠ å¯†
- **æ¼”ç®—æ³•**: bcrypt with cost factor 12
- **Salt**: æ¯å€‹å¯†ç¢¼ä½¿ç”¨ç¨ç«‹çš„éš¨æ©Ÿ Salt
- **æœ€å°é•·åº¦**: 8 å­—å…ƒ
- **è¤‡é›œåº¦è¦æ±‚**: åŒ…å«å¤§å°å¯«å­—æ¯ã€æ•¸å­—ã€ç‰¹æ®Šç¬¦è™Ÿ

#### 6.1.2 Token å®‰å…¨
```dart
class TokenSecurity {
  // JWT ç°½ç« æ¼”ç®—æ³•
  static const String ALGORITHM = 'HS256';
  
  // Token æœ‰æ•ˆæœŸ
  static const Duration ACCESS_TOKEN_EXPIRY = Duration(hours: 1);
  static const Duration REFRESH_TOKEN_EXPIRY = Duration(days: 30);
  
  // Token é»‘åå–®æ©Ÿåˆ¶
  static final Set<String> _blacklistedTokens = {};
  
  static bool isTokenBlacklisted(String token) {
    return _blacklistedTokens.contains(token);
  }
}
```

#### 6.1.3 API è«‹æ±‚ç°½ç« 
```dart
class RequestSigner {
  static String generateSignature({
    required String method,
    required String path,
    required String body,
    required String timestamp,
    required String nonce,
    required String secretKey,
  }) {
    final message = '$method|$path|$body|$timestamp|$nonce';
    final hmac = Hmac(sha256, utf8.encode(secretKey));
    final digest = hmac.convert(utf8.encode(message));
    return base64.encode(digest.bytes);
  }
}
```

### 6.2 é˜²è­·æ©Ÿåˆ¶

#### 6.2.1 é˜²é‡æ”¾æ”»æ“Š
```dart
class AntiReplayProtection {
  static const Duration NONCE_VALIDITY = Duration(minutes: 5);
  static final Map<String, DateTime> _usedNonces = {};
  
  static bool validateNonce(String nonce, DateTime timestamp) {
    // æª¢æŸ¥æ™‚é–“æˆ³æ˜¯å¦åœ¨æœ‰æ•ˆç¯„åœå…§
    final now = DateTime.now();
    if (now.difference(timestamp) > NONCE_VALIDITY) {
      return false;
    }
    
    // æª¢æŸ¥ nonce æ˜¯å¦å·²ä½¿ç”¨
    if (_usedNonces.containsKey(nonce)) {
      return false;
    }
    
    // è¨˜éŒ„ nonce
    _usedNonces[nonce] = timestamp;
    
    // æ¸…ç†éæœŸçš„ nonce
    _cleanupExpiredNonces();
    
    return true;
  }
}
```

#### 6.2.2 é€Ÿç‡é™åˆ¶
```dart
class RateLimit {
  // ç™»å…¥å˜—è©¦é™åˆ¶
  static const int MAX_LOGIN_ATTEMPTS = 5;
  static const Duration LOGIN_LOCKOUT = Duration(minutes: 15);
  
  // API è«‹æ±‚é™åˆ¶
  static const int MAX_REQUESTS_PER_MINUTE = 100;
  
  static bool checkRateLimit(String identifier, RateLimitType type) {
    // å¯¦ä½œé€Ÿç‡é™åˆ¶é‚è¼¯
    // è¿”å›æ˜¯å¦å…è¨±è«‹æ±‚
  }
}
```

### 6.3 è³‡æ–™ä¿è­·

#### 6.3.1 æ•æ„Ÿè³‡æ–™åŠ å¯†
```dart
class DataEncryption {
  static const String ENCRYPTION_ALGORITHM = 'AES-256-GCM';
  
  static String encrypt(String plaintext, String key) {
    // å¯¦ä½œ AES åŠ å¯†
  }
  
  static String decrypt(String ciphertext, String key) {
    // å¯¦ä½œ AES è§£å¯†
  }
}
```

#### 6.3.2 å®‰å…¨å„²å­˜
```dart
class SecureStorage {
  final FlutterSecureStorage _storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
    iOptions: IOSOptions(
      accessibility: IOSAccessibility.first_unlock_this_device,
    ),
  );
  
  Future<void> storeToken(String key, String token) async {
    await _storage.write(key: key, value: token);
  }
  
  Future<String?> getToken(String key) async {
    return await _storage.read(key: key);
  }
  
  Future<void> deleteToken(String key) async {
    await _storage.delete(key: key);
  }
}
```

---

## 7.0 éŒ¯èª¤è™•ç†ç­–ç•¥ï¼ˆError Handling Strategyï¼‰

### 7.1 éŒ¯èª¤åˆ†é¡ç³»çµ±

#### 7.1.1 èªè­‰éŒ¯èª¤å®šç¾©
```dart
enum AuthErrorCode {
  // ç¶²è·¯ç›¸é—œéŒ¯èª¤
  NETWORK_ERROR,
  TIMEOUT_ERROR,
  
  // èªè­‰ç›¸é—œéŒ¯èª¤
  INVALID_CREDENTIALS,
  ACCOUNT_NOT_FOUND,
  ACCOUNT_DISABLED,
  TOKEN_EXPIRED,
  TOKEN_INVALID,
  
  // æˆæ¬Šç›¸é—œéŒ¯èª¤
  INSUFFICIENT_PERMISSIONS,
  ACCOUNT_LOCKED,
  
  // é©—è­‰ç›¸é—œéŒ¯èª¤
  VALIDATION_ERROR,
  EMAIL_FORMAT_ERROR,
  PASSWORD_TOO_WEAK,
  
  // ç³»çµ±ç›¸é—œéŒ¯èª¤
  INTERNAL_ERROR,
  SERVICE_UNAVAILABLE,
  RATE_LIMIT_EXCEEDED,
}

class AuthError extends Error {
  final AuthErrorCode code;
  final String message;
  final String? details;
  final Map<String, dynamic>? metadata;
  
  AuthError({
    required this.code,
    required this.message,
    this.details,
    this.metadata,
  });
}
```

#### 7.1.2 éŒ¯èª¤æœ¬åœ°åŒ–è¨Šæ¯
```dart
class AuthErrorMessages {
  static const Map<AuthErrorCode, String> _messages = {
    AuthErrorCode.INVALID_CREDENTIALS: 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤',
    AuthErrorCode.ACCOUNT_NOT_FOUND: 'æ‰¾ä¸åˆ°æ­¤å¸³è™Ÿ',
    AuthErrorCode.ACCOUNT_DISABLED: 'å¸³è™Ÿå·²è¢«åœç”¨',
    AuthErrorCode.TOKEN_EXPIRED: 'ç™»å…¥å·²éæœŸï¼Œè«‹é‡æ–°ç™»å…¥',
    AuthErrorCode.TOKEN_INVALID: 'ç„¡æ•ˆçš„èªè­‰è³‡è¨Š',
    AuthErrorCode.NETWORK_ERROR: 'ç¶²è·¯é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯è¨­å®š',
    AuthErrorCode.EMAIL_FORMAT_ERROR: 'Email æ ¼å¼ä¸æ­£ç¢º',
    AuthErrorCode.PASSWORD_TOO_WEAK: 'å¯†ç¢¼å¼·åº¦ä¸è¶³',
    AuthErrorCode.RATE_LIMIT_EXCEEDED: 'æ“ä½œéæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦',
  };
  
  static String getMessage(AuthErrorCode code) {
    return _messages[code] ?? 'æœªçŸ¥éŒ¯èª¤';
  }
}
```

### 7.2 éŒ¯èª¤è™•ç†æ©Ÿåˆ¶

#### 7.2.1 çµ±ä¸€éŒ¯èª¤è™•ç†å™¨
```dart
class AuthErrorHandler {
  static AuthError handleApiError(DioError error) {
    switch (error.type) {
      case DioErrorType.connectTimeout:
      case DioErrorType.receiveTimeout:
        return AuthError(
          code: AuthErrorCode.TIMEOUT_ERROR,
          message: 'é€£ç·šé€¾æ™‚',
        );
        
      case DioErrorType.response:
        return _handleResponseError(error.response);
        
      default:
        return AuthError(
          code: AuthErrorCode.NETWORK_ERROR,
          message: 'ç¶²è·¯éŒ¯èª¤',
        );
    }
  }
  
  static AuthError _handleResponseError(Response? response) {
    if (response == null) {
      return AuthError(
        code: AuthErrorCode.INTERNAL_ERROR,
        message: 'ç³»çµ±éŒ¯èª¤',
      );
    }
    
    switch (response.statusCode) {
      case 401:
        return AuthError(
          code: AuthErrorCode.INVALID_CREDENTIALS,
          message: 'èªè­‰å¤±æ•—',
        );
      case 403:
        return AuthError(
          code: AuthErrorCode.INSUFFICIENT_PERMISSIONS,
          message: 'æ¬Šé™ä¸è¶³',
        );
      case 429:
        return AuthError(
          code: AuthErrorCode.RATE_LIMIT_EXCEEDED,
          message: 'è«‹æ±‚éæ–¼é »ç¹',
        );
      default:
        return AuthError(
          code: AuthErrorCode.INTERNAL_ERROR,
          message: 'ç³»çµ±éŒ¯èª¤',
        );
    }
  }
}
```

#### 7.2.2 è‡ªå‹•é‡è©¦æ©Ÿåˆ¶
```dart
class RetryMechanism {
  static const int MAX_RETRY_ATTEMPTS = 3;
  static const Duration RETRY_DELAY = Duration(seconds: 2);
  
  static Future<T> executeWithRetry<T>(
    Future<T> Function() operation,
    {bool Function(dynamic error)? shouldRetry}
  ) async {
    int attempts = 0;
    
    while (attempts < MAX_RETRY_ATTEMPTS) {
      try {
        return await operation();
      } catch (error) {
        attempts++;
        
        if (attempts >= MAX_RETRY_ATTEMPTS || 
            (shouldRetry != null && !shouldRetry(error))) {
          rethrow;
        }
        
        await Future.delayed(RETRY_DELAY * attempts);
      }
    }
    
    throw Exception('Maximum retry attempts exceeded');
  }
}
```

---

## 8.0 èˆ‡Flutter UIå±¤æ•´åˆï¼ˆFlutter UI Integrationï¼‰

### 8.1 UI ç‹€æ…‹ç®¡ç†æ•´åˆ

#### 8.1.1 Provider æ•´åˆ
```dart
class AuthProvider extends ChangeNotifier {
  final AuthService _authService;
  AuthState _state = AuthState.initial();
  
  AuthState get state => _state;
  User? get currentUser => _state.user;
  bool get isAuthenticated => _state.isAuthenticated;
  
  AuthProvider(this._authService) {
    _initializeAuth();
  }
  
  Future<void> _initializeAuth() async {
    _setState(AuthState.loading());
    
    try {
      final token = await _authService.getStoredToken();
      if (token != null && _authService.isTokenValid(token)) {
        final user = await _authService.getCurrentUser();
        _setState(AuthState.authenticated(user: user, token: token));
      } else {
        _setState(AuthState.unauthenticated());
      }
    } catch (e) {
      _setState(AuthState.error(e.toString()));
    }
  }
  
  Future<AuthResult> login(LoginRequest request) async {
    _setState(AuthState.loading());
    
    try {
      final result = await _authService.login(request);
      _setState(AuthState.authenticated(
        user: result.user,
        token: result.token,
      ));
      return result;
    } catch (e) {
      _setState(AuthState.error(e.toString()));
      rethrow;
    }
  }
  
  void _setState(AuthState newState) {
    _state = newState;
    notifyListeners();
  }
}
```

#### 8.1.2 Riverpod æ•´åˆ
```dart
final authServiceProvider = Provider<AuthService>((ref) {
  return AuthService();
});

final authStateProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return AuthNotifier(authService);
});

final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authStateProvider).user;
});

final isAuthenticatedProvider = Provider<bool>((ref) {
  return ref.watch(authStateProvider).isAuthenticated;
});
```

### 8.2 UI å…ƒä»¶æ•´åˆç¯„ä¾‹

#### 8.2.1 ç™»å…¥é é¢æ•´åˆ
```dart
class LoginScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authStateProvider);
    final authNotifier = ref.read(authStateProvider.notifier);
    
    // ç›£è½èªè­‰ç‹€æ…‹è®ŠåŒ–
    ref.listen<AuthState>(authStateProvider, (previous, next) {
      if (next.isAuthenticated) {
        Navigator.pushReplacementNamed(context, '/home');
      } else if (next.status == AuthStatus.error) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.errorMessage ?? 'ç™»å…¥å¤±æ•—')),
        );
      }
    });
    
    return Scaffold(
      body: authState.isLoading
          ? Center(child: CircularProgressIndicator())
          : _buildLoginForm(context, authNotifier),
    );
  }
  
  Widget _buildLoginForm(BuildContext context, AuthNotifier authNotifier) {
    return Padding(
      padding: EdgeInsets.all(16.0),
      child: Column(
        children: [
          // LINE ç™»å…¥æŒ‰éˆ•
          ElevatedButton.icon(
            onPressed: () => _loginWithLINE(authNotifier),
            icon: Icon(Icons.login),
            label: Text('ä½¿ç”¨ LINE ç™»å…¥'),
          ),
          
          // Email ç™»å…¥è¡¨å–®
          EmailLoginForm(
            onSubmit: (email, password) => _loginWithEmail(
              authNotifier, email, password
            ),
          ),
        ],
      ),
    );
  }
  
  Future<void> _loginWithLINE(AuthNotifier authNotifier) async {
    try {
      await authNotifier.loginWithLINE();
    } catch (e) {
      // éŒ¯èª¤è™•ç†å·²åœ¨ Provider ä¸­çµ±ä¸€è™•ç†
    }
  }
  
  Future<void> _loginWithEmail(
    AuthNotifier authNotifier,
    String email,
    String password,
  ) async {
    try {
      await authNotifier.loginWithEmail(email, password);
    } catch (e) {
      // éŒ¯èª¤è™•ç†å·²åœ¨ Provider ä¸­çµ±ä¸€è™•ç†
    }
  }
}
```

#### 8.2.2 è·¯ç”±å®ˆè¡›æ•´åˆ
```dart
class AuthGuard {
  static Route<dynamic> generateRoute(RouteSettings settings) {
    return MaterialPageRoute(
      builder: (context) => Consumer(
        builder: (context, ref, child) {
          final isAuthenticated = ref.watch(isAuthenticatedProvider);
          
          if (!isAuthenticated && !_publicRoutes.contains(settings.name)) {
            return LoginScreen();
          }
          
          return _buildRoute(settings);
        },
      ),
      settings: settings,
    );
  }
  
  static const List<String> _publicRoutes = [
    '/login',
    '/register',
    '/forgot-password',
  ];
}
```

---

## 9.0 å››æ¨¡å¼å·®ç•°åŒ–æ”¯æ´ï¼ˆFour Mode Supportï¼‰

### 9.1 æ¨¡å¼èªè­‰ç­–ç•¥

#### 9.1.1 ç²¾æº–æ§åˆ¶è€…æ¨¡å¼ (Controller)
**èªè­‰ç‰¹é»**: å®Œæ•´åŠŸèƒ½ï¼Œé«˜å®‰å…¨æ€§è¦æ±‚
```dart
class ControllerModeAuth implements AuthModeStrategy {
  @override
  List<AuthFeature> getSupportedFeatures() {
    return [
      AuthFeature.EMAIL_LOGIN,
      AuthFeature.LINE_LOGIN,
      AuthFeature.TWO_FACTOR_AUTH,
      AuthFeature.DEVICE_MANAGEMENT,
      AuthFeature.SESSION_MANAGEMENT,
      AuthFeature.SECURITY_LOGS,
    ];
  }
  
  @override
  SecurityLevel getSecurityLevel() => SecurityLevel.HIGH;
  
  @override
  Duration getTokenExpiry() => Duration(hours: 1); // è¼ƒçŸ­çš„ Token æœ‰æ•ˆæœŸ
}
```

#### 9.1.2 ç´€éŒ„ç¿’æ…£è€…æ¨¡å¼ (Logger)
**èªè­‰ç‰¹é»**: ç°¡æ½”å„ªé›…ï¼Œæ³¨é‡é«”é©—
```dart
class LoggerModeAuth implements AuthModeStrategy {
  @override
  List<AuthFeature> getSupportedFeatures() {
    return [
      AuthFeature.LINE_LOGIN,        // ä¸»è¦æ¨è–¦
      AuthFeature.EMAIL_LOGIN,       // å‚™ç”¨é¸é …
      AuthFeature.REMEMBER_ME,       // è¨˜ä½ç™»å…¥
      AuthFeature.QUICK_ACCESS,      // å¿«é€Ÿé€²å…¥
    ];
  }
  
  @override
  SecurityLevel getSecurityLevel() => SecurityLevel.MEDIUM;
  
  @override
  Duration getTokenExpiry() => Duration(hours: 24); // è¼ƒé•·çš„æœ‰æ•ˆæœŸ
}
```

#### 9.1.3 è½‰å‹æŒ‘æˆ°è€…æ¨¡å¼ (Struggler)
**èªè­‰ç‰¹é»**: ç¿’æ…£é¤Šæˆå°å‘ï¼Œæé†’æ©Ÿåˆ¶
```dart
class StrugglerModeAuth implements AuthModeStrategy {
  @override
  List<AuthFeature> getSupportedFeatures() {
    return [
      AuthFeature.LINE_LOGIN,
      AuthFeature.HABIT_TRACKING,   // ç¿’æ…£è¿½è¹¤
      AuthFeature.REMINDER_AUTH,    // æé†’èªè­‰
      AuthFeature.GOAL_INTEGRATION, // ç›®æ¨™æ•´åˆ
    ];
  }
  
  @override
  SecurityLevel getSecurityLevel() => SecurityLevel.MEDIUM;
  
  @override
  Map<String, dynamic> getAuthExtensions() {
    return {
      'habit_tracking': true,
      'reminder_notifications': true,
      'goal_based_auth': true,
    };
  }
}
```

#### 9.1.4 æ½›åœ¨è¦ºé†’è€…æ¨¡å¼ (Sleeper)
**èªè­‰ç‰¹é»**: æ¥µç°¡æµç¨‹ï¼Œé™ä½é–€æª»
```dart
class SleeperModeAuth implements AuthModeStrategy {
  @override
  List<AuthFeature> getSupportedFeatures() {
    return [
      AuthFeature.LINE_LOGIN,        // åƒ…æ”¯æ´ LINE ç™»å…¥
      AuthFeature.GUEST_MODE,        // è¨ªå®¢æ¨¡å¼
      AuthFeature.AUTO_LOGIN,        // è‡ªå‹•ç™»å…¥
    ];
  }
  
  @override
  SecurityLevel getSecurityLevel() => SecurityLevel.LOW;
  
  @override
  bool isSimplifiedFlow() => true; // ç°¡åŒ–èªè­‰æµç¨‹
  
  @override
  Duration getTokenExpiry() => Duration(days: 7); // æœ€é•·æœ‰æ•ˆæœŸ
}
```

### 9.2 æ¨¡å¼åˆ‡æ›æ©Ÿåˆ¶

#### 9.2.1 æ¨¡å¼æª¢æ¸¬èˆ‡é©é…
```dart
class AuthModeAdapter {
  static AuthModeStrategy getStrategy(UserMode mode) {
    switch (mode) {
      case UserMode.controller:
        return ControllerModeAuth();
      case UserMode.logger:
        return LoggerModeAuth();
      case UserMode.struggler:
        return StrugglerModeAuth();
      case UserMode.sleeper:
        return SleeperModeAuth();
    }
  }
  
  static Future<void> adaptAuthFlow(UserMode mode) async {
    final strategy = getStrategy(mode);
    
    // èª¿æ•´ Token æœ‰æ•ˆæœŸ
    TokenManager.setTokenExpiry(strategy.getTokenExpiry());
    
    // è¨­å®šå®‰å…¨ç­‰ç´š
    SecurityValidator.setSecurityLevel(strategy.getSecurityLevel());
    
    // å•Ÿç”¨å°æ‡‰åŠŸèƒ½
    AuthService.enableFeatures(strategy.getSupportedFeatures());
  }
}
```

#### 9.2.2 UI å·®ç•°åŒ–å¯¦ä½œ
```dart
class AuthUIBuilder {
  static Widget buildLoginScreen(UserMode mode) {
    final strategy = AuthModeAdapter.getStrategy(mode);
    
    switch (mode) {
      case UserMode.sleeper:
        return _buildSleeperLoginScreen(strategy);
      case UserMode.logger:
        return _buildLoggerLoginScreen(strategy);
      case UserMode.struggler:
        return _buildStrugglerLoginScreen(strategy);
      case UserMode.controller:
        return _buildControllerLoginScreen(strategy);
    }
  }
  
  static Widget _buildSleeperLoginScreen(AuthModeStrategy strategy) {
    return SimpleLoginScreen(
      title: 'è¼•é¬†é–‹å§‹è¨˜å¸³',
      subtitle: 'ä½¿ç”¨ LINE å¸³è™Ÿä¸€éµç™»å…¥',
      primaryButton: LargeLINELoginButton(),
      showAlternativeLogin: false, // ä¸é¡¯ç¤ºå…¶ä»–ç™»å…¥é¸é …
    );
  }
  
  static Widget _buildControllerLoginScreen(AuthModeStrategy strategy) {
    return AdvancedLoginScreen(
      title: 'è²¡å‹™æ§åˆ¶ä¸­å¿ƒ',
      features: [
        EmailLoginForm(),
        LINELoginButton(),
        TwoFactorAuthOption(),
        SecurityOptionsPanel(),
      ],
    );
  }
}
```

---

## 10.0 æ¸¬è©¦è¨ˆç•«ï¼ˆTesting Planï¼‰

### 10.1 å–®å…ƒæ¸¬è©¦è¦åŠƒ

#### 10.1.1 AuthService æ¸¬è©¦
```dart
class AuthServiceTest {
  late AuthService authService;
  late MockTokenManager mockTokenManager;
  late MockSecurityValidator mockSecurityValidator;
  
  @setUp
  void setUp() {
    mockTokenManager = MockTokenManager();
    mockSecurityValidator = MockSecurityValidator();
    authService = AuthService(
      tokenManager: mockTokenManager,
      securityValidator: mockSecurityValidator,
    );
  }
  
  @test
  void test_register_success() async {
    // Given
    final request = RegisterRequest(
      displayName: 'æ¸¬è©¦ç”¨æˆ¶',
      email: 'test@example.com',
      password: 'TestPass123!',
      defaultMode: UserMode.logger,
    );
    
    when(mockSecurityValidator.validateEmail(any))
        .thenReturn(ValidationResult.valid());
    when(mockSecurityValidator.validatePassword(any))
        .thenReturn(ValidationResult.valid());
    
    // When
    final result = await authService.register(request);
    
    // Then
    expect(result.success, isTrue);
    expect(result.user, isNotNull);
    expect(result.token, isNotNull);
  }
  
  @test
  void test_login_invalid_credentials() async {
    // Given
    final request = LoginRequest(
      authType: AuthType.email,
      email: 'test@example.com',
      password: 'wrong_password',
    );
    
    // When & Then
    expect(
      () => authService.login(request),
      throwsA(isA<AuthError>().having(
        (e) => e.code,
        'error code',
        AuthErrorCode.INVALID_CREDENTIALS,
      )),
    );
  }
}
```

#### 10.1.2 TokenManager æ¸¬è©¦
```dart
class TokenManagerTest {
  late TokenManager tokenManager;
  late MockSecureStorage mockStorage;
  
  @test
  void test_token_refresh_mechanism() async {
    // Given
    final expiredToken = 'expired_token';
    final newToken = 'new_token';
    
    when(mockStorage.getAccessToken())
        .thenReturn(Future.value(expiredToken));
    when(tokenManager.isTokenExpired(expiredToken))
        .thenReturn(true);
    
    // When
    final result = await tokenManager.getValidToken();
    
    // Then
    expect(result, equals(newToken));
    verify(mockStorage.storeToken('access_token', newToken));
  }
}
```

### 10.2 æ•´åˆæ¸¬è©¦è¦åŠƒ

#### 10.2.1 API æ•´åˆæ¸¬è©¦
```dart
class AuthAPIIntegrationTest {
  late AuthService authService;
  
  @test
  void test_complete_auth_flow() async {
    // 1. è¨»å†Š
    final registerResult = await authService.register(RegisterRequest(
      displayName: 'æ•´åˆæ¸¬è©¦ç”¨æˆ¶',
      email: 'integration@test.com',
      password: 'TestPass123!',
    ));
    expect(registerResult.success, isTrue);
    
    // 2. ç™»å‡º
    await authService.logout();
    
    // 3. é‡æ–°ç™»å…¥
    final loginResult = await authService.login(LoginRequest(
      authType: AuthType.email,
      email: 'integration@test.com',
      password: 'TestPass123!',
    ));
    expect(loginResult.success, isTrue);
    
    // 4. Token åˆ·æ–°
    await Future.delayed(Duration(seconds: 1));
    final refreshResult = await authService.refreshToken();
    expect(refreshResult.success, isTrue);
  }
}
```

#### 10.2.2 å››æ¨¡å¼æ•´åˆæ¸¬è©¦
```dart
class AuthModeIntegrationTest {
  @test
  void test_mode_switching() async {
    for (final mode in UserMode.values) {
      // Given
      await AuthModeAdapter.adaptAuthFlow(mode);
      final strategy = AuthModeAdapter.getStrategy(mode);
      
      // When
      final features = strategy.getSupportedFeatures();
      final securityLevel = strategy.getSecurityLevel();
      
      // Then
      expect(features, isNotEmpty);
      expect(securityLevel, isNotNull);
      
      // é©—è­‰æ¨¡å¼ç‰¹å®šåŠŸèƒ½
      switch (mode) {
        case UserMode.sleeper:
          expect(features, contains(AuthFeature.LINE_LOGIN));
          expect(features, isNot(contains(AuthFeature.TWO_FACTOR_AUTH)));
          break;
        case UserMode.controller:
          expect(features, contains(AuthFeature.TWO_FACTOR_AUTH));
          expect(securityLevel, equals(SecurityLevel.HIGH));
          break;
      }
    }
  }
}
```

### 10.3 æ•ˆèƒ½æ¸¬è©¦è¦åŠƒ

#### 10.3.1 Token æ•ˆèƒ½æ¸¬è©¦
```dart
class TokenPerformanceTest {
  @test
  void test_token_generation_performance() async {
    final stopwatch = Stopwatch()..start();
    
    for (int i = 0; i < 1000; i++) {
      await TokenManager.generateAccessToken(
        userId: 'user_$i',
        permissions: ['read', 'write'],
      );
    }
    
    stopwatch.stop();
    
    // Token ç”Ÿæˆæ‡‰è©²åœ¨åˆç†æ™‚é–“å…§å®Œæˆ
    expect(stopwatch.elapsedMilliseconds, lessThan(5000));
  }
  
  @test
  void test_concurrent_auth_requests() async {
    final futures = List.generate(50, (index) =>
      authService.login(LoginRequest(
        authType: AuthType.email,
        email: 'user$index@test.com',
        password: 'TestPass123!',
      ))
    );
    
    final results = await Future.wait(futures);
    
    // æ‰€æœ‰è«‹æ±‚éƒ½æ‡‰è©²æˆåŠŸ
    expect(results.every((r) => r.success), isTrue);
  }
}
```

### 10.4 å®‰å…¨æ€§æ¸¬è©¦è¦åŠƒ

#### 10.4.1 æ¼æ´æ¸¬è©¦
```dart
class SecurityTest {
  @test
  void test_sql_injection_prevention() async {
    final maliciousEmail = "test@test.com'; DROP TABLE users; --";
    
    expect(
      () => authService.login(LoginRequest(
        authType: AuthType.email,
        email: maliciousEmail,
        password: 'password',
      )),
      throwsA(isA<AuthError>().having(
        (e) => e.code,
        'error code',
        AuthErrorCode.VALIDATION_ERROR,
      )),
    );
  }
  
  @test
  void test_brute_force_protection() async {
    final email = 'target@test.com';
    
    // å˜—è©¦å¤šæ¬¡éŒ¯èª¤ç™»å…¥
    for (int i = 0; i < 6; i++) {
      try {
        await authService.login(LoginRequest(
          authType: AuthType.email,
          email: email,
          password: 'wrong_password_$i',
        ));
      } catch (e) {
        if (i < 5) {
          expect(e, isA<AuthError>().having(
            (e) => e.code, 'error code', AuthErrorCode.INVALID_CREDENTIALS));
        } else {
          expect(e, isA<AuthError>().having(
            (e) => e.code, 'error code', AuthErrorCode.ACCOUNT_LOCKED));
        }
      }
    }
  }
}
```

---

## 11.0 ç‰ˆæœ¬å‡ç´šè¨ˆç•«ï¼ˆVersion Upgrade Planï¼‰

### 11.1 æ¨¡çµ„ç‰ˆæœ¬è¦åŠƒ

| å…ƒä»¶åç¨± | ç•¶å‰ç‰ˆæœ¬ | ç›®æ¨™ç‰ˆæœ¬ | å‡ç´šå…§å®¹ | ç›¸ä¾æ€§ |
|----------|----------|----------|----------|--------|
| **AuthService** | æ–°å»º | v1.0.0 | å®Œæ•´èªè­‰æœå‹™å¯¦ä½œï¼Œæ”¯æ´å››æ¨¡å¼ | AMæ¨¡çµ„ v1.1.1 |
| **TokenManager** | æ–°å»º | v1.0.0 | JWT Token ç®¡ç†ï¼Œå®‰å…¨å„²å­˜ | Security Library |
| **SecurityValidator** | æ–°å»º | v1.0.0 | å®‰å…¨é©—è­‰æ©Ÿåˆ¶ï¼Œé˜²è­·æªæ–½ | Crypto Library |
| **AuthProviders** | æ–°å»º | v1.0.0 | LINE OAuthã€Email èªè­‰æä¾›è€… | LINE SDK |
| **AuthUI Components** | æ–°å»º | v1.0.0 | èªè­‰ç›¸é—œ UI å…ƒä»¶åº« | Flutter UI |

### 11.2 é–‹ç™¼é‡Œç¨‹ç¢‘

#### 11.2.1 Phase 1: æ ¸å¿ƒèªè­‰æ¶æ§‹ (Week 1-2)
- âœ… AuthService åŸºç¤æ¶æ§‹è¨­è¨ˆ
- âœ… TokenManager å¯¦ä½œ
- âœ… åŸºç¤å®‰å…¨æ©Ÿåˆ¶
- ğŸ”„ API ç«¯é»å¯¦ä½œï¼ˆF001-F005ï¼‰
- ğŸ”„ éŒ¯èª¤è™•ç†æ©Ÿåˆ¶

#### 11.2.2 Phase 2: èªè­‰æä¾›è€…æ•´åˆ (Week 3-4)
- â³ LINE OAuth æ•´åˆ
- â³ Email èªè­‰å¯¦ä½œ
- â³ å¤šé‡èªè­‰æ”¯æ´
- â³ å®‰å…¨é©—è­‰å¼·åŒ–

#### 11.2.3 Phase 3: Flutter UI æ•´åˆ (Week 5-6)
- â³ State Management æ•´åˆ
- â³ èªè­‰ç›¸é—œ UI å…ƒä»¶
- â³ è·¯ç”±å®ˆè¡›å¯¦ä½œ
- â³ å››æ¨¡å¼å·®ç•°åŒ– UI

#### 11.2.4 Phase 4: å››æ¨¡å¼æ”¯æ´èˆ‡å„ªåŒ– (Week 7-8)
- â³ å››æ¨¡å¼èªè­‰ç­–ç•¥å¯¦ä½œ
- â³ æ¨¡å¼åˆ‡æ›æ©Ÿåˆ¶
- â³ ä½¿ç”¨è€…é«”é©—æœ€ä½³åŒ–
- â³ æ•ˆèƒ½èª¿å„ª

#### 11.2.5 Phase 5: æ¸¬è©¦èˆ‡å®‰å…¨å¼·åŒ– (Week 9-10)
- â³ å®Œæ•´æ¸¬è©¦è¦†è“‹
- â³ å®‰å…¨æ€§æ¸¬è©¦
- â³ æ•ˆèƒ½æ¸¬è©¦
- â³ æ–‡ä»¶å®Œå–„

### 11.3 ç›¸ä¾æ€§ç®¡ç†

#### 11.3.1 å¤–éƒ¨ç›¸ä¾æ€§
```yaml
dependencies:
  # Flutter æ ¸å¿ƒ
  flutter: ^3.0.0
  
  # ç‹€æ…‹ç®¡ç†
  flutter_riverpod: ^2.3.0
  provider: ^6.0.0
  
  # ç¶²è·¯è«‹æ±‚
  dio: ^5.0.0
  
  # å®‰å…¨å„²å­˜
  flutter_secure_storage: ^9.0.0
  
  # åŠ å¯†
  crypto: ^3.0.0
  pointycastle: ^3.7.0
  
  # JWT
  jwt_decoder: ^2.0.1
  
  # LINE SDK
  line_login_sdk: ^2.0.0
  
  # å·¥å…·
  uuid: ^3.0.0
  
dev_dependencies:
  # æ¸¬è©¦
  flutter_test:
    sdk: flutter
  mockito: ^5.4.0
  integration_test:
    sdk: flutter
```

#### 11.3.2 å…§éƒ¨æ¨¡çµ„ç›¸ä¾
```dart
// èˆ‡ AM æ¨¡çµ„æ•´åˆ
import 'package:lcas_business_layer/modules/am.dart';

// èˆ‡ FS æ¨¡çµ„æ•´åˆ
import 'package:lcas_business_layer/modules/fs.dart';

// èˆ‡ DL æ¨¡çµ„æ•´åˆ
import 'package:lcas_business_layer/modules/dl.dart';
```

### 11.4 å‘å¾Œç›¸å®¹æ€§ä¿è­‰

#### 11.4.1 API ç‰ˆæœ¬ç›¸å®¹
```dart
class AuthServiceVersionManager {
  static const String CURRENT_VERSION = 'v1.0.0';
  static const List<String> SUPPORTED_VERSIONS = ['v1.0.0'];
  
  static bool isVersionSupported(String version) {
    return SUPPORTED_VERSIONS.contains(version);
  }
  
  static AuthService createService(String version) {
    switch (version) {
      case 'v1.0.0':
        return AuthServiceV1();
      default:
        throw UnsupportedError('Unsupported version: $version');
    }
  }
}
```

#### 11.4.2 è³‡æ–™é·ç§»ç­–ç•¥
```dart
class AuthDataMigration {
  static Future<void> migrateToV1() async {
    // æª¢æŸ¥æ˜¯å¦éœ€è¦é·ç§»
    final currentVersion = await _getCurrentDataVersion();
    if (currentVersion == 'v1.0.0') return;
    
    // åŸ·è¡Œè³‡æ–™é·ç§»
    await _migrateTokenStorage();
    await _migrateUserPreferences();
    await _updateDataVersion('v1.0.0');
  }
  
  static Future<void> _migrateTokenStorage() async {
    // é·ç§» Token å„²å­˜æ ¼å¼
  }
  
  static Future<void> _migrateUserPreferences() async {
    // é·ç§»ä½¿ç”¨è€…åå¥½è¨­å®š
  }
}
```

---

## æ–‡ä»¶ç¶­è­·è¨˜éŒ„

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹è€… | ä¿®æ”¹å…§å®¹ |
|------|------|--------|----------|
| **v1.0.0** | **2025-01-26** | **LCAS SA Team** | **åˆç‰ˆå»ºç«‹ï¼šå®Œæ•´èªè­‰æœå‹™ SRS æ–‡ä»¶ï¼ŒåŒ…å« 5 å€‹ API ç«¯é»è¦æ ¼ã€å››æ¨¡å¼å·®ç•°åŒ–æ”¯æ´ã€å®‰å…¨æ©Ÿåˆ¶ã€Flutter UI æ•´åˆã€æ¸¬è©¦è¨ˆç•«ç­‰** |

---

## å‚™è¨»

- **ç‰ˆæœ¬1.0.0ç‰¹è‰²**: å…¨æ–°çš„ Flutter èªè­‰æœå‹™æ¨¡çµ„ï¼Œæ”¯æ´å››ç¨®ä½¿ç”¨è€…æ¨¡å¼å·®ç•°åŒ–
- **5å€‹APIç«¯é»**: F001-F005 å®Œæ•´çš„èªè­‰ç®¡ç†åŠŸèƒ½ï¼ˆè¨»å†Šã€ç™»å…¥ã€ç™»å‡ºã€åˆªé™¤ã€é‡è¨­å¯†ç¢¼ï¼‰
- **å®‰å…¨æ©Ÿåˆ¶**: JWT Token ç®¡ç†ã€é˜²é‡æ”¾æ”»æ“Šã€åŠ å¯†å„²å­˜ã€é€Ÿç‡é™åˆ¶
- **å››æ¨¡å¼æ”¯æ´**: Controller/Logger/Struggler/Sleeper å·®ç•°åŒ–èªè­‰ç­–ç•¥
- **Flutteræ•´åˆ**: Provider/Riverpod ç‹€æ…‹ç®¡ç†ã€UI å…ƒä»¶ã€è·¯ç”±å®ˆè¡›
- **æ¸¬è©¦å®Œæ•´**: å–®å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦ã€æ•ˆèƒ½æ¸¬è©¦ã€å®‰å…¨æ€§æ¸¬è©¦
- **ç›¸ä¾æ¨¡çµ„**: èˆ‡ AM æ¨¡çµ„ v1.1.1ã€FS æ¨¡çµ„ã€DL æ¨¡çµ„æ•´åˆ
- **æŠ€è¡“å¯¦ä½œ**: ä½¿ç”¨ LINE SDKã€Flutter Secure Storageã€Crypto Library
- **é–‹ç™¼è¨ˆç•«**: 10é€±é–‹ç™¼é€±æœŸï¼Œ5å€‹éšæ®µæ¼¸é€²å¼å¯¦ä½œ
- **å‘å¾Œç›¸å®¹**: ç‰ˆæœ¬ç®¡ç†ã€è³‡æ–™é·ç§»ã€API ç›¸å®¹æ€§ä¿è­‰
