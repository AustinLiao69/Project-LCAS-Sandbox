
// Mocks generated by Mockito 5.4.0 from annotations
// in apl_tests/8501. 認證服務_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i2;
import 'package:mockito/mockito.dart' as _i1;

// Mock classes for authentication services
class MockAuthService extends _i1.Mock {
  MockAuthService() {
    _i1.throwOnMissingStub(this);
  }

  _i2.Future<RegisterResult> processRegistration(RegisterRequest request) =>
      (super.noSuchMethod(
        Invocation.method(#processRegistration, [request]),
        returnValue: _i2.Future<RegisterResult>.value(
          RegisterResult(userId: '', success: false),
        ),
      ) as _i2.Future<RegisterResult>);

  _i2.Future<LoginResult> authenticateUser(String email, String password) =>
      (super.noSuchMethod(
        Invocation.method(#authenticateUser, [email, password]),
        returnValue: _i2.Future<LoginResult>.value(
          LoginResult(success: false),
        ),
      ) as _i2.Future<LoginResult>);

  _i2.Future<void> processLogout(LogoutRequest request) =>
      (super.noSuchMethod(
        Invocation.method(#processLogout, [request]),
        returnValue: _i2.Future<void>.value(),
      ) as _i2.Future<void>);

  _i2.Future<void> initiateForgotPassword(String email) =>
      (super.noSuchMethod(
        Invocation.method(#initiateForgotPassword, [email]),
        returnValue: _i2.Future<void>.value(),
      ) as _i2.Future<void>);

  _i2.Future<ResetTokenValidation> validateResetToken(String token) =>
      (super.noSuchMethod(
        Invocation.method(#validateResetToken, [token]),
        returnValue: _i2.Future<ResetTokenValidation>.value(
          ResetTokenValidation(isValid: false, email: ''),
        ),
      ) as _i2.Future<ResetTokenValidation>);

  _i2.Future<void> executePasswordReset(String token, String newPassword) =>
      (super.noSuchMethod(
        Invocation.method(#executePasswordReset, [token, newPassword]),
        returnValue: _i2.Future<void>.value(),
      ) as _i2.Future<void>);

  _i2.Future<void> processEmailVerification(String email, String code) =>
      (super.noSuchMethod(
        Invocation.method(#processEmailVerification, [email, code]),
        returnValue: _i2.Future<void>.value(),
      ) as _i2.Future<void>);
}

class MockTokenService extends _i1.Mock {
  MockTokenService() {
    _i1.throwOnMissingStub(this);
  }

  _i2.Future<TokenPair> generateTokenPair(String userId, UserMode userMode) =>
      (super.noSuchMethod(
        Invocation.method(#generateTokenPair, [userId, userMode]),
        returnValue: _i2.Future<TokenPair>.value(
          TokenPair(
            accessToken: 'mock-token',
            refreshToken: 'mock-refresh',
            expiresAt: DateTime.now().add(Duration(hours: 1)),
          ),
        ),
      ) as _i2.Future<TokenPair>);

  _i2.Future<TokenValidationResult> validateRefreshToken(String token) =>
      (super.noSuchMethod(
        Invocation.method(#validateRefreshToken, [token]),
        returnValue: _i2.Future<TokenValidationResult>.value(
          TokenValidationResult(isValid: false),
        ),
      ) as _i2.Future<TokenValidationResult>);
}

class MockUserModeAdapter extends _i1.Mock {
  MockUserModeAdapter() {
    _i1.throwOnMissingStub(this);
  }

  RegisterResponse adaptRegisterResponse(RegisterResult result, UserMode mode) =>
      (super.noSuchMethod(
        Invocation.method(#adaptRegisterResponse, [result, mode]),
        returnValue: RegisterResponse(
          userId: '',
          email: '',
          userMode: mode,
          verificationSent: false,
          needsAssessment: false,
          token: '',
          refreshToken: '',
          expiresAt: DateTime.now(),
        ),
      ) as RegisterResponse);

  LoginResponse adaptLoginResponse(LoginResult result, UserMode mode) =>
      (super.noSuchMethod(
        Invocation.method(#adaptLoginResponse, [result, mode]),
        returnValue: LoginResponse(
          token: '',
          refreshToken: '',
          expiresAt: DateTime.now(),
          user: UserProfile(
            id: '',
            email: '',
            displayName: '',
            userMode: mode,
            createdAt: DateTime.now(),
          ),
        ),
      ) as LoginResponse);
}

class MockSecurityService extends _i1.Mock {
  MockSecurityService() {
    _i1.throwOnMissingStub(this);
  }

  bool isPasswordSecure(String password) => (super.noSuchMethod(
        Invocation.method(#isPasswordSecure, [password]),
        returnValue: true,
      ) as bool);

  _i2.Future<bool> verifyPassword(String password, String hash) =>
      (super.noSuchMethod(
        Invocation.method(#verifyPassword, [password, hash]),
        returnValue: _i2.Future<bool>.value(true),
      ) as _i2.Future<bool>);

  _i2.Future<String> hashPassword(String password) => (super.noSuchMethod(
        Invocation.method(#hashPassword, [password]),
        returnValue: _i2.Future<String>.value('hashed-password'),
      ) as _i2.Future<String>);

  _i2.Future<String> generateSecureToken() => (super.noSuchMethod(
        Invocation.method(#generateSecureToken, []),
        returnValue: _i2.Future<String>.value('secure-token'),
      ) as _i2.Future<String>);

  bool validateTokenFormat(String token) => (super.noSuchMethod(
        Invocation.method(#validateTokenFormat, [token]),
        returnValue: true,
      ) as bool);
}

class MockValidationService extends _i1.Mock {
  MockValidationService() {
    _i1.throwOnMissingStub(this);
  }

  List<ValidationError> validateRegisterRequest(RegisterRequest request) =>
      (super.noSuchMethod(
        Invocation.method(#validateRegisterRequest, [request]),
        returnValue: <ValidationError>[],
      ) as List<ValidationError>);
}

class MockErrorHandler extends _i1.Mock {
  MockErrorHandler() {
    _i1.throwOnMissingStub(this);
  }

  ApiError createValidationError(List<ValidationError> errors, UserMode mode) =>
      (super.noSuchMethod(
        Invocation.method(#createValidationError, [errors, mode]),
        returnValue: ApiError.create(AuthErrorCode.validationError, mode),
      ) as ApiError);
}

class MockModeConfigService extends _i1.Mock {
  MockModeConfigService() {
    _i1.throwOnMissingStub(this);
  }

  ModeConfig getConfigForMode(UserMode mode) => (super.noSuchMethod(
        Invocation.method(#getConfigForMode, [mode]),
        returnValue: ModeConfig(
          mode: mode,
          settings: {},
          features: [],
        ),
      ) as ModeConfig);

  bool isFeatureEnabled(UserMode mode, String feature) => (super.noSuchMethod(
        Invocation.method(#isFeatureEnabled, [mode, feature]),
        returnValue: true,
      ) as bool);
}

class MockResponseFilter extends _i1.Mock {
  MockResponseFilter() {
    _i1.throwOnMissingStub(this);
  }

  Map<String, dynamic> filterForExpert(Map<String, dynamic> data) =>
      (super.noSuchMethod(
        Invocation.method(#filterForExpert, [data]),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);

  Map<String, dynamic> filterForInertial(Map<String, dynamic> data) =>
      (super.noSuchMethod(
        Invocation.method(#filterForInertial, [data]),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);

  Map<String, dynamic> filterForCultivation(Map<String, dynamic> data) =>
      (super.noSuchMethod(
        Invocation.method(#filterForCultivation, [data]),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);

  Map<String, dynamic> filterForGuiding(Map<String, dynamic> data) =>
      (super.noSuchMethod(
        Invocation.method(#filterForGuiding, [data]),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);
}

class MockJwtProvider extends _i1.Mock {
  MockJwtProvider() {
    _i1.throwOnMissingStub(this);
  }

  String generateToken(Map<String, dynamic> payload, Duration duration) =>
      (super.noSuchMethod(
        Invocation.method(#generateToken, [payload, duration]),
        returnValue: 'mock-jwt-token',
      ) as String);

  Map<String, dynamic> verifyToken(String token) => (super.noSuchMethod(
        Invocation.method(#verifyToken, [token]),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);
}

// Additional classes for testing
class RegisterResult {
  final String userId;
  final bool success;
  final String? errorMessage;

  RegisterResult({
    required this.userId,
    required this.success,
    this.errorMessage,
  });
}

class LoginResult {
  final UserProfile? user;
  final bool success;
  final String? errorMessage;

  LoginResult({
    this.user,
    required this.success,
    this.errorMessage,
  });
}

class TokenPair {
  final String accessToken;
  final String refreshToken;
  final DateTime expiresAt;

  TokenPair({
    required this.accessToken,
    required this.refreshToken,
    required this.expiresAt,
  });
}

class TokenValidationResult {
  final bool isValid;
  final String? userId;
  final UserMode? userMode;
  final String? reason;

  TokenValidationResult({
    required this.isValid,
    this.userId,
    this.userMode,
    this.reason,
  });
}

class ResetTokenValidation {
  final bool isValid;
  final String email;
  final DateTime? expiresAt;

  ResetTokenValidation({
    required this.isValid,
    required this.email,
    this.expiresAt,
  });
}

class ValidationError {
  final String field;
  final String message;
  final String? value;

  ValidationError({
    required this.field,
    required this.message,
    this.value,
  });
}

class ModeConfig {
  final UserMode mode;
  final Map<String, dynamic> settings;
  final List<String> features;

  ModeConfig({
    required this.mode,
    required this.settings,
    required this.features,
  });
}

// Enum and base classes
enum UserMode { expert, inertial, cultivation, guiding }

enum AuthErrorCode {
  validationError,
  emailAlreadyExists,
  invalidCredentials,
  tokenInvalid,
  tokenExpired,
  weakPassword,
  invalidResetToken,
  internalServerError,
}

extension AuthErrorCodeMessages on AuthErrorCode {
  String getMessage(UserMode mode) {
    switch (this) {
      case AuthErrorCode.validationError:
        switch (mode) {
          case UserMode.expert:
            return '請求參數驗證失敗，請檢查資料格式與完整性';
          case UserMode.inertial:
            return '資料格式驗證失敗，請確認輸入內容';
          case UserMode.cultivation:
            return '輸入資料需要調整，讓我們一起完善它！';
          case UserMode.guiding:
            return '資料格式錯誤';
        }
      case AuthErrorCode.emailAlreadyExists:
        return 'Email已存在';
      case AuthErrorCode.invalidCredentials:
        return '無效的登入憑證';
      case AuthErrorCode.weakPassword:
        return '密碼強度不足';
      default:
        return '未知錯誤';
    }
  }
}

class ApiError {
  final AuthErrorCode code;
  final String message;
  final String? field;
  final Map<String, dynamic>? details;

  ApiError({
    required this.code,
    required this.message,
    this.field,
    this.details,
  });

  static ApiError create(AuthErrorCode code, UserMode mode, {
    String? field,
    List<ValidationError>? validationErrors,
  }) {
    return ApiError(
      code: code,
      message: code.getMessage(mode),
      field: field,
      details: validationErrors != null ? {'validation': validationErrors} : null,
    );
  }
}
