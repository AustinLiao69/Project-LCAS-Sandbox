# SRS_InfrastructureService_åŸºç¤è¨­æ–½_v1.0.0

**æ–‡ä»¶ç·¨è™Ÿ**: 8900  
**ç‰ˆæœ¬**: 1.0.0  
**å»ºç«‹æ—¥æœŸ**: 2025-08-02  
**å»ºç«‹è€…**: LCAS SA Team  
**æœ€å¾Œæ›´æ–°**: 2025-08-02 08:00:00 UTC+8

---

## ç›®æ¬¡

1. [æ¨¡çµ„æ¦‚è¿°](#10-æ¨¡çµ„æ¦‚è¿°module-overview)
2. [åŸºç¤è¨­æ–½æœå‹™ç°¡ä»‹](#20-åŸºç¤è¨­æ–½æœå‹™ç°¡ä»‹infrastructure-service-introduction)
3. [APIç«¯é»è¦æ ¼](#30-apiç«¯é»è¦æ ¼api-endpoints-specification)
4. [InfrastructureServiceå¯¦ä½œ](#40-infrastructureserviceå¯¦ä½œinfrastructure-service-implementation)
5. [èˆ‡å…¶ä»–æœå‹™çš„æ•´åˆ](#50-èˆ‡å…¶ä»–æœå‹™çš„æ•´åˆintegration-with-other-services)

---

## 1.0 æ¨¡çµ„æ¦‚è¿°ï¼ˆModule Overviewï¼‰

### 1.1 ç”¢å“å®šä½
InfrastructureService åŸºç¤è¨­æ–½æœå‹™æ˜¯ LCAS 2.0 Flutter AP Layer çš„ç¬¬8å€‹æ ¸å¿ƒæœå‹™æ¨¡çµ„ï¼Œè² è²¬è™•ç†8å€‹åŸºç¤è¨­æ–½APIç«¯é»ï¼Œç‚ºå…¶ä»–7å€‹æœå‹™æ¨¡çµ„æä¾›çµ±ä¸€çš„åŸºç¤è¨­æ–½æ”¯æ’æœå‹™ã€‚

### 1.2 æ ¸å¿ƒè·è²¬
- **APIå®¢æˆ¶ç«¯ç®¡ç†**: çµ±ä¸€HTTPå®¢æˆ¶ç«¯é…ç½®èˆ‡è«‹æ±‚æ””æˆªå™¨
- **å¿«å–ç­–ç•¥ç®¡ç†**: å¤šå±¤æ¬¡å¿«å–æ¶æ§‹èˆ‡æ™ºæ…§å¿«å–ç­–ç•¥
- **éŒ¯èª¤è™•ç†æ¡†æ¶**: çµ±ä¸€éŒ¯èª¤åˆ†é¡ã€æœ¬åœ°åŒ–èˆ‡é‡è©¦æ©Ÿåˆ¶
- **å®‰å…¨èˆ‡èªè­‰åŸºç¤**: Tokenç®¡ç†ã€åŠ å¯†è§£å¯†ã€æ¬Šé™é©—è­‰
- **æ—¥èªŒèˆ‡ç›£æ§**: çµæ§‹åŒ–æ—¥èªŒè¨˜éŒ„èˆ‡æ•ˆèƒ½ç›£æ§
- **ä¾è³´æ³¨å…¥å®¹å™¨**: æœå‹™è¨»å†Šã€ç”Ÿå‘½é€±æœŸç®¡ç†èˆ‡ä¾è³´è§£æ
- **é…ç½®ç®¡ç†**: ç’°å¢ƒé…ç½®ã€åŠŸèƒ½é–‹é—œèˆ‡å‹•æ…‹é…ç½®
- **æ•ˆèƒ½å„ªåŒ–å·¥å…·**: è«‹æ±‚å„ªåŒ–ã€è³‡æºç®¡ç†èˆ‡æ•ˆèƒ½åˆ†æ

### 1.3 æœå‹™æ¶æ§‹å®šä½
```
LCAS 2.0 Flutter AP Layer - 8å¤§æœå‹™æ¨¡çµ„æ¶æ§‹
â”œâ”€â”€ ğŸ“ AuthService (8901) - èªè­‰æœå‹™ â†’ ä¾è³´ InfrastructureService
â”œâ”€â”€ ğŸ“ EntryService (8902) - åŸºç¤è¨˜å¸³ â†’ ä¾è³´ InfrastructureService
â”œâ”€â”€ ğŸ“Š ProjectLedgerService (8903) - å¤šå¸³æœ¬ç®¡ç† â†’ ä¾è³´ InfrastructureService
â”œâ”€â”€ ğŸ’° BudgetService (8904) - é ç®—ç®¡ç† â†’ ä¾è³´ InfrastructureService
â”œâ”€â”€ ğŸ¤ CollaborationService (8905) - å”ä½œåŠŸèƒ½ â†’ ä¾è³´ InfrastructureService
â”œâ”€â”€ ğŸ“ˆ ReportService (8906) - å ±è¡¨åŠŸèƒ½ â†’ ä¾è³´ InfrastructureService
â”œâ”€â”€ ğŸ”§ SystemService (8907) - ç³»çµ±ç®¡ç† â†’ ä¾è³´ InfrastructureService
â””â”€â”€ ğŸ—ï¸ InfrastructureService (8900) - åŸºç¤è¨­æ–½ â˜… åŸºç¤æœå‹™æä¾›è€… â˜…
    â”œâ”€â”€ I001: APIå®¢æˆ¶ç«¯ç®¡ç†
    â”œâ”€â”€ I002: å¿«å–ç­–ç•¥ç®¡ç†  
    â”œâ”€â”€ I003: éŒ¯èª¤è™•ç†æ¡†æ¶
    â”œâ”€â”€ I004: å®‰å…¨èˆ‡èªè­‰åŸºç¤
    â”œâ”€â”€ I005: æ—¥èªŒèˆ‡ç›£æ§
    â”œâ”€â”€ I006: ä¾è³´æ³¨å…¥å®¹å™¨
    â”œâ”€â”€ I007: é…ç½®ç®¡ç†
    â””â”€â”€ I008: æ•ˆèƒ½å„ªåŒ–å·¥å…·
```

---

## 2.0 åŸºç¤è¨­æ–½æœå‹™ç°¡ä»‹ï¼ˆInfrastructure Service Introductionï¼‰

### 2.1 ç›®æ¨™èˆ‡è§’è‰²
åŸºç¤è¨­æ–½æœå‹™åœ¨ LCAS 2.0 Flutter æ¶æ§‹ä¸­æä¾›åº•å±¤åŸºç¤è¨­æ–½æ”¯æ’ï¼š
- **åŸºç¤æœå‹™æä¾›è€…**: ç‚ºå…¶ä»–7å€‹æœå‹™æ¨¡çµ„æä¾›çµ±ä¸€çš„åŸºç¤è¨­æ–½åŠŸèƒ½
- **æ©«åˆ‡é—œæ³¨é»è™•ç†**: è™•ç†è·¨æœå‹™çš„å…±åŒéœ€æ±‚ï¼ˆæ—¥èªŒã€å¿«å–ã€éŒ¯èª¤è™•ç†ç­‰ï¼‰
- **æ¶æ§‹ä¸€è‡´æ€§ä¿è­‰**: ç¢ºä¿æ‰€æœ‰æœå‹™æ¨¡çµ„ä½¿ç”¨çµ±ä¸€çš„åŸºç¤è¨­æ–½æ¨™æº–

### 2.2 è¨­è¨ˆåŸå‰‡
- **å–®ä¸€è·è²¬**: æ¯å€‹åŸºç¤è¨­æ–½APIå°ˆæ³¨æ–¼ç‰¹å®šçš„åŸºç¤è¨­æ–½åŠŸèƒ½
- **é«˜å¯é‡ç”¨æ€§**: æä¾›å¯è¢«å¤šå€‹æœå‹™é‡è¤‡ä½¿ç”¨çš„åŸºç¤è¨­æ–½çµ„ä»¶
- **é…ç½®é©…å‹•**: é€éé…ç½®æª”æ¡ˆç®¡ç†ä¸åŒç’°å¢ƒçš„åŸºç¤è¨­æ–½è¨­å®š
- **æ•ˆèƒ½å„ªå…ˆ**: å„ªåŒ–åŸºç¤è¨­æ–½æ•ˆèƒ½ä»¥æ¸›å°‘å°æ¥­å‹™æœå‹™çš„å½±éŸ¿

---

## 3.0 APIç«¯é»è¦æ ¼ï¼ˆAPI Endpoints Specificationï¼‰

### 3.1 åŸºç¤è¨­æ–½ç®¡ç†APIç¾¤çµ„ï¼ˆI001-I008ï¼‰

#### 3.1.1 I001: APIå®¢æˆ¶ç«¯ç®¡ç†
**åŠŸèƒ½æè¿°**: çµ±ä¸€HTTPå®¢æˆ¶ç«¯é…ç½®èˆ‡è«‹æ±‚æ””æˆªå™¨ç®¡ç†

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST (é…ç½®) / GET (æŸ¥è©¢)
- **ç«¯é»**: `/infrastructure/api-client/config`
- **è¼¸å…¥åƒæ•¸**:
```dart
class ApiClientConfigRequest {
  final String action;                          // å‹•ä½œé¡å‹ï¼ˆå¿…å¡«ï¼‰
  final ClientConfiguration? clientConfig;      // å®¢æˆ¶ç«¯é…ç½®ï¼ˆå¯é¸ï¼‰
  final InterceptorSettings? interceptorSettings; // æ””æˆªå™¨è¨­å®šï¼ˆå¯é¸ï¼‰
  final RetryPolicy? retryPolicy;               // é‡è©¦ç­–ç•¥ï¼ˆå¯é¸ï¼‰
  final TimeoutSettings? timeoutSettings;       // è¶…æ™‚è¨­å®šï¼ˆå¯é¸ï¼‰
}

enum ApiClientAction { configure, query, reset, refresh }

class ClientConfiguration {
  final String baseUrl;                         // åŸºç¤URL
  final Map<String, String> defaultHeaders;     // é è¨­æ¨™é ­
  final String userAgent;                       // ä½¿ç”¨è€…ä»£ç†
  final bool enableLogging;                     // å•Ÿç”¨æ—¥èªŒ
  final String logLevel;                        // æ—¥èªŒç­‰ç´š
  final CertificatePinning? certificatePinning; // æ†‘è­‰å›ºå®š
}

class InterceptorSettings {
  final bool enableAuthInterceptor;             // å•Ÿç”¨èªè­‰æ””æˆªå™¨
  final bool enableCacheInterceptor;            // å•Ÿç”¨å¿«å–æ””æˆªå™¨
  final bool enableRetryInterceptor;            // å•Ÿç”¨é‡è©¦æ””æˆªå™¨
  final bool enableLoggingInterceptor;          // å•Ÿç”¨æ—¥èªŒæ””æˆªå™¨
  final List<CustomInterceptor> customInterceptors; // è‡ªè¨‚æ””æˆªå™¨
}

class CustomInterceptor {
  final String name;                            // æ””æˆªå™¨åç¨±
  final int priority;                           // å„ªå…ˆç´š
  final Map<String, dynamic> config;            // é…ç½®åƒæ•¸
}

class RetryPolicy {
  final int maxRetries;                         // æœ€å¤§é‡è©¦æ¬¡æ•¸
  final Duration initialDelay;                  // åˆå§‹å»¶é²
  final double backoffMultiplier;               // é€€é¿å€æ•¸
  final List<int> retryStatusCodes;             // é‡è©¦ç‹€æ…‹ç¢¼
  final List<String> retryExceptions;           // é‡è©¦ä¾‹å¤–
}

class TimeoutSettings {
  final Duration connectTimeout;                // é€£ç·šè¶…æ™‚
  final Duration receiveTimeout;                // æ¥æ”¶è¶…æ™‚
  final Duration sendTimeout;                   // ç™¼é€è¶…æ™‚
}

class CertificatePinning {
  final List<String> allowedSHA256Fingerprints; // å…è¨±çš„æ†‘è­‰æŒ‡ç´‹
  final bool allowBadCertificates;              // å…è¨±ç„¡æ•ˆæ†‘è­‰
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class ApiClientConfigResponse {
  final bool success;
  final String action;
  final ClientStatus clientStatus;
  final InterceptorStatus interceptorStatus;
  final PerformanceMetrics performanceMetrics;
  final List<ConfigValidation> validations;
  final String? errorMessage;
}

class ClientStatus {
  final String configurationId;                 // é…ç½®ID
  final DateTime lastConfigured;                // æœ€å¾Œé…ç½®æ™‚é–“
  final String baseUrl;                         // åŸºç¤URL
  final int activeConnections;                  // æ´»èºé€£ç·šæ•¸
  final String connectionPoolStatus;            // é€£ç·šæ± ç‹€æ…‹
  final bool isHealthy;                         // æ˜¯å¦å¥åº·
}

class InterceptorStatus {
  final int totalInterceptors;                  // ç¸½æ””æˆªå™¨æ•¸
  final List<InterceptorInfo> activeInterceptors; // æ´»èºæ””æˆªå™¨
  final Map<String, dynamic> interceptorMetrics; // æ””æˆªå™¨æŒ‡æ¨™
}

class InterceptorInfo {
  final String name;                            // æ””æˆªå™¨åç¨±
  final bool isEnabled;                         // æ˜¯å¦å•Ÿç”¨
  final int executionCount;                     // åŸ·è¡Œæ¬¡æ•¸
  final Duration averageExecutionTime;          // å¹³å‡åŸ·è¡Œæ™‚é–“
  final DateTime lastExecution;                 // æœ€å¾ŒåŸ·è¡Œæ™‚é–“
}

class PerformanceMetrics {
  final Duration averageResponseTime;           // å¹³å‡å›æ‡‰æ™‚é–“
  final int requestsPerMinute;                  // æ¯åˆ†é˜è«‹æ±‚æ•¸
  final double successRate;                     // æˆåŠŸç‡
  final int activeRequests;                     // æ´»èºè«‹æ±‚æ•¸
  final String networkUsage;                    // ç¶²è·¯ä½¿ç”¨é‡
}

class ConfigValidation {
  final String field;                           // æ¬„ä½
  final String status;                          // ç‹€æ…‹
  final String? message;                        // è¨Šæ¯
  final String? suggestion;                     // å»ºè­°
}
```

#### 3.1.2 I002: å¿«å–ç­–ç•¥ç®¡ç†
**åŠŸèƒ½æè¿°**: å¤šå±¤æ¬¡å¿«å–æ¶æ§‹èˆ‡æ™ºæ…§å¿«å–ç­–ç•¥ç®¡ç†

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: GET (æŸ¥è©¢ç‹€æ…‹) / POST (é…ç½®) / DELETE (æ¸…é™¤)
- **ç«¯é»**: `/infrastructure/cache/status`
- **è¼¸å…¥åƒæ•¸**:
```dart
class CacheManagementRequest {
  final String operation;                       // æ“ä½œé¡å‹ï¼ˆå¿…å¡«ï¼‰
  final CacheConfiguration? configuration;      // å¿«å–é…ç½®ï¼ˆå¯é¸ï¼‰
  final CacheQueryParams? queryParams;          // æŸ¥è©¢åƒæ•¸ï¼ˆå¯é¸ï¼‰
  final CacheClearParams? clearParams;          // æ¸…é™¤åƒæ•¸ï¼ˆå¯é¸ï¼‰
}

enum CacheOperation { configure, query, clear, optimize, analyze }

class CacheConfiguration {
  final Map<String, CacheLevel> cacheLevels;    // å¿«å–å±¤ç´š
  final CacheStrategy defaultStrategy;          // é è¨­ç­–ç•¥
  final ExpirationPolicy expirationPolicy;      // éæœŸç­–ç•¥
  final StorageQuota storageQuota;              // å„²å­˜é…é¡
  final CompressionSettings compressionSettings; // å£“ç¸®è¨­å®š
}

class CacheLevel {
  final String levelName;                       // å±¤ç´šåç¨±
  final CacheType cacheType;                    // å¿«å–é¡å‹
  final Duration defaultTtl;                    // é è¨­å­˜æ´»æ™‚é–“
  final int maxEntries;                         // æœ€å¤§æ¢ç›®æ•¸
  final String evictionPolicy;                  // é©…é€ç­–ç•¥
  final bool enableCompression;                 // å•Ÿç”¨å£“ç¸®
}

enum CacheType { memory, disk, hybrid, distributed }

class CacheStrategy {
  final String strategyName;                    // ç­–ç•¥åç¨±
  final List<String> applicableEndpoints;       // é©ç”¨ç«¯é»
  final Duration cacheDuration;                 // å¿«å–æœŸé–“
  final bool refreshOnAccess;                   // å­˜å–æ™‚é‡æ–°æ•´ç†
  final bool enablePrefetch;                    // å•Ÿç”¨é å–
  final ConditionalCaching conditionalCaching;  // æ¢ä»¶å¿«å–
}

class ConditionalCaching {
  final List<String> cacheHeaders;              // å¿«å–æ¨™é ­
  final List<String> invalidationTriggers;      // å¤±æ•ˆè§¸ç™¼å™¨
  final bool respectServerDirectives;           // éµå®ˆä¼ºæœå™¨æŒ‡ä»¤
}

class ExpirationPolicy {
  final String policyType;                      // ç­–ç•¥é¡å‹
  final Duration defaultExpiration;             // é è¨­éæœŸæ™‚é–“
  final Duration maxExpiration;                 // æœ€å¤§éæœŸæ™‚é–“
  final bool enableSlidingExpiration;           // å•Ÿç”¨æ»‘å‹•éæœŸ
  final List<ExpirationRule> customRules;       // è‡ªè¨‚è¦å‰‡
}

class ExpirationRule {
  final String pattern;                         // æ¨¡å¼
  final Duration expiration;                    // éæœŸæ™‚é–“
  final String? condition;                      // æ¢ä»¶
}

class StorageQuota {
  final int maxMemoryMB;                        // æœ€å¤§è¨˜æ†¶é«”MB
  final int maxDiskMB;                          // æœ€å¤§ç£ç¢ŸMB
  final double warningThreshold;                // è­¦å‘Šé–¾å€¼
  final String cleanupStrategy;                 // æ¸…ç†ç­–ç•¥
}

class CompressionSettings {
  final bool enableCompression;                 // å•Ÿç”¨å£“ç¸®
  final String compressionAlgorithm;            // å£“ç¸®æ¼”ç®—æ³•
  final int compressionLevel;                   // å£“ç¸®ç­‰ç´š
  final int minSizeForCompression;              // æœ€å°å£“ç¸®å¤§å°
}

class CacheQueryParams {
  final List<String>? cacheKeys;                // å¿«å–éµ
  final List<String>? cacheLevels;              // å¿«å–å±¤ç´š
  final String? pattern;                        // æ¨¡å¼
  final bool includeMetrics;                    // åŒ…å«æŒ‡æ¨™
}

class CacheClearParams {
  final String clearScope;                      // æ¸…é™¤ç¯„åœ
  final List<String>? specificKeys;             // ç‰¹å®šéµ
  final List<String>? patterns;                 // æ¨¡å¼
  final List<String>? cacheLevels;              // å¿«å–å±¤ç´š
  final bool forceClear;                        // å¼·åˆ¶æ¸…é™¤
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class CacheManagementResponse {
  final bool success;
  final String operation;
  final CacheStatus cacheStatus;
  final CacheMetrics cacheMetrics;
  final List<CacheLevelStatus> levelStatus;
  final CacheAnalysis? analysis;
  final List<OptimizationSuggestion> optimizationSuggestions;
  final String? errorMessage;
}

class CacheStatus {
  final bool isEnabled;                         // æ˜¯å¦å•Ÿç”¨
  final int totalLevels;                        // ç¸½å±¤ç´šæ•¸
  final String overallHealth;                   // æ•´é«”å¥åº·ç‹€æ…‹
  final DateTime lastOptimized;                 // æœ€å¾Œå„ªåŒ–æ™‚é–“
  final StorageUsage storageUsage;              // å„²å­˜ä½¿ç”¨é‡
}

class StorageUsage {
  final int usedMemoryMB;                       // å·²ä½¿ç”¨è¨˜æ†¶é«”MB
  final int usedDiskMB;                         // å·²ä½¿ç”¨ç£ç¢ŸMB
  final double memoryUtilization;               // è¨˜æ†¶é«”ä½¿ç”¨ç‡
  final double diskUtilization;                 // ç£ç¢Ÿä½¿ç”¨ç‡
}

class CacheMetrics {
  final CachePerformance performance;           // æ•ˆèƒ½æŒ‡æ¨™
  final CacheStatistics statistics;             // çµ±è¨ˆè³‡æ–™
  final CacheEffectiveness effectiveness;       // æ•ˆæœè©•ä¼°
}

class CachePerformance {
  final double hitRate;                         // å‘½ä¸­ç‡
  final double missRate;                        // æœªå‘½ä¸­ç‡
  final Duration averageAccessTime;             // å¹³å‡å­˜å–æ™‚é–“
  final int requestsPerSecond;                  // æ¯ç§’è«‹æ±‚æ•¸
  final Duration averageWriteTime;              // å¹³å‡å¯«å…¥æ™‚é–“
}

class CacheStatistics {
  final int totalRequests;                      // ç¸½è«‹æ±‚æ•¸
  final int cacheHits;                          // å¿«å–å‘½ä¸­æ•¸
  final int cacheMisses;                        // å¿«å–æœªå‘½ä¸­æ•¸
  final int evictions;                          // é©…é€æ•¸
  final int expirations;                        // éæœŸæ•¸
  final DateTime lastReset;                     // æœ€å¾Œé‡ç½®æ™‚é–“
}

class CacheEffectiveness {
  final double dataFreshnessScore;              // è³‡æ–™æ–°é®®åº¦åˆ†æ•¸
  final double storageEfficiencyScore;          // å„²å­˜æ•ˆç‡åˆ†æ•¸
  final double networkSavingsPercentage;        // ç¶²è·¯ç¯€çœç™¾åˆ†æ¯”
  final double responseTimeImprovement;         // å›æ‡‰æ™‚é–“æ”¹å–„
}

class CacheLevelStatus {
  final String levelName;                       // å±¤ç´šåç¨±
  final CacheType cacheType;                    // å¿«å–é¡å‹
  final bool isActive;                          // æ˜¯å¦æ´»èº
  final int entryCount;                         // æ¢ç›®æ•¸é‡
  final int sizeBytes;                          // å¤§å°ä½å…ƒçµ„
  final double hitRate;                         // å‘½ä¸­ç‡
  final DateTime lastAccess;                    // æœ€å¾Œå­˜å–æ™‚é–“
}

class CacheAnalysis {
  final List<AccessPattern> accessPatterns;     // å­˜å–æ¨¡å¼
  final List<HotKey> hotKeys;                   // ç†±é»éµ
  final List<ColdKey> coldKeys;                 // å†·éµ
  final TrendAnalysis trendAnalysis;            // è¶¨å‹¢åˆ†æ
}

class AccessPattern {
  final String pattern;                         // æ¨¡å¼
  final int frequency;                          // é »ç‡
  final String timeRange;                       // æ™‚é–“ç¯„åœ
  final double hitRate;                         // å‘½ä¸­ç‡
}

class HotKey {
  final String key;                             // éµ
  final int accessCount;                        // å­˜å–æ¬¡æ•¸
  final Duration averageAccessTime;             // å¹³å‡å­˜å–æ™‚é–“
  final DateTime lastAccess;                    // æœ€å¾Œå­˜å–æ™‚é–“
}

class ColdKey {
  final String key;                             // éµ
  final DateTime lastAccess;                    // æœ€å¾Œå­˜å–æ™‚é–“
  final int sizeBytes;                          // å¤§å°ä½å…ƒçµ„
  final String recommendation;                  // å»ºè­°
}

class TrendAnalysis {
  final String hitRateTrend;                    // å‘½ä¸­ç‡è¶¨å‹¢
  final String usageTrend;                      // ä½¿ç”¨è¶¨å‹¢
  final String sizeTrend;                       // å¤§å°è¶¨å‹¢
  final List<TrendPoint> trendPoints;           // è¶¨å‹¢é»
}

class TrendPoint {
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
  final Map<String, double> metrics;            // æŒ‡æ¨™
}

class OptimizationSuggestion {
  final String suggestionType;                  // å»ºè­°é¡å‹
  final String description;                     // æè¿°
  final String expectedBenefit;                 // é æœŸæ•ˆç›Š
  final int priority;                           // å„ªå…ˆç´š
  final Map<String, dynamic>? actionParams;     // è¡Œå‹•åƒæ•¸
}
```

#### 3.1.3 I003: éŒ¯èª¤è™•ç†æ¡†æ¶
**åŠŸèƒ½æè¿°**: çµ±ä¸€éŒ¯èª¤åˆ†é¡ã€æœ¬åœ°åŒ–èˆ‡é‡è©¦æ©Ÿåˆ¶ç®¡ç†

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST
- **ç«¯é»**: `/infrastructure/error/handle`
- **è¼¸å…¥åƒæ•¸**:
```dart
class ErrorHandlingRequest {
  final ErrorContext errorContext;              // éŒ¯èª¤ä¸Šä¸‹æ–‡ï¼ˆå¿…å¡«ï¼‰
  final ErrorClassification? classification;    // éŒ¯èª¤åˆ†é¡ï¼ˆå¯é¸ï¼‰
  final LocalizationSettings? localization;     // æœ¬åœ°åŒ–è¨­å®šï¼ˆå¯é¸ï¼‰
  final RetryConfiguration? retryConfig;        // é‡è©¦é…ç½®ï¼ˆå¯é¸ï¼‰
  final UserNotificationSettings? notification; // ä½¿ç”¨è€…é€šçŸ¥è¨­å®šï¼ˆå¯é¸ï¼‰
}

class ErrorContext {
  final String errorId;                         // éŒ¯èª¤ID
  final String errorType;                       // éŒ¯èª¤é¡å‹
  final String errorCode;                       // éŒ¯èª¤ä»£ç¢¼
  final String errorMessage;                    // éŒ¯èª¤è¨Šæ¯
  final String? stackTrace;                     // å †ç–Šè¿½è¹¤
  final String sourceService;                   // ä¾†æºæœå‹™
  final String sourceFunction;                  // ä¾†æºå‡½æ•¸
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
  final Map<String, dynamic> contextData;       // ä¸Šä¸‹æ–‡è³‡æ–™
  final UserContext? userContext;               // ä½¿ç”¨è€…ä¸Šä¸‹æ–‡
}

class UserContext {
  final String? userId;                         // ä½¿ç”¨è€…ID
  final String? sessionId;                      // æœƒè©±ID
  final String? deviceId;                       // è£ç½®ID
  final String? appVersion;                     // æ‡‰ç”¨ç¨‹å¼ç‰ˆæœ¬
  final String? platform;                       // å¹³å°
}

class ErrorClassification {
  final ErrorSeverity severity;                 // åš´é‡ç¨‹åº¦
  final ErrorCategory category;                 // éŒ¯èª¤é¡åˆ¥
  final bool isRecoverable;                     // æ˜¯å¦å¯æ¢å¾©
  final bool requiresUserAction;                // éœ€è¦ä½¿ç”¨è€…è¡Œå‹•
  final bool shouldLog;                         // æ˜¯å¦æ‡‰è¨˜éŒ„
  final bool shouldReport;                      // æ˜¯å¦æ‡‰å›å ±
}

enum ErrorSeverity { low, medium, high, critical }
enum ErrorCategory { network, authentication, validation, business, system, unknown }

class LocalizationSettings {
  final String locale;                          // åœ°å€è¨­å®š
  final bool enableLocalization;                // å•Ÿç”¨æœ¬åœ°åŒ–
  final String fallbackLocale;                  // å‚™ç”¨åœ°å€è¨­å®š
  final MessageTemplate? customTemplate;        // è‡ªè¨‚ç¯„æœ¬
}

class MessageTemplate {
  final String templateId;                      // ç¯„æœ¬ID
  final String titleTemplate;                   // æ¨™é¡Œç¯„æœ¬
  final String messageTemplate;                 // è¨Šæ¯ç¯„æœ¬
  final String? actionButtonText;                // è¡Œå‹•æŒ‰éˆ•æ–‡å­—
  final Map<String, String> placeholders;       // ä½”ä½ç¬¦
}

class RetryConfiguration {
  final bool enableRetry;                       // å•Ÿç”¨é‡è©¦
  final int maxRetryAttempts;                    // æœ€å¤§é‡è©¦æ¬¡æ•¸
  final Duration retryDelay;                     // é‡è©¦å»¶é²
  final double backoffMultiplier;                // é€€é¿å€æ•¸
  final List<String> retryableErrorCodes;        // å¯é‡è©¦éŒ¯èª¤ä»£ç¢¼
  final RetryStrategy retryStrategy;             // é‡è©¦ç­–ç•¥
}

enum RetryStrategy { immediate, exponentialBackoff, linearBackoff, customInterval }

class UserNotificationSettings {
  final bool showToUser;                        // é¡¯ç¤ºçµ¦ä½¿ç”¨è€…
  final NotificationType notificationType;      // é€šçŸ¥é¡å‹
  final NotificationPriority priority;          // é€šçŸ¥å„ªå…ˆç´š
  final Duration? displayDuration;              // é¡¯ç¤ºæœŸé–“
  final bool allowDismiss;                      // å…è¨±é—œé–‰
  final Map<String, dynamic>? customSettings;   // è‡ªè¨‚è¨­å®š
}

enum NotificationType { toast, dialog, snackbar, banner, silent }
enum NotificationPriority { low, normal, high, urgent }
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class ErrorHandlingResponse {
  final bool success;
  final String errorId;
  final ErrorProcessingResult processingResult;
  final LocalizedMessage localizedMessage;
  final RetryRecommendation? retryRecommendation;
  final UserActionGuidance? userActionGuidance;
  final LoggingResult loggingResult;
  final String? errorMessage;
}

class ErrorProcessingResult {
  final ErrorSeverity classifiedSeverity;       // åˆ†é¡åš´é‡ç¨‹åº¦
  final ErrorCategory classifiedCategory;       // åˆ†é¡é¡åˆ¥
  final bool wasHandled;                        // æ˜¯å¦å·²è™•ç†
  final bool wasRecovered;                      // æ˜¯å¦å·²æ¢å¾©
  final String processingStatus;                // è™•ç†ç‹€æ…‹
  final Duration processingTime;                // è™•ç†æ™‚é–“
  final LogEnrichment enrichment;               // æ—¥èªŒè±å¯ŒåŒ–
}

class LocalizedMessage {
  final String locale;                          // åœ°å€è¨­å®š
  final String title;                           // æ¨™é¡Œ
  final String message;                         // è¨Šæ¯
  final String? actionButtonText;               // è¡Œå‹•æŒ‰éˆ•æ–‡å­—
  final String? helpText;                       // èªªæ˜æ–‡å­—
  final MessageMetadata metadata;               // è¨Šæ¯å…ƒè³‡æ–™
}

class MessageMetadata {
  final String templateId;                      // ç¯„æœ¬ID
  final DateTime generatedAt;                   // ç”Ÿæˆæ™‚é–“
  final Map<String, String> appliedPlaceholders; // å¥—ç”¨çš„ä½”ä½ç¬¦
  final bool wasCustomized;                     // æ˜¯å¦è‡ªè¨‚
}

class RetryRecommendation {
  final bool shouldRetry;                       // æ˜¯å¦æ‡‰é‡è©¦
  final int suggestedAttempts;                  // å»ºè­°å˜—è©¦æ¬¡æ•¸
  final Duration suggestedDelay;                // å»ºè­°å»¶é²
  final RetryStrategy recommendedStrategy;       // å»ºè­°ç­–ç•¥
  final String? retryReason;                    // é‡è©¦åŸå› 
  final DateTime? nextRetryTime;                // ä¸‹æ¬¡é‡è©¦æ™‚é–“
}

class UserActionGuidance {
  final bool requiresUserAction;                // éœ€è¦ä½¿ç”¨è€…è¡Œå‹•
  final List<UserAction> suggestedActions;      // å»ºè­°è¡Œå‹•
  final String? helpUrl;                        // èªªæ˜URL
  final ContactInfo? contactInfo;               // è¯çµ¡è³‡è¨Š
}

class UserAction {
  final String actionId;                        // è¡Œå‹•ID
  final String actionText;                      // è¡Œå‹•æ–‡å­—
  final String actionType;                      // è¡Œå‹•é¡å‹
  final String? actionUrl;                      // è¡Œå‹•URL
  final Map<String, dynamic>? actionParams;     // è¡Œå‹•åƒæ•¸
}

class ContactInfo {
  final String? supportEmail;                   // æ”¯æ´Email
  final String? supportPhone;                   // æ”¯æ´é›»è©±
  final String? documentationUrl;               // æ–‡ä»¶URL
  final String? faqUrl;                         // FAQ URL
}

class LoggingResult {
  final bool wasLogged;                         // æ˜¯å¦å·²è¨˜éŒ„
  final String logLevel;                        // æ—¥èªŒç­‰ç´š
  final String logId;                           // æ—¥èªŒID
  final DateTime loggedAt;                      // è¨˜éŒ„æ™‚é–“
  final bool wasReported;                       // æ˜¯å¦å·²å›å ±
  final String? reportId;                       // å›å ±ID
}
```

#### 3.1.4 I004: å®‰å…¨èˆ‡èªè­‰åŸºç¤
**åŠŸèƒ½æè¿°**: Tokenç®¡ç†ã€åŠ å¯†è§£å¯†ã€æ¬Šé™é©—è­‰åŸºç¤æœå‹™

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: GET (é©—è­‰) / POST (æ“ä½œ)
- **ç«¯é»**: `/infrastructure/security/verify`
- **è¼¸å…¥åƒæ•¸**:
```dart
class SecurityOperationRequest {
  final String operationType;                   // æ“ä½œé¡å‹ï¼ˆå¿…å¡«ï¼‰
  final TokenOperation? tokenOperation;         // Tokenæ“ä½œï¼ˆå¯é¸ï¼‰
  final EncryptionOperation? encryptionOperation; // åŠ å¯†æ“ä½œï¼ˆå¯é¸ï¼‰
  final PermissionVerification? permissionVerification; // æ¬Šé™é©—è­‰ï¼ˆå¯é¸ï¼‰
  final SecurityAudit? securityAudit;           // å®‰å…¨ç¨½æ ¸ï¼ˆå¯é¸ï¼‰
}

enum SecurityOperationType { tokenManagement, encryption, permissionCheck, audit }

class TokenOperation {
  final String action;                          // å‹•ä½œ
  final TokenData? tokenData;                   // Tokenè³‡æ–™
  final TokenValidation? validation;            // Tokené©—è­‰
  final TokenRefresh? refresh;                  // Tokené‡æ–°æ•´ç†
}

enum TokenAction { validate, refresh, revoke, decode, generate }

class TokenData {
  final String token;                           // Token
  final TokenType tokenType;                    // Tokené¡å‹
  final Map<String, dynamic>? claims;           // è²æ˜
  final Duration? expirationTime;               // éæœŸæ™‚é–“
}

enum TokenType { access, refresh, id, temporary }

class TokenValidation {
  final String token;                           // Token
  final bool checkExpiration;                   // æª¢æŸ¥éæœŸ
  final bool checkSignature;                    // æª¢æŸ¥ç°½å
  final bool checkPermissions;                  // æª¢æŸ¥æ¬Šé™
  final List<String>? requiredClaims;           // å¿…è¦è²æ˜
}

class TokenRefresh {
  final String refreshToken;                    // é‡æ–°æ•´ç†Token
  final bool extendExpiration;                  // å»¶é•·éæœŸæ™‚é–“
  final Map<String, dynamic>? newClaims;        // æ–°è²æ˜
}

class EncryptionOperation {
  final String action;                          // å‹•ä½œ
  final EncryptionData? encryptionData;         // åŠ å¯†è³‡æ–™
  final DecryptionData? decryptionData;         // è§£å¯†è³‡æ–™
  final KeyManagement? keyManagement;           // é‡‘é‘°ç®¡ç†
}

enum EncryptionAction { encrypt, decrypt, generateKey, rotateKey }

class EncryptionData {
  final String plainText;                       // æ˜æ–‡
  final String algorithm;                       // æ¼”ç®—æ³•
  final String? keyId;                          // é‡‘é‘°ID
  final Map<String, dynamic>? parameters;       // åƒæ•¸
}

class DecryptionData {
  final String cipherText;                      // å¯†æ–‡
  final String algorithm;                       // æ¼”ç®—æ³•
  final String? keyId;                          // é‡‘é‘°ID
  final String? initializationVector;           // åˆå§‹åŒ–å‘é‡
}

class KeyManagement {
  final String action;                          // å‹•ä½œ
  final String? keyId;                          // é‡‘é‘°ID
  final String? keyType;                        // é‡‘é‘°é¡å‹
  final int? keySize;                           // é‡‘é‘°å¤§å°
  final DateTime? expirationDate;               // éæœŸæ—¥æœŸ
}

class PermissionVerification {
  final String userId;                          // ä½¿ç”¨è€…ID
  final String resource;                        // è³‡æº
  final String action;                          // å‹•ä½œ
  final Map<String, dynamic>? context;          // ä¸Šä¸‹æ–‡
  final List<String>? requiredRoles;            // å¿…è¦è§’è‰²
  final List<String>? requiredPermissions;      // å¿…è¦æ¬Šé™
}

class SecurityAudit {
  final String auditType;                       // ç¨½æ ¸é¡å‹
  final String? userId;                         // ä½¿ç”¨è€…ID
  final String? resource;                       // è³‡æº
  final Map<String, dynamic>? auditData;        // ç¨½æ ¸è³‡æ–™
  final bool includeHistory;                    // åŒ…å«æ­·å²
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class SecurityOperationResponse {
  final bool success;
  final String operationType;
  final TokenOperationResult? tokenResult;
  final EncryptionOperationResult? encryptionResult;
  final PermissionVerificationResult? permissionResult;
  final SecurityAuditResult? auditResult;
  final SecurityMetrics securityMetrics;
  final String? errorMessage;
}

class TokenOperationResult {
  final String action;
  final bool isValid;
  final TokenInfo? tokenInfo;
  final String? newToken;
  final String? refreshToken;
  final DateTime? expirationTime;
  final Map<String, dynamic>? decodedClaims;
  final List<String>? validationErrors;
}

class TokenInfo {
  final String tokenId;
  final TokenType tokenType;
  final String issuer;
  final String subject;
  final DateTime issuedAt;
  final DateTime expiresAt;
  final List<String> audience;
  final Map<String, dynamic> claims;
}

class EncryptionOperationResult {
  final String action;
  final bool isSuccessful;
  final String? result;                         // åŠ å¯†/è§£å¯†çµæœ
  final String? keyId;                          // é‡‘é‘°ID
  final String? algorithm;                      // æ¼”ç®—æ³•
  final Map<String, dynamic>? metadata;         // å…ƒè³‡æ–™
}

class PermissionVerificationResult {
  final bool hasPermission;
  final String userId;
  final String resource;
  final String action;
  final List<String> grantedPermissions;
  final List<String> userRoles;
  final Map<String, dynamic> permissionContext;
  final List<PermissionDenialReason>? denialReasons;
}

class PermissionDenialReason {
  final String reason;
  final String description;
  final String? suggestedAction;
}

class SecurityAuditResult {
  final String auditId;
  final String auditType;
  final DateTime auditTime;
  final List<AuditEvent> auditEvents;
  final SecurityRiskAssessment riskAssessment;
  final List<SecurityRecommendation> recommendations;
}

class AuditEvent {
  final String eventId;
  final DateTime timestamp;
  final String eventType;
  final String? userId;
  final String? resource;
  final String action;
  final Map<String, dynamic> eventData;
  final String riskLevel;
}

class SecurityRiskAssessment {
  final String overallRiskLevel;
  final List<RiskFactor> riskFactors;
  final double riskScore;
  final List<SecurityThreat> identifiedThreats;
}

class RiskFactor {
  final String factor;
  final String riskLevel;
  final double impact;
  final String description;
}

class SecurityThreat {
  final String threatId;
  final String threatType;
  final String severity;
  final String description;
  final List<string> affectedResources;
}

class SecurityRecommendation {
  final String recommendationId;
  final string type;
  final string priority;
  final string description;
  final string suggestedAction;
  final string? implementationGuide;
}

class SecurityMetrics {
  final int totalTokenValidations;
  final int failedValidations;
  final int encryptionOperations;
  final int permissionChecks;
  final DateTime lastSecurityScan;
  final String securityHealth;
}
```

#### 3.1.5 I005: æ—¥èªŒèˆ‡ç›£æ§
**åŠŸèƒ½æè¿°**: çµæ§‹åŒ–æ—¥èªŒè¨˜éŒ„èˆ‡æ•ˆèƒ½ç›£æ§æœå‹™

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: POST
- **ç«¯é»**: `/infrastructure/logging/event`
- **è¼¸å…¥åƒæ•¸**:
```dart
class LoggingRequest {
  final LogEntry logEntry;                      // æ—¥èªŒæ¢ç›®ï¼ˆå¿…å¡«ï¼‰
  final LoggingConfiguration? configuration;    // æ—¥èªŒé…ç½®ï¼ˆå¯é¸ï¼‰
  final MonitoringOptions? monitoring;          // ç›£æ§é¸é …ï¼ˆå¯é¸ï¼‰
  final PerformanceTracking? performance;       // æ•ˆèƒ½è¿½è¹¤ï¼ˆå¯é¸ï¼‰
}

class LogEntry {
  final String logId;                           // æ—¥èªŒID
  final LogLevel logLevel;                      // æ—¥èªŒç­‰ç´š
  final String message;                         // è¨Šæ¯
  final String source;                          // ä¾†æº
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
  final Map<String, dynamic> contextData;       // ä¸Šä¸‹æ–‡è³‡æ–™
  final UserContext? userContext;               // ä½¿ç”¨è€…ä¸Šä¸‹æ–‡
  final String? correlationId;                  // é—œè¯ID
  final String? sessionId;                      // æœƒè©±ID
  final List<String>? tags;                     // æ¨™ç±¤
}

enum LogLevel { trace, debug, info, warn, error, fatal }

class LoggingConfiguration {
  final List<LogLevel> enabledLevels;           // å•Ÿç”¨ç­‰ç´š
  final List<String> enabledSources;            // å•Ÿç”¨ä¾†æº
  final LogFormat logFormat;                    // æ—¥èªŒæ ¼å¼
  final LogOutput logOutput;                    // æ—¥èªŒè¼¸å‡º
  final bool enableStructuredLogging;           // å•Ÿç”¨çµæ§‹åŒ–æ—¥èªŒ
  final PrivacySettings privacySettings;        // éš±ç§è¨­å®š
}

enum LogFormat { json, plainText, structured }
enum LogOutput { console, file, remote, multiple }

class PrivacySettings {
  final bool enableDataMasking;                 // å•Ÿç”¨è³‡æ–™é®ç½©
  final List<String> sensitiveFields;           // æ•æ„Ÿæ¬„ä½
  final String maskingStrategy;                 // é®ç½©ç­–ç•¥
  final bool enablePiiDetection;                // å•Ÿç”¨PIIæª¢æ¸¬
}

class MonitoringOptions {
  final bool enableMetricsCollection;           // å•Ÿç”¨æŒ‡æ¨™æ”¶é›†
  final MetricsConfiguration metricsConfig;     // æŒ‡æ¨™é…ç½®
  final AlertConfiguration alertConfig;         // è­¦ç¤ºé…ç½®
  final bool enableHealthChecks;                // å•Ÿç”¨å¥åº·æª¢æŸ¥
}

class MetricsConfiguration {
  final List<String> metricTypes;               // æŒ‡æ¨™é¡å‹
  final Duration samplingInterval;              // æ¡æ¨£é–“éš”
  final int retentionDays;                      // ä¿ç•™å¤©æ•¸
  final AggregationSettings aggregation;        // èšåˆè¨­å®š
}

class AggregationSettings {
  final List<string> aggregationMethods;        // èšåˆæ–¹æ³•
  final Duration aggregationWindow;             // èšåˆè¦–çª—
  final bool enableRealTimeAggregation;         // å•Ÿç”¨å³æ™‚èšåˆ
}

class AlertConfiguration {
  final List<AlertRule> alertRules;             // è­¦ç¤ºè¦å‰‡
  final NotificationSettings notifications;     // é€šçŸ¥è¨­å®š
  final bool enableEscalation;                  // å•Ÿç”¨å‡ç´š
}

class AlertRule {
  final String ruleId;                          // è¦å‰‡ID
  final String ruleName;                        // è¦å‰‡åç¨±
  final String condition;                       // æ¢ä»¶
  final String threshold;                       // é–¾å€¼
  final Duration evaluationWindow;              // è©•ä¼°è¦–çª—
  final AlertSeverity severity;                 // åš´é‡ç¨‹åº¦
}

enum AlertSeverity { low, medium, high, critical }

class NotificationSettings {
  final List<NotificationChannel> channels;     // é€šçŸ¥ç®¡é“
  final bool enableBatching;                    // å•Ÿç”¨æ‰¹æ¬¡è™•ç†
  final Duration batchWindow;                   // æ‰¹æ¬¡è¦–çª—
  final bool enableThrottling;                  // å•Ÿç”¨ç¯€æµ
}

class NotificationChannel {
  final String channelType;                     // ç®¡é“é¡å‹
  final Map<string, dynamic> channelConfig;     // ç®¡é“é…ç½®
  final bool isEnabled;                         // æ˜¯å¦å•Ÿç”¨
}

class PerformanceTracking {
  final bool enablePerformanceLogging;          // å•Ÿç”¨æ•ˆèƒ½æ—¥èªŒ
  final List<PerformanceMetric> trackedMetrics; // è¿½è¹¤æŒ‡æ¨™
  final SamplingConfiguration sampling;         // æ¡æ¨£é…ç½®
  final bool enableDistributedTracing;          // å•Ÿç”¨åˆ†æ•£å¼è¿½è¹¤
}

class PerformanceMetric {
  final String metricName;                      // æŒ‡æ¨™åç¨±
  final String metricType;                      // æŒ‡æ¨™é¡å‹
  final Map<string, dynamic> metricConfig;      // æŒ‡æ¨™é…ç½®
}

class SamplingConfiguration {
  final double samplingRate;                    // æ¡æ¨£ç‡
  final string samplingStrategy;                // æ¡æ¨£ç­–ç•¥
  final Map<string, dynamic> strategyConfig;    // ç­–ç•¥é…ç½®
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class LoggingResponse {
  final bool success;
  final String logId;
  final LogProcessingResult processingResult;
  final MonitoringResult? monitoringResult;
  final PerformanceResult? performanceResult;
  final LoggingMetrics loggingMetrics;
  final String? errorMessage;
}

class LogProcessingResult {
  final bool wasProcessed;                      // æ˜¯å¦å·²è™•ç†
  final bool wasStored;                         // æ˜¯å¦å·²å„²å­˜
  final bool wasFiltered;                       // æ˜¯å¦å·²ç¯©é¸
  final DateTime processedAt;                   // è™•ç†æ™‚é–“
  final Duration processingTime;                // è™•ç†æœŸé–“
  final LogEnrichment enrichment;               // æ—¥èªŒè±å¯ŒåŒ–
}

class LogEnrichment {
  final Map<String, dynamic> addedFields;       // æ–°å¢æ¬„ä½
  final List<String> appliedTags;               // å¥—ç”¨æ¨™ç±¤
  final String? geolocation;                    // åœ°ç†ä½ç½®
  final String? userAgent;                      // ä½¿ç”¨è€…ä»£ç†
  final Map<String, dynamic> systemInfo;        // ç³»çµ±è³‡è¨Š
}

class MonitoringResult {
  final List<TriggeredAlert> triggeredAlerts;   // è§¸ç™¼è­¦ç¤º
  final List<MetricUpdate> metricUpdates;       // æŒ‡æ¨™æ›´æ–°
  final HealthCheckResult healthCheck;          // å¥åº·æª¢æŸ¥çµæœ
  final AnomalyDetection? anomalyDetection;     // ç•°å¸¸æª¢æ¸¬
}

class TriggeredAlert {
  final String alertId;                         // è­¦ç¤ºID
  final String ruleId;                          // è¦å‰‡ID
  final AlertSeverity severity;                 // åš´é‡ç¨‹åº¦
  final String alertMessage;                    // è­¦ç¤ºè¨Šæ¯
  final DateTime triggeredAt;                   // è§¸ç™¼æ™‚é–“
  final NotificationResult notificationResult;  // é€šçŸ¥çµæœ
}

class NotificationResult {
  final List<ChannelResult> channelResults;     // ç®¡é“çµæœ
  final bool allNotificationsSent;              // æ˜¯å¦æ‰€æœ‰é€šçŸ¥å·²ç™¼é€
  final Duration totalNotificationTime;         // ç¸½é€šçŸ¥æ™‚é–“
}

class ChannelResult {
  final String channelType;                     // ç®¡é“é¡å‹
  final bool wasSuccessful;                     // æ˜¯å¦æˆåŠŸ
  final String? errorMessage;                   // éŒ¯èª¤è¨Šæ¯
  final DateTime sentAt;                        // ç™¼é€æ™‚é–“
}

class MetricUpdate {
  final String metricName;                      // æŒ‡æ¨™åç¨±
  final double value;                           // å€¼
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
  final Map<String, string> labels;             // æ¨™ç±¤
  final string aggregationType;                 // èšåˆé¡å‹
}

class HealthCheckResult {
  final String overallHealth;                   // æ•´é«”å¥åº·ç‹€æ…‹
  final List<ComponentHealth> componentHealth;  // å…ƒä»¶å¥åº·ç‹€æ…‹
  final DateTime lastCheck;                     // æœ€å¾Œæª¢æŸ¥æ™‚é–“
  final Duration checkDuration;                 // æª¢æŸ¥æœŸé–“
}

class ComponentHealth {
  final String componentName;                   // å…ƒä»¶åç¨±
  final string healthStatus;                    // å¥åº·ç‹€æ…‹
  final string? statusMessage;                  // ç‹€æ…‹è¨Šæ¯
  final Map<string, dynamic> metrics;           // æŒ‡æ¨™
}

class AnomalyDetection {
  final List<DetectedAnomaly> detectedAnomalies; // æª¢æ¸¬åˆ°çš„ç•°å¸¸
  final AnomalyAnalysis analysis;               // ç•°å¸¸åˆ†æ
  final List<AnomalyRecommendation> recommendations; // ç•°å¸¸å»ºè­°
}

class DetectedAnomaly {
  final String anomalyId;                       // ç•°å¸¸ID
  final String anomalyType;                     // ç•°å¸¸é¡å‹
  final string severity;                        // åš´é‡ç¨‹åº¦
  final string description;                     // æè¿°
  final DateTime detectedAt;                    // æª¢æ¸¬æ™‚é–“
  final Map<string, dynamic> anomalyData;       // ç•°å¸¸è³‡æ–™
}

class AnomalyAnalysis {
  final string analysisMethod;                  // åˆ†ææ–¹æ³•
  final double confidenceScore;                 // ä¿¡å¿ƒåˆ†æ•¸
  final string pattern;                         // æ¨¡å¼
  final List<string> contributingFactors;       // è²¢ç»å› ç´ 
}

class AnomalyRecommendation {
  final string recommendationType;              // å»ºè­°é¡å‹
  final string description;                     // æè¿°
  final string suggestedAction;                 // å»ºè­°è¡Œå‹•
  final int priority;                           // å„ªå…ˆç´š
}

class PerformanceResult {
  final List<PerformanceMeasurement> measurements; // æ•ˆèƒ½æ¸¬é‡
  final PerformanceAnalysis analysis;           // æ•ˆèƒ½åˆ†æ
  final List<PerformanceOptimization> optimizations; // æ•ˆèƒ½å„ªåŒ–
}

class PerformanceMeasurement {
  final String metricName;                      // æŒ‡æ¨™åç¨±
  final double value;                           // å€¼
  final string unit;                            // å–®ä½
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
  final Map<string, string> tags;               // æ¨™ç±¤
}

class PerformanceAnalysis {
  final string performanceTrend;                // æ•ˆèƒ½è¶¨å‹¢
  final List<PerformanceBottleneck> bottlenecks; // æ•ˆèƒ½ç“¶é ¸
  final PerformanceBenchmark benchmark;         // æ•ˆèƒ½åŸºæº–
}

class PerformanceBottleneck {
  final string bottleneckType;                  // ç“¶é ¸é¡å‹
  final string location;                        // ä½ç½®
  final double impact;                          // å½±éŸ¿
  final string description;                     // æè¿°
}

class PerformanceBenchmark {
  final double baselineValue;                   // åŸºæº–å€¼
  final double currentValue;                    // ç›®å‰å€¼
  final double percentageChange;                // è®ŠåŒ–ç™¾åˆ†æ¯”
  final string comparisonResult;                // æ¯”è¼ƒçµæœ
}

class PerformanceOptimization {
  final string optimizationType;                // å„ªåŒ–é¡å‹
  final string description;                     // æè¿°
  final double expectedImprovement;             // é æœŸæ”¹å–„
  final int implementationComplexity;           // å¯¦ä½œè¤‡é›œåº¦
}

class LoggingMetrics {
  final int totalLogsProcessed;                 // ç¸½è™•ç†æ—¥èªŒæ•¸
  final int logsPerSecond;                      // æ¯ç§’æ—¥èªŒæ•¸
  final Duration averageProcessingTime;         // å¹³å‡è™•ç†æ™‚é–“
  final int errorCount;                         // éŒ¯èª¤æ•¸é‡
  final int warningCount;                       // è­¦å‘Šæ•¸é‡
  final DateTime lastLogTime;                   // æœ€å¾Œæ—¥èªŒæ™‚é–“
}
```

#### 3.1.6 I006: ä¾è³´æ³¨å…¥å®¹å™¨
**åŠŸèƒ½æè¿°**: æœå‹™è¨»å†Šã€ç”Ÿå‘½é€±æœŸç®¡ç†èˆ‡ä¾è³´è§£ææœå‹™

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: GET
- **ç«¯é»**: `/infrastructure/di/services`
- **è¼¸å…¥åƒæ•¸**:
```dart
class DependencyInjectionRequest {
  final String operation;                       // æ“ä½œé¡å‹ï¼ˆå¿…å¡«ï¼‰
  final ServiceRegistration? serviceRegistration; // æœå‹™è¨»å†Šï¼ˆå¯é¸ï¼‰
  final ServiceResolution? serviceResolution;   // æœå‹™è§£æï¼ˆå¯é¸ï¼‰
  final LifecycleManagement? lifecycleManagement; // ç”Ÿå‘½é€±æœŸç®¡ç†ï¼ˆå¯é¸ï¼‰
  final ContainerConfiguration? containerConfig; // å®¹å™¨é…ç½®ï¼ˆå¯é¸ï¼‰
}

enum DIOperation { register, resolve, configure, query, lifecycle }

class ServiceRegistration {
  final String serviceId;                       // æœå‹™ID
  final String serviceName;                     // æœå‹™åç¨±
  final String serviceType;                     // æœå‹™é¡å‹
  final ServiceLifetime lifetime;               // æœå‹™ç”Ÿå‘½é€±æœŸ
  final Map<String, dynamic> serviceConfig;     // æœå‹™é…ç½®
  final List<ServiceDependency> dependencies;   // ä¾è³´é—œä¿‚
  final ServiceFactory? factory;                // æœå‹™å·¥å» 
}

enum ServiceLifetime { singleton, transient, scoped, perRequest }

class ServiceDependency {
  final String dependencyId;                    // ä¾è³´ID
  final String dependencyType;                  // ä¾è³´é¡å‹
  final bool isOptional;                        // æ˜¯å¦å¯é¸
  final String? injectionPoint;                 // æ³¨å…¥é»
}

class ServiceFactory {
  final String factoryType;                     // å·¥å» é¡å‹
  final Map<String, dynamic> factoryConfig;     // å·¥å» é…ç½®
  final List<String> constructorParameters;     // å»ºæ§‹åƒæ•¸
}

class ServiceResolution {
  final String serviceId;                       // æœå‹™ID
  final Map<String, dynamic>? resolutionContext; // è§£æä¸Šä¸‹æ–‡
  final bool includeMetadata;                   // åŒ…å«å…ƒè³‡æ–™
  final bool validateDependencies;              // é©—è­‰ä¾è³´é—œä¿‚
}

class LifecycleManagement {
  final String action;                          // å‹•ä½œ
  final String? serviceId;                      // æœå‹™ID
  final LifecycleEvent? event;                  // ç”Ÿå‘½é€±æœŸäº‹ä»¶
  final DisposalSettings? disposalSettings;     // è™•ç½®è¨­å®š
}

enum LifecycleAction { create, dispose, refresh, restart }

class LifecycleEvent {
  final String eventType;                       // äº‹ä»¶é¡å‹
  final DateTime eventTime;                     // äº‹ä»¶æ™‚é–“
  final Map<String, dynamic> eventData;         // äº‹ä»¶è³‡æ–™
}

class DisposalSettings {
  final bool forceDisposal;                     // å¼·åˆ¶è™•ç½®
  final Duration gracefulShutdownTimeout;       // å„ªé›…é—œé–‰è¶…æ™‚
  final bool disposeOnError;                    // éŒ¯èª¤æ™‚è™•ç½®
}

class ContainerConfiguration {
  final String configurationId;                 // é…ç½®ID
  final ContainerSettings settings;             // å®¹å™¨è¨­å®š
  final SecurityPolicy? securityPolicy;         // å®‰å…¨æ”¿ç­–
  final PerformanceSettings? performanceSettings; // æ•ˆèƒ½è¨­å®š
}

class ContainerSettings {
  final bool enableValidation;                  // å•Ÿç”¨é©—è­‰
  final bool enableCircularDependencyDetection; // å•Ÿç”¨å¾ªç’°ä¾è³´æª¢æ¸¬
  final bool enableAutoRegistration;            // å•Ÿç”¨è‡ªå‹•è¨»å†Š
  final string defaultLifetime;                 // é è¨­ç”Ÿå‘½é€±æœŸ
  final int maxServiceInstances;                // æœ€å¤§æœå‹™å¯¦ä¾‹æ•¸
}

class SecurityPolicy {
  final bool enableAccessControl;               // å•Ÿç”¨å­˜å–æ§åˆ¶
  final List<String> allowedServices;           // å…è¨±çš„æœå‹™
  final List<String> restrictedOperations;      // é™åˆ¶çš„æ“ä½œ
  final string authenticationRequired;          // éœ€è¦èªè­‰
}

class PerformanceSettings {
  final bool enableCaching;                     // å•Ÿç”¨å¿«å–
  final bool enableLazyLoading;                 // å•Ÿç”¨å»¶é²è¼‰å…¥
  final int cacheExpiration;                    // å¿«å–éæœŸæ™‚é–“
  final bool enablePooling;                     // å•Ÿç”¨æ± åŒ–
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class DependencyInjectionResponse {
  final bool success;
  final String operation;
  final ServiceRegistrationResult? registrationResult;
  final ServiceResolutionResult? resolutionResult;
  final LifecycleManagementResult? lifecycleResult;
  final ContainerStatus containerStatus;
  final DIMetrics diMetrics;
  final String? errorMessage;
}

class ServiceRegistrationResult {
  final String serviceId;
  final bool wasRegistered;
  final DateTime registeredAt;
  final List<String> resolvedDependencies;
  final List<RegistrationWarning> warnings;
  final ServiceMetadata serviceMetadata;
}

class RegistrationWarning {
  final String warningType;
  final String message;
  final String? suggestion;
}

class ServiceMetadata {
  final String serviceName;
  final String serviceType;
  final ServiceLifetime lifetime;
  final int dependencyCount;
  final bool isCircularDependency;
  final DateTime createdAt;
}

class ServiceResolutionResult {
  final String serviceId;
  final bool wasResolved;
  final Object? serviceInstance;                // æœå‹™å¯¦ä¾‹
  final ResolutionPath resolutionPath;
  final List<ResolvedDependency> resolvedDependencies;
  final ResolutionMetrics resolutionMetrics;
}

class ResolutionPath {
  final List<String> path;
  final int depth;
  final Duration resolutionTime;
  final bool hadCircularDependency;
}

class ResolvedDependency {
  final String dependencyId;
  final String dependencyType;
  final bool wasResolved;
  final String? errorMessage;
  final Object? instance;
}

class ResolutionMetrics {
  final Duration totalResolutionTime;
  final int totalDependencies;
  final int cachedInstances;
  final int newInstances;
  final int failedResolutions;
}

class LifecycleManagementResult {
  final String action;
  final bool wasSuccessful;
  final List<LifecycleOperation> operations;
  final LifecycleMetrics lifecycleMetrics;
  final List<LifecycleEvent> events;
}

class LifecycleOperation {
  final String operationType;
  final String serviceId;
  final bool wasSuccessful;
  final DateTime operationTime;
  final Duration operationDuration;
  final String? errorMessage;
}

class LifecycleMetrics {
  final int totalInstances;
  final int activeInstances;
  final int disposedInstances;
  final Duration averageLifetime;
  final int creationFailures;
  final int disposalFailures;
}

class ContainerStatus {
  final String containerId;
  final bool isHealthy;
  final int totalServices;
  final int activeServices;
  final int failedServices;
  final DateTime lastHealthCheck;
  final ContainerResourceUsage resourceUsage;
}

class ContainerResourceUsage {
  final int memoryUsageMB;
  final double cpuUsagePercentage;
  final int activeThreads;
  final int openConnections;
  final DateTime lastMeasurement;
}

class DIMetrics {
  final int totalRegistrations;
  final int totalResolutions;
  final int successfulResolutions;
  final int failedResolutions;
  final Duration averageResolutionTime;
  final int cacheHitRate;
  final DateTime lastOperation;
}
```

#### 3.1.7 I007: é…ç½®ç®¡ç†
**åŠŸèƒ½æè¿°**: ç’°å¢ƒé…ç½®ã€åŠŸèƒ½é–‹é—œèˆ‡å‹•æ…‹é…ç½®ç®¡ç†

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: GET
- **ç«¯é»**: `/infrastructure/config/settings`
- **è¼¸å…¥åƒæ•¸**:
```dart
class ConfigurationRequest {
  final String operation;                       // æ“ä½œé¡å‹ï¼ˆå¿…å¡«ï¼‰
  final ConfigurationQuery? query;              // é…ç½®æŸ¥è©¢ï¼ˆå¯é¸ï¼‰
  final ConfigurationUpdate? update;            // é…ç½®æ›´æ–°ï¼ˆå¯é¸ï¼‰
  final FeatureToggleOperation? featureToggle;  // åŠŸèƒ½é–‹é—œæ“ä½œï¼ˆå¯é¸ï¼‰
  final EnvironmentConfiguration? environment;  // ç’°å¢ƒé…ç½®ï¼ˆå¯é¸ï¼‰
}

enum ConfigOperation { query, update, reload, validate, export }

class ConfigurationQuery {
  final List<String>? configKeys;               // é…ç½®éµ
  final String? configGroup;                    // é…ç½®ç¾¤çµ„
  final String? environment;                    // ç’°å¢ƒ
  final bool includeMetadata;                   // åŒ…å«å…ƒè³‡æ–™
  final bool includeSensitive;                  // åŒ…å«æ•æ„Ÿè³‡æ–™
  final ConfigurationFilter? filter;            // é…ç½®ç¯©é¸
}

class ConfigurationFilter {
  final String? pattern;                        // æ¨¡å¼
  final List<String>? tags;                     // æ¨™ç±¤
  final DateTime? lastModifiedAfter;            // æœ€å¾Œä¿®æ”¹æ™‚é–“ä¹‹å¾Œ
  final String? modifiedBy;                     // ä¿®æ”¹è€…
}

class ConfigurationUpdate {
  final Map<String, ConfigurationValue> updates; // æ›´æ–°
  final String reason;                          // åŸå› 
  final bool validateBeforeUpdate;              // æ›´æ–°å‰é©—è­‰
  final bool notifySubscribers;                 // é€šçŸ¥è¨‚é–±è€…
  final UpdateStrategy updateStrategy;          // æ›´æ–°ç­–ç•¥
}

class ConfigurationValue {
  final dynamic value;                          // å€¼
  final String dataType;                        // è³‡æ–™é¡å‹
  final bool isSensitive;                       // æ˜¯å¦æ•æ„Ÿ
  final ConfigurationMetadata? metadata;        // å…ƒè³‡æ–™
}

class ConfigurationMetadata {
  final String? description;                    // æè¿°
  final String? category;                       // é¡åˆ¥
  final List<String>? tags;                     // æ¨™ç±¤
  final ValidationRule? validationRule;         // é©—è­‰è¦å‰‡
  final DateTime? expirationTime;               // éæœŸæ™‚é–“
}

class ValidationRule {
  final String ruleType;                        // è¦å‰‡é¡å‹
  final Map<String, dynamic> ruleParameters;    // è¦å‰‡åƒæ•¸
  final String? errorMessage;                   // éŒ¯èª¤è¨Šæ¯
}

enum UpdateStrategy { immediate, scheduled, onNextRestart }

class FeatureToggleOperation {
  final String action;                          // å‹•ä½œ
  final FeatureToggleRequest? toggleRequest;    // é–‹é—œè«‹æ±‚
  final FeatureToggleQuery? toggleQuery;        // é–‹é—œæŸ¥è©¢
}

enum FeatureToggleAction { enable, disable, query, configure }

class FeatureToggleRequest {
  final String featureId;                       // åŠŸèƒ½ID
  final bool enabled;                           // æ˜¯å¦å•Ÿç”¨
  final ToggleConfiguration? configuration;     // é–‹é—œé…ç½®
  final RolloutStrategy? rolloutStrategy;       // æ¨å‡ºç­–ç•¥
}

class ToggleConfiguration {
  final String? description;                    // æè¿°
  final List<String>? targetUsers;              // ç›®æ¨™ä½¿ç”¨è€…
  final List<String>? targetGroups;             // ç›®æ¨™ç¾¤çµ„
  final ToggleConditions? conditions;           // é–‹é—œæ¢ä»¶
  final DateTime? effectiveDate;                // ç”Ÿæ•ˆæ—¥æœŸ
  final DateTime? expirationDate;               // éæœŸæ—¥æœŸ
}

class ToggleConditions {
  final List<Condition> conditions;             // æ¢ä»¶
  final String logicalOperator;                 // é‚è¼¯é‹ç®—å­
}

class Condition {
  final String attribute;                       // å±¬æ€§
  final String operator;                        // é‹ç®—å­
  final dynamic value;                          // å€¼
}

class RolloutStrategy {
  final String strategyType;                    // ç­–ç•¥é¡å‹
  final double percentage;                      // ç™¾åˆ†æ¯”
  final String? targetSegment;                  // ç›®æ¨™å€æ®µ
  final RolloutSchedule? schedule;              // æ¨å‡ºæ’ç¨‹
}

class RolloutSchedule {
  final DateTime startTime;                     // é–‹å§‹æ™‚é–“
  final DateTime endTime;                       // çµæŸæ™‚é–“
  final List<RolloutPhase> phases;              // æ¨å‡ºéšæ®µ
}

class RolloutPhase {
  final String phaseName;                       // éšæ®µåç¨±
  final double percentage;                      // ç™¾åˆ†æ¯”
  final Duration duration;                      // æœŸé–“
}

class FeatureToggleQuery {
  final String? featureId;                      // åŠŸèƒ½ID
  final String? userId;                         // ä½¿ç”¨è€…ID
  final Map<String, dynamic>? userContext;      // ä½¿ç”¨è€…ä¸Šä¸‹æ–‡
  final bool includeConfiguration;              // åŒ…å«é…ç½®
}

class EnvironmentConfiguration {
  final String environmentName;                 // ç’°å¢ƒåç¨±
  final Map<String, String> environmentVariables; // ç’°å¢ƒè®Šæ•¸
  final List<String> activeProfiles;            // æ´»èºè¨­å®šæª”
  final EnvironmentValidation? validation;      // ç’°å¢ƒé©—è­‰
}

class EnvironmentValidation {
  final bool validateConfiguration;             // é©—è­‰é…ç½®
  final bool validateConnections;               // é©—è­‰é€£ç·š
  final bool validatePermissions;               // é©—è­‰æ¬Šé™
  final List<String> requiredServices;          // å¿…è¦æœå‹™
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class ConfigurationResponse {
  final bool success;
  final String operation;
  final ConfigurationQueryResult? queryResult;
  final ConfigurationUpdateResult? updateResult;
  final FeatureToggleResult? featureToggleResult;
  final EnvironmentStatus? environmentStatus;
  final ConfigurationMetrics configMetrics;
  final String? errorMessage;
}

class ConfigurationQueryResult {
  final Map<String, ConfigurationItem> configurations; // é…ç½®
  final int totalConfigurations;                // ç¸½é…ç½®æ•¸
  final DateTime queryTime;                     // æŸ¥è©¢æ™‚é–“
  final ConfigurationSummary summary;           // é…ç½®æ‘˜è¦
}

class ConfigurationItem {
  final String key;                             // éµ
  final dynamic value;                          // å€¼
  final String dataType;                        // è³‡æ–™é¡å‹
  final ConfigurationMetadata metadata;         // å…ƒè³‡æ–™
  final DateTime lastModified;                  // æœ€å¾Œä¿®æ”¹æ™‚é–“
  final String modifiedBy;                      // ä¿®æ”¹è€…
  final bool isSensitive;                       // æ˜¯å¦æ•æ„Ÿ
}

class ConfigurationSummary {
  final int totalItems;                         // ç¸½é …ç›®æ•¸
  final int sensitiveItems;                     // æ•æ„Ÿé …ç›®æ•¸
  final List<String> categories;                // é¡åˆ¥
  final DateTime oldestConfiguration;           // æœ€èˆŠé…ç½®
  final DateTime newestConfiguration;           // æœ€æ–°é…ç½®
}

class ConfigurationUpdateResult {
  final int totalUpdates;                       // ç¸½æ›´æ–°æ•¸
  final int successfulUpdates;                  // æˆåŠŸæ›´æ–°æ•¸
  final int failedUpdates;                      // å¤±æ•—æ›´æ–°æ•¸
  final List<UpdateResult> updateResults;       // æ›´æ–°çµæœ
  final NotificationResult? notificationResult; // é€šçŸ¥çµæœ
  final ValidationResult validationResult;      // é©—è­‰çµæœ
}

class UpdateResult {
  final String configKey;                       // é…ç½®éµ
  final bool wasSuccessful;                     // æ˜¯å¦æˆåŠŸ
  final dynamic oldValue;                       // èˆŠå€¼
  final dynamic newValue;                       // æ–°å€¼
  final DateTime updateTime;                    // æ›´æ–°æ™‚é–“
  final String? errorMessage;                   // éŒ¯èª¤è¨Šæ¯
}

class ValidationResult {
  final bool isValid;                           // æ˜¯å¦æœ‰æ•ˆ
  final List<ValidationError> errors;           // é©—è­‰éŒ¯èª¤
  final List<ValidationWarning> warnings;       // é©—è­‰è­¦å‘Š
  final DateTime validatedAt;                   // é©—è­‰æ™‚é–“
}

class ValidationError {
  final String configKey;                       // é…ç½®éµ
  final String errorType;                       // éŒ¯èª¤é¡å‹
  final String errorMessage;                    // éŒ¯èª¤è¨Šæ¯
  final String? suggestion;                     // å»ºè­°
}

class ValidationWarning {
  final String configKey;                       // é…ç½®éµ
  final String warningType;                     // è­¦å‘Šé¡å‹
  final String warningMessage;                  // è­¦å‘Šè¨Šæ¯
  final String? recommendation;                 // å»ºè­°
}

class FeatureToggleResult {
  final String action;                          // å‹•ä½œ
  final FeatureToggleQueryResult? queryResult;  // æŸ¥è©¢çµæœ
  final FeatureToggleUpdateResult? updateResult; // æ›´æ–°çµæœ
  final FeatureToggleMetrics metrics;           // åŠŸèƒ½é–‹é—œæŒ‡æ¨™
}

class FeatureToggleQueryResult {
  final Map<String, FeatureToggleInfo> features; // åŠŸèƒ½
  final UserFeatureContext? userContext;        // ä½¿ç”¨è€…åŠŸèƒ½ä¸Šä¸‹æ–‡
  final DateTime queryTime;                     // æŸ¥è©¢æ™‚é–“
}

class FeatureToggleInfo {
  final String featureId;                       // åŠŸèƒ½ID
  final bool isEnabled;                         // æ˜¯å¦å•Ÿç”¨
  final bool isEnabledForUser;                  // å°ä½¿ç”¨è€…æ˜¯å¦å•Ÿç”¨
  final ToggleConfiguration configuration;      // é–‹é—œé…ç½®
  final RolloutStatus rolloutStatus;            // æ¨å‡ºç‹€æ…‹
  final DateTime lastModified;                  // æœ€å¾Œä¿®æ”¹æ™‚é–“
}

class RolloutStatus {
  final String status;                          // ç‹€æ…‹
  final double currentPercentage;               // ç›®å‰ç™¾åˆ†æ¯”
  final String? currentPhase;                   // ç›®å‰éšæ®µ
  final DateTime? nextPhaseTime;                // ä¸‹éšæ®µæ™‚é–“
  final int affectedUsers;                      // å—å½±éŸ¿ä½¿ç”¨è€…æ•¸
}

class UserFeatureContext {
  final String userId;                          // ä½¿ç”¨è€…ID
  final List<String> enabledFeatures;           // å•Ÿç”¨åŠŸèƒ½
  final List<String> disabledFeatures;          // åœç”¨åŠŸèƒ½
  final Map<String, dynamic> userAttributes;    // ä½¿ç”¨è€…å±¬æ€§
}

class FeatureToggleUpdateResult {
  final String featureId;                       // åŠŸèƒ½ID
  final bool wasSuccessful;                     // æ˜¯å¦æˆåŠŸ
  final bool oldState;                          // èˆŠç‹€æ…‹
  final bool newState;                          // æ–°ç‹€æ…‹
  final DateTime updateTime;                    // æ›´æ–°æ™‚é–“
  final int affectedUsers;                      // å—å½±éŸ¿ä½¿ç”¨è€…æ•¸
}

class FeatureToggleMetrics {
  final int totalFeatures;                      // ç¸½åŠŸèƒ½æ•¸
  final int enabledFeatures;                    // å•Ÿç”¨åŠŸèƒ½æ•¸
  final int rollingOutFeatures;                 // æ¨å‡ºä¸­åŠŸèƒ½æ•¸
  final DateTime lastToggleTime;                // æœ€å¾Œé–‹é—œæ™‚é–“
  final Map<String, int> usageStatistics;       // ä½¿ç”¨çµ±è¨ˆ
}

class EnvironmentStatus {
  final String environmentName;                 // ç’°å¢ƒåç¨±
  final bool isHealthy;                         // æ˜¯å¦å¥åº·
  final EnvironmentValidationResult validationResult; // ç’°å¢ƒé©—è­‰çµæœ
  final List<EnvironmentService> services;      // ç’°å¢ƒæœå‹™
  final EnvironmentMetrics environmentMetrics;  // ç’°å¢ƒæŒ‡æ¨™
}

class EnvironmentValidationResult {
  final bool isValid;                           // æ˜¯å¦æœ‰æ•ˆ
  final List<ValidationCheck> validationChecks; // é©—è­‰æª¢æŸ¥
  final DateTime validatedAt;                   // é©—è­‰æ™‚é–“
  final Duration validationDuration;            // é©—è­‰æœŸé–“
}

class ValidationCheck {
  final String checkName;                       // æª¢æŸ¥åç¨±
  final String checkType;                       // æª¢æŸ¥é¡å‹
  final bool passed;                            // æ˜¯å¦é€šé
  final String? errorMessage;                   // éŒ¯èª¤è¨Šæ¯
  final Duration checkDuration;                 // æª¢æŸ¥æœŸé–“
}

class EnvironmentService {
  final String serviceName;                     // æœå‹™åç¨±
  final String serviceStatus;                   // æœå‹™ç‹€æ…‹
  final String? serviceUrl;                     // æœå‹™URL
  final DateTime lastCheck;                     // æœ€å¾Œæª¢æŸ¥æ™‚é–“
  final String? healthCheckResult;              // å¥åº·æª¢æŸ¥çµæœ
}

class EnvironmentMetrics {
  final int totalServices;                      // ç¸½æœå‹™æ•¸
  final int healthyServices;                    // å¥åº·æœå‹™æ•¸
  final int unhealthyServices;                  // ä¸å¥åº·æœå‹™æ•¸
  final double overallHealthScore;              // æ•´é«”å¥åº·åˆ†æ•¸
  final DateTime lastMetricsUpdate;             // æœ€å¾ŒæŒ‡æ¨™æ›´æ–°æ™‚é–“
}

class ConfigurationMetrics {
  final int totalConfigurations;                // ç¸½é…ç½®æ•¸
  final int totalFeatureToggles;                // ç¸½åŠŸèƒ½é–‹é—œæ•¸
  final int configurationReads;                 // é…ç½®è®€å–æ•¸
  final int configurationWrites;                // é…ç½®å¯«å…¥æ•¸
  final DateTime lastConfigurationChange;       // æœ€å¾Œé…ç½®è®Šæ›´æ™‚é–“
  final Duration averageResponseTime;           // å¹³å‡å›æ‡‰æ™‚é–“
}
```

#### 3.1.8 I008: æ•ˆèƒ½å„ªåŒ–å·¥å…·
**åŠŸèƒ½æè¿°**: è«‹æ±‚å„ªåŒ–ã€è³‡æºç®¡ç†èˆ‡æ•ˆèƒ½åˆ†æå·¥å…·

**APIè¦æ ¼**:
- **HTTPæ–¹æ³•**: GET
- **ç«¯é»**: `/infrastructure/performance/metrics`
- **è¼¸å…¥åƒæ•¸**:
```dart
class PerformanceOptimizationRequest {
  final String operation;                       // æ“ä½œé¡å‹ï¼ˆå¿…å¡«ï¼‰
  final PerformanceAnalysis? analysis;          // æ•ˆèƒ½åˆ†æï¼ˆå¯é¸ï¼‰
  final ResourceOptimization? resourceOptimization; // è³‡æºå„ªåŒ–ï¼ˆå¯é¸ï¼‰
  final RequestOptimization? requestOptimization; // è«‹æ±‚å„ªåŒ–ï¼ˆå¯é¸ï¼‰
  final PerformanceMonitoring? monitoring;      // æ•ˆèƒ½ç›£æ§ï¼ˆå¯é¸ï¼‰
}

enum PerformanceOperation { analyze, optimize, monitor, profile, benchmark }

class PerformanceAnalysis {
  final String analysisType;                    // åˆ†æé¡å‹
  final AnalysisScope scope;                    // åˆ†æç¯„åœ
  final TimeRange timeRange;                    // æ™‚é–“ç¯„åœ
  final List<PerformanceMetric> targetMetrics;  // ç›®æ¨™æŒ‡æ¨™
  final AnalysisConfiguration configuration;    // åˆ†æé…ç½®
}

enum AnalysisType { realTime, historical, predictive, comparative }

class AnalysisScope {
  final List<String> services;                  // æœå‹™
  final List<String> endpoints;                 // ç«¯é»
  final List<String> resources;                 // è³‡æº
  final bool includeDatabase;                   // åŒ…å«è³‡æ–™åº«
  final bool includeNetwork;                    // åŒ…å«ç¶²è·¯
  final bool includeMemory;                     // åŒ…å«è¨˜æ†¶é«”
}

class TimeRange {
  final DateTime startTime;                     // é–‹å§‹æ™‚é–“
  final DateTime endTime;                       // çµæŸæ™‚é–“
  final string granularity;                     // ç²’åº¦
}

class PerformanceMetric {
  final String metricName;                      // æŒ‡æ¨™åç¨±
  final String metricType;                      // æŒ‡æ¨™é¡å‹
  final Map<String, dynamic> metricConfig;      // æŒ‡æ¨™é…ç½®
}

class AnalysisConfiguration {
  final String analysisDepth;                   // åˆ†ææ·±åº¦
  final bool enableProfiling;                   // å•Ÿç”¨æ€§èƒ½åˆ†æ
  final bool includeRecommendations;            // åŒ…å«å»ºè­°
  final double confidenceThreshold;             // ä¿¡å¿ƒé–¾å€¼
}

class ResourceOptimization {
  final String optimizationType;                // å„ªåŒ–é¡å‹
  final ResourceTargets targets;                // è³‡æºç›®æ¨™
  final OptimizationStrategy strategy;          // å„ªåŒ–ç­–ç•¥
  final OptimizationConstraints? constraints;   // å„ªåŒ–ç´„æŸ
}

enum OptimizationType { memory, cpu, network, storage, overall }

class ResourceTargets {
  final double? memoryTarget;                   // è¨˜æ†¶é«”ç›®æ¨™
  final double? cpuTarget;                      // CPUç›®æ¨™
  final double? networkTarget;                  // ç¶²è·¯ç›®æ¨™
  final double? storageTarget;                  // å„²å­˜ç›®æ¨™
  final double? responseTimeTarget;             // å›æ‡‰æ™‚é–“ç›®æ¨™
}

class OptimizationStrategy {
  final String strategyName;                    // ç­–ç•¥åç¨±
  final List<OptimizationTechnique> techniques; // å„ªåŒ–æŠ€å·§
  final bool enableAutomaticOptimization;       // å•Ÿç”¨è‡ªå‹•å„ªåŒ–
  final string optimizationPriority;            // å„ªåŒ–å„ªå…ˆç´š
}

class OptimizationTechnique {
  final String techniqueName;                   // æŠ€å·§åç¨±
  final String techniqueType;                   // æŠ€å·§é¡å‹
  final Map<String, dynamic> techniqueConfig;   // æŠ€å·§é…ç½®
  final bool isEnabled;                         // æ˜¯å¦å•Ÿç”¨
}

class OptimizationConstraints {
  final double maxMemoryIncrease;               // æœ€å¤§è¨˜æ†¶é«”å¢åŠ 
  final double maxCpuIncrease;                  // æœ€å¤§CPUå¢åŠ 
  final Duration maxResponseTimeIncrease;       // æœ€å¤§å›æ‡‰æ™‚é–“å¢åŠ 
  final List<String> preservedFeatures;         // ä¿ç•™åŠŸèƒ½
}

class RequestOptimization {
  final RequestAnalysis requestAnalysis;        // è«‹æ±‚åˆ†æ
  final CachingOptimization cachingOptimization; // å¿«å–å„ªåŒ–
  final CompressionOptimization compressionOptimization; // å£“ç¸®å„ªåŒ–
  final ConnectionOptimization connectionOptimization; // é€£ç·šå„ªåŒ–
}

class RequestAnalysis {
  final List<string> targetEndpoints;           // ç›®æ¨™ç«¯é»
  final RequestPattern requestPattern;          // è«‹æ±‚æ¨¡å¼
  final bool analyzePayloadSize;                // åˆ†æè² è¼‰å¤§å°
  final bool analyzeHeaders;                    // åˆ†ææ¨™é ­
}

class RequestPattern {
  final string patternType;                     // æ¨¡å¼é¡å‹
  final TimeRange analysisWindow;               // åˆ†æè¦–çª—
  final int minRequestCount;                    // æœ€å°è«‹æ±‚æ•¸
}

class CachingOptimization {
  final bool enableRequestCaching;              // å•Ÿç”¨è«‹æ±‚å¿«å–
  final bool enableResponseCaching;             // å•Ÿç”¨å›æ‡‰å¿«å–
  final CachingStrategy cachingStrategy;        // å¿«å–ç­–ç•¥
  final List<CachingRule> cachingRules;         // å¿«å–è¦å‰‡
}

class CachingStrategy {
  final string strategyName;                    // ç­–ç•¥åç¨±
  final Duration defaultCacheDuration;          // é è¨­å¿«å–æœŸé–“
  final List<string> cacheHeaders;              // å¿«å–æ¨™é ­
  final bool enableConditionalCaching;          // å•Ÿç”¨æ¢ä»¶å¿«å–
}

class CachingRule {
  final string ruleId;                          // è¦å‰‡ID
  final string pattern;                         // æ¨¡å¼
  final Duration cacheDuration;                 // å¿«å–æœŸé–“
  final List<string> conditions;                // æ¢ä»¶
}

class CompressionOptimization {
  final bool enableRequestCompression;          // å•Ÿç”¨è«‹æ±‚å£“ç¸®
  final bool enableResponseCompression;         // å•Ÿç”¨å›æ‡‰å£“ç¸®
  final CompressionSettings compressionSettings; // å£“ç¸®è¨­å®š
}

class CompressionSettings {
  final string algorithm;                       // æ¼”ç®—æ³•
  final int compressionLevel;                   // å£“ç¸®ç­‰ç´š
  final int minSizeThreshold;                   // æœ€å°å¤§å°é–¾å€¼
  final List<string> compressibleTypes;         // å¯å£“ç¸®é¡å‹
}

class ConnectionOptimization {
  final ConnectionPooling connectionPooling;    // é€£ç·šæ± 
  final KeepAliveSettings keepAliveSettings;    // ä¿æŒé€£ç·šè¨­å®š
  final TimeoutOptimization timeoutOptimization; // è¶…æ™‚å„ªåŒ–
}

class ConnectionPooling {
  final int maxConnections;                     // æœ€å¤§é€£ç·šæ•¸
  final int maxConnectionsPerHost;              // æ¯ä¸»æ©Ÿæœ€å¤§é€£ç·šæ•¸
  final Duration connectionTimeout;             // é€£ç·šè¶…æ™‚
  final Duration idleTimeout;                   // ç©ºé–’è¶…æ™‚
}

class KeepAliveSettings {
  final bool enableKeepAlive;                   // å•Ÿç”¨ä¿æŒé€£ç·š
  final Duration keepAliveTimeout;              // ä¿æŒé€£ç·šè¶…æ™‚
  final int maxKeepAliveRequests;               // æœ€å¤§ä¿æŒé€£ç·šè«‹æ±‚æ•¸
}

class TimeoutOptimization {
  final Duration connectTimeout;                // é€£ç·šè¶…æ™‚
  final Duration readTimeout;                   // è®€å–è¶…æ™‚
  final Duration writeTimeout;                  // å¯«å…¥è¶…æ™‚
  final bool enableAdaptiveTimeout;             // å•Ÿç”¨è‡ªé©æ‡‰è¶…æ™‚
}

class PerformanceMonitoring {
  final MonitoringConfiguration configuration;  // ç›£æ§é…ç½®
  final List<PerformanceAlert> alerts;          // æ•ˆèƒ½è­¦ç¤º
  final ReportingSettings reportingSettings;    // å ±å‘Šè¨­å®š
}

class MonitoringConfiguration {
  final List<string> monitoredMetrics;          // ç›£æ§æŒ‡æ¨™
  final Duration samplingInterval;              // æ¡æ¨£é–“éš”
  final int retentionPeriod;                    // ä¿ç•™æœŸé–“
  final bool enableRealTimeMonitoring;          // å•Ÿç”¨å³æ™‚ç›£æ§
}

class PerformanceAlert {
  final string alertId;                         // è­¦ç¤ºID
  final string metricName;                      // æŒ‡æ¨™åç¨±
  final string condition;                       // æ¢ä»¶
  final double threshold;                       // é–¾å€¼
  final AlertSeverity severity;                 // åš´é‡ç¨‹åº¦
}

class ReportingSettings {
  final bool enableAutoReporting;               // å•Ÿç”¨è‡ªå‹•å ±å‘Š
  final Duration reportingInterval;             // å ±å‘Šé–“éš”
  final List<string> reportRecipients;          // å ±å‘Šæ”¶ä»¶äºº
  final string reportFormat;                    // å ±å‘Šæ ¼å¼
}
```

**è¼¸å‡ºè¦æ ¼**:
```dart
class PerformanceOptimizationResponse {
  final bool success;
  final String operation;
  final PerformanceAnalysisResult? analysisResult;
  final ResourceOptimizationResult? resourceResult;
  final RequestOptimizationResult? requestResult;
  final PerformanceMonitoringResult? monitoringResult;
  final PerformanceMetrics performanceMetrics;
  final String? errorMessage;
}

class PerformanceAnalysisResult {
  final String analysisId;                      // åˆ†æID
  final PerformanceProfile performanceProfile;  // æ•ˆèƒ½è¨­å®šæª”
  final List<PerformanceBottleneck> bottlenecks; // æ•ˆèƒ½ç“¶é ¸
  final List<PerformanceInsight> insights;       // æ•ˆèƒ½æ´å¯Ÿ
  final BenchmarkComparison? benchmarkComparison; // åŸºæº–æ¯”è¼ƒ
  final List<OptimizationRecommendation> recommendations; // å„ªåŒ–å»ºè­°
}

class PerformanceProfile {
  final Map<string, double> metrics;            // æŒ‡æ¨™
  final PerformanceCharacteristics characteristics; // æ•ˆèƒ½ç‰¹æ€§
  final ResourceUtilization resourceUtilization; // è³‡æºä½¿ç”¨ç‡
  final DateTime profileTime;                   // è¨­å®šæª”æ™‚é–“
}

class PerformanceCharacteristics {
  final double averageResponseTime;             // å¹³å‡å›æ‡‰æ™‚é–“
  final double throughput;                      // ååé‡
  final double errorRate;                       // éŒ¯èª¤ç‡
  final double availability;                    // å¯ç”¨æ€§
  final PerformanceTrend trend;                 // æ•ˆèƒ½è¶¨å‹¢
}

class PerformanceTrend {
  final string direction;                       // æ–¹å‘
  final double changeRate;                      // è®ŠåŒ–ç‡
  final Duration trendPeriod;                   // è¶¨å‹¢æœŸé–“
  final List<TrendPoint> trendPoints;           // è¶¨å‹¢é»
}

class ResourceUtilization {
  final double memoryUtilization;               // è¨˜æ†¶é«”ä½¿ç”¨ç‡
  final double cpuUtilization;                  // CPUä½¿ç”¨ç‡
  final double networkUtilization;              // ç¶²è·¯ä½¿ç”¨ç‡
  final double storageUtilization;              // å„²å­˜ä½¿ç”¨ç‡
}

class PerformanceBottleneck {
  final string bottleneckId;                    // ç“¶é ¸ID
  final string bottleneckType;                  // ç“¶é ¸é¡å‹
  final string location;                        // ä½ç½®
  final double severity;                        // åš´é‡ç¨‹åº¦
  final string description;                     // æè¿°
  final double impact;                          // å½±éŸ¿
  final List<string> affectedOperations;        // å—å½±éŸ¿æ“ä½œ
}

class PerformanceInsight {
  final string insightId;                       // æ´å¯ŸID
  final string insightType;                     // æ´å¯Ÿé¡å‹
  final string title;                           // æ¨™é¡Œ
  final string description;                     // æè¿°
  final double confidence;                      // ä¿¡å¿ƒåº¦
  final string? actionSuggestion;               // è¡Œå‹•å»ºè­°
}

class BenchmarkComparison {
  final string benchmarkName;                   // åŸºæº–åç¨±
  final Map<string, BenchmarkMetric> metrics;   // æŒ‡æ¨™
  final string comparisonResult;                // æ¯”è¼ƒçµæœ
  final double overallScore;                    // æ•´é«”åˆ†æ•¸
}

class BenchmarkMetric {
  final double currentValue;                    // ç›®å‰å€¼
  final double benchmarkValue;                  // åŸºæº–å€¼
  final double percentageDifference;            // ç™¾åˆ†æ¯”å·®ç•°
  final string comparisonStatus;                // æ¯”è¼ƒç‹€æ…‹
}

class OptimizationRecommendation {
  final string recommendationId;                // å»ºè­°ID
  final string recommendationType;              // å»ºè­°é¡å‹
  final string title;                           // æ¨™é¡Œ
  final string description;                     // æè¿°
  final double expectedImprovement;             // é æœŸæ”¹å–„
  final int implementationComplexity;           // å¯¦ä½œè¤‡é›œåº¦
  final List<string> implementationSteps;       // å¯¦ä½œæ­¥é©Ÿ
  final Map<string, dynamic>? parameters;       // åƒæ•¸
}

class ResourceOptimizationResult {
  final string optimizationId;                  // å„ªåŒ–ID
  final List<OptimizationAction> appliedActions; // å¥—ç”¨è¡Œå‹•
  final ResourceImprovements improvements;       // è³‡æºæ”¹å–„
  final OptimizationMetrics optimizationMetrics; // å„ªåŒ–æŒ‡æ¨™
  final List<OptimizationWarning> warnings;     // å„ªåŒ–è­¦å‘Š
}

class OptimizationAction {
  final string actionId;                        // è¡Œå‹•ID
  final string actionType;                      // è¡Œå‹•é¡å‹
  final string description;                     // æè¿°
  final bool wasSuccessful;                     // æ˜¯å¦æˆåŠŸ
  final DateTime appliedAt;                     // å¥—ç”¨æ™‚é–“
  final Map<string, dynamic> parameters;        // åƒæ•¸
}

class ResourceImprovements {
  final double memoryImprovement;               // è¨˜æ†¶é«”æ”¹å–„
  final double cpuImprovement;                  // CPUæ”¹å–„
  final double networkImprovement;              // ç¶²è·¯æ”¹å–„
  final double responseTimeImprovement;         // å›æ‡‰æ™‚é–“æ”¹å–„
  final double overallImprovement;              // æ•´é«”æ”¹å–„
}

class OptimizationMetrics {
  final int totalOptimizations;                 // ç¸½å„ªåŒ–æ•¸
  final int successfulOptimizations;            // æˆåŠŸå„ªåŒ–æ•¸
  final int failedOptimizations;                // å¤±æ•—å„ªåŒ–æ•¸
  final Duration totalOptimizationTime;         // ç¸½å„ªåŒ–æ™‚é–“
  final DateTime lastOptimization;              // æœ€å¾Œå„ªåŒ–æ™‚é–“
}

class OptimizationWarning {
  final String warningType;                     // è­¦å‘Šé¡å‹
  final string message;                         // è¨Šæ¯
  final string? recommendation;                 // å»ºè­°
  final string severity;                        // åš´é‡ç¨‹åº¦
}

class RequestOptimizationResult {
  final string optimizationId;                  // å„ªåŒ–ID
  final CachingOptimizationResult cachingResult; // å¿«å–å„ªåŒ–çµæœ
  final CompressionOptimizationResult compressionResult; // å£“ç¸®å„ªåŒ–çµæœ
  final ConnectionOptimizationResult connectionResult; // é€£ç·šå„ªåŒ–çµæœ
  final RequestPerformanceImprovement improvements; // è«‹æ±‚æ•ˆèƒ½æ”¹å–„
}

class CachingOptimizationResult {
  final bool cachingEnabled;                    // å¿«å–å•Ÿç”¨
  final double cacheHitRate;                    // å¿«å–å‘½ä¸­ç‡
  final Duration averageCacheResponseTime;      // å¹³å‡å¿«å–å›æ‡‰æ™‚é–“
  final int totalCachedRequests;                // ç¸½å¿«å–è«‹æ±‚æ•¸
  final double bandwidthSaved;                  // ç¯€çœé »å¯¬
}

class CompressionOptimizationResult {
  final bool compressionEnabled;                // å£“ç¸®å•Ÿç”¨
  final double compressionRatio;                // å£“ç¸®æ¯”
  final double bandwidthReduction;              // é »å¯¬æ¸›å°‘
  final Duration compressionOverhead;           // å£“ç¸®é–‹éŠ·
  final List<string> compressedEndpoints;       // å£“ç¸®ç«¯é»
}

class ConnectionOptimizationResult {
  final int activeConnections;                  // æ´»èºé€£ç·šæ•¸
  final double connectionReuseRate;             // é€£ç·šé‡ç”¨ç‡
  final Duration averageConnectionTime;         // å¹³å‡é€£ç·šæ™‚é–“
  final int connectionPoolEfficiency;           // é€£ç·šæ± æ•ˆç‡
  final List<ConnectionMetric> connectionMetrics; // é€£ç·šæŒ‡æ¨™
}

class ConnectionMetric {
  final String metricName;                      // æŒ‡æ¨™åç¨±
  final double value;                           // å€¼
  final string unit;                            // å–®ä½
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
}

class RequestPerformanceImprovement {
  final double responseTimeImprovement;         // å›æ‡‰æ™‚é–“æ”¹å–„
  final double throughputImprovement;           // ååé‡æ”¹å–„
  final double errorRateReduction;              // éŒ¯èª¤ç‡æ¸›å°‘
  final double resourceUtilizationImprovement;  // è³‡æºä½¿ç”¨ç‡æ”¹å–„
}

class PerformanceMonitoringResult {
  final string monitoringId;                    // ç›£æ§ID
  final MonitoringStatus status;                // ç›£æ§ç‹€æ…‹
  final List<TriggeredPerformanceAlert> triggeredAlerts; // è§¸ç™¼è­¦ç¤º
  final PerformanceReport performanceReport;    // æ•ˆèƒ½å ±å‘Š
  final MonitoringMetrics monitoringMetrics;    // ç›£æ§æŒ‡æ¨™
}

class MonitoringStatus {
  final bool isActive;                          // æ˜¯å¦æ´»èº
  final int monitoredServices;                  // ç›£æ§æœå‹™æ•¸
  final int monitoredMetrics;                   // ç›£æ§æŒ‡æ¨™æ•¸
  final DateTime lastUpdate;                    // æœ€å¾Œæ›´æ–°æ™‚é–“
  final string healthStatus;                    // å¥åº·ç‹€æ…‹
}

class TriggeredPerformanceAlert {
  final string alertId;                         // è­¦ç¤ºID
  final string metricName;                      // æŒ‡æ¨™åç¨±
  final double currentValue;                    // ç›®å‰å€¼
  final double threshold;                       // é–¾å€¼
  final AlertSeverity severity;                 // åš´é‡ç¨‹åº¦
  final DateTime triggeredAt;                   // è§¸ç™¼æ™‚é–“
  final bool wasNotified;                       // æ˜¯å¦å·²é€šçŸ¥
}

class PerformanceReport {
  final string reportId;                        // å ±å‘ŠID
  final DateTime reportPeriodStart;             // å ±å‘ŠæœŸé–“é–‹å§‹
  final DateTime reportPeriodEnd;               // å ±å‘ŠæœŸé–“çµæŸ
  final PerformanceSummary summary;             // æ•ˆèƒ½æ‘˜è¦
  final List<MetricTrend> metricTrends;         // æŒ‡æ¨™è¶¨å‹¢
  final List<PerformanceEvent> significantEvents; // é‡è¦äº‹ä»¶
}

class PerformanceSummary {
  final double averageResponseTime;             // å¹³å‡å›æ‡‰æ™‚é–“
  final double peakResponseTime;                // å³°å€¼å›æ‡‰æ™‚é–“
  final double minResponseTime;                 // æœ€å°å›æ‡‰æ™‚é–“
  final double throughput;                      // ååé‡
  final double availability;                    // å¯ç”¨æ€§
  final double errorRate;                       // éŒ¯èª¤ç‡
}

class MetricTrend {
  final string metricName;                      // æŒ‡æ¨™åç¨±
  final string trendDirection;                  // è¶¨å‹¢æ–¹å‘
  final double changePercentage;                // è®ŠåŒ–ç™¾åˆ†æ¯”
  final List<DataPoint> dataPoints;             // è³‡æ–™é»
}

class DataPoint {
  final DateTime timestamp;                     // æ™‚é–“æˆ³è¨˜
  final double value;                           // å€¼
  final Map<string, string>? labels;            // æ¨™ç±¤
}

class PerformanceEvent {
  final string eventId;                         // äº‹ä»¶ID
  final string eventType;                       // äº‹ä»¶é¡å‹
  final DateTime eventTime;                     // äº‹ä»¶æ™‚é–“
  final string description;                     // æè¿°
  final string impact;                          // å½±éŸ¿
  final Duration? duration;                     // æœŸé–“
}

class MonitoringMetrics {
  final int totalDataPoints;                    // ç¸½è³‡æ–™é»æ•¸
  final Duration monitoringUptime;              // ç›£æ§æ­£å¸¸é‹è¡Œæ™‚é–“
  final double dataCollectionRate;              // è³‡æ–™æ”¶é›†ç‡
  final int alertsTriggered;                    // è§¸ç™¼è­¦ç¤ºæ•¸
  final DateTime lastDataCollection;            // æœ€å¾Œè³‡æ–™æ”¶é›†æ™‚é–“
}

class PerformanceMetrics {
  final double overallPerformanceScore;         // æ•´é«”æ•ˆèƒ½åˆ†æ•¸
  final Map<string, double> servicePerformance; // æœå‹™æ•ˆèƒ½
  final ResourceUtilization currentUtilization; // ç›®å‰ä½¿ç”¨ç‡
  final PerformanceTrend overallTrend;          // æ•´é«”è¶¨å‹¢
  final DateTime lastMeasurement;               // æœ€å¾Œæ¸¬é‡æ™‚é–“
  final int totalOptimizations;                 // ç¸½å„ªåŒ–æ•¸
}
```

---

## 4.0 InfrastructureServiceå¯¦ä½œï¼ˆInfrastructure Service Implementationï¼‰

### 4.1 InfrastructureService ä¸»æœå‹™é¡åˆ¥

```dart
/**
 * InfrastructureService_åŸºç¤è¨­æ–½æœå‹™_v1.0.0
 * @module InfrastructureService
 * @description åŸºç¤è¨­æ–½æœå‹™ - ç‚ºå…¶ä»–7å€‹æœå‹™æ¨¡çµ„æä¾›çµ±ä¸€çš„åŸºç¤è¨­æ–½æ”¯æ’
 * @update 2025-08-02: åˆç‰ˆå»ºç«‹ï¼Œå¯¦ä½œ8å€‹åŸºç¤è¨­æ–½APIç«¯é»
 */
class InfrastructureService {
  final ApiClient _apiClient;
  final CacheManager _cacheManager;
  final ErrorHandler _errorHandler;
  final SecurityManager _securityManager;

  InfrastructureService(
    this._apiClient,
    this._cacheManager,
    this._errorHandler,
    this._securityManager,
  );

  /**
   * I001: APIå®¢æˆ¶ç«¯ç®¡ç†
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description çµ±ä¸€HTTPå®¢æˆ¶ç«¯é…ç½®èˆ‡è«‹æ±‚æ””æˆªå™¨ç®¡ç†
   */
  Future<ApiClientConfigResponse> configureApiClient(ApiClientConfigRequest request) async {
    try {
      final response = await _apiClient.post(
        '/infrastructure/api-client/config',
        data: request.toJson(),
      );

      final configResponse = ApiClientConfigResponse.fromJson(response.data);

      // æ›´æ–°æœ¬åœ°APIå®¢æˆ¶ç«¯é…ç½®
      if (configResponse.success && request.action == ApiClientAction.configure.name) {
        await _updateLocalApiClientConfig(request.clientConfig);
      }

      return configResponse;
    } catch (error) {
      throw InfrastructureServiceException('APIå®¢æˆ¶ç«¯é…ç½®å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I001: æŸ¥è©¢APIå®¢æˆ¶ç«¯ç‹€æ…‹
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description æŸ¥è©¢APIå®¢æˆ¶ç«¯ç›®å‰é…ç½®ç‹€æ…‹
   */
  Future<ApiClientConfigResponse> getApiClientStatus() async {
    try {
      final request = ApiClientConfigRequest(
        action: ApiClientAction.query.name,
      );

      final response = await _apiClient.get(
        '/infrastructure/api-client/config',
        queryParameters: request.toJson(),
      );

      return ApiClientConfigResponse.fromJson(response.data);
    } catch (error) {
      throw InfrastructureServiceException('æŸ¥è©¢APIå®¢æˆ¶ç«¯ç‹€æ…‹å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I002: å¿«å–ç­–ç•¥ç®¡ç†
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description å¤šå±¤æ¬¡å¿«å–æ¶æ§‹èˆ‡æ™ºæ…§å¿«å–ç­–ç•¥ç®¡ç†
   */
  Future<CacheManagementResponse> manageCacheStrategy(CacheManagementRequest request) async {
    try {
      String endpoint;
      Map<String, dynamic> requestData;

      switch (request.operation) {
        case CacheOperation.query:
          endpoint = '/infrastructure/cache/status';
          requestData = request.queryParams?.toJson() ?? {};
          break;
        case CacheOperation.configure:
          endpoint = '/infrastructure/cache/config';
          requestData = request.configuration?.toJson() ?? {};
          break;
        case CacheOperation.clear:
          endpoint = '/infrastructure/cache/clear';
          requestData = request.clearParams?.toJson() ?? {};
          break;
        default:
          endpoint = '/infrastructure/cache/status';
          requestData = {};
      }

      final response = await _apiClient.post(endpoint, data: requestData);
      final cacheResponse = CacheManagementResponse.fromJson(response.data);

      // åŒæ­¥æœ¬åœ°å¿«å–ç®¡ç†å™¨è¨­å®š
      if (cacheResponse.success && request.operation == CacheOperation.configure) {
        await _syncCacheManagerSettings(request.configuration);
      }

      return cacheResponse;
    } catch (error) {
      throw InfrastructureServiceException('å¿«å–ç­–ç•¥ç®¡ç†å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I003: éŒ¯èª¤è™•ç†æ¡†æ¶
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description çµ±ä¸€éŒ¯èª¤åˆ†é¡ã€æœ¬åœ°åŒ–èˆ‡é‡è©¦æ©Ÿåˆ¶ç®¡ç†
   */
  Future<ErrorHandlingResponse> handleError(ErrorHandlingRequest request) async {
    try {
      final response = await _apiClient.post(
        '/infrastructure/error/handle',
        data: request.toJson(),
      );

      final errorResponse = ErrorHandlingResponse.fromJson(response.data);

      // æœ¬åœ°éŒ¯èª¤è™•ç†å™¨æ•´åˆ
      if (errorResponse.success) {
        await _integrateErrorHandling(errorResponse);
      }

      return errorResponse;
    } catch (error) {
      throw InfrastructureServiceException('éŒ¯èª¤è™•ç†å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I004: å®‰å…¨èˆ‡èªè­‰åŸºç¤
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description Tokenç®¡ç†ã€åŠ å¯†è§£å¯†ã€æ¬Šé™é©—è­‰åŸºç¤æœå‹™
   */
  Future<SecurityOperationResponse> performSecurityOperation(SecurityOperationRequest request) async {
    try {
      final response = await _apiClient.post(
        '/infrastructure/security/verify',
        data: request.toJson(),
      );

      final securityResponse = SecurityOperationResponse.fromJson(response.data);

      // æ›´æ–°æœ¬åœ°å®‰å…¨ç®¡ç†å™¨
      if (securityResponse.success) {
        await _updateSecurityManager(securityResponse);
      }

      return securityResponse;
    } catch (error) {
      throw InfrastructureServiceException('å®‰å…¨æ“ä½œå¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I005: æ—¥èªŒèˆ‡ç›£æ§
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description çµæ§‹åŒ–æ—¥èªŒè¨˜éŒ„èˆ‡æ•ˆèƒ½ç›£æ§æœå‹™
   */
  Future<LoggingResponse> logEvent(LoggingRequest request) async {
    try {
      final response = await _apiClient.post(
        '/infrastructure/logging/event',
        data: request.toJson(),
      );

      final loggingResponse = LoggingResponse.fromJson(response.data);

      // æœ¬åœ°æ—¥èªŒè™•ç†
      if (loggingResponse.success) {
        await _processLocalLogging(request.logEntry);
      }

      return loggingResponse;
    } catch (error) {
      throw InfrastructureServiceException('æ—¥èªŒè¨˜éŒ„å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I006: ä¾è³´æ³¨å…¥å®¹å™¨
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description æœå‹™è¨»å†Šã€ç”Ÿå‘½é€±æœŸç®¡ç†èˆ‡ä¾è³´è§£ææœå‹™
   */
  Future<DependencyInjectionResponse> manageDependencyInjection(DependencyInjectionRequest request) async {
    try {
      final response = await _apiClient.get(
        '/infrastructure/di/services',
        queryParameters: request.toJson(),
      );

      final diResponse = DependencyInjectionResponse.fromJson(response.data);

      // æœ¬åœ°ä¾è³´æ³¨å…¥å®¹å™¨æ›´æ–°
      if (diResponse.success) {
        await _updateDIContainer(diResponse);
      }

      return diResponse;
    } catch (error) {
      throw InfrastructureServiceException('ä¾è³´æ³¨å…¥ç®¡ç†å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I007: é…ç½®ç®¡ç†
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description ç’°å¢ƒé…ç½®ã€åŠŸèƒ½é–‹é—œèˆ‡å‹•æ…‹é…ç½®ç®¡ç†
   */
  Future<ConfigurationResponse> manageConfiguration(ConfigurationRequest request) async {
    try {
      final response = await _apiClient.get(
        '/infrastructure/config/settings',
        queryParameters: request.toJson(),
      );

      final configResponse = ConfigurationResponse.fromJson(response.data);

      // æœ¬åœ°é…ç½®åŒæ­¥
      if (configResponse.success && request.operation == ConfigOperation.query) {
        await _syncLocalConfiguration(configResponse);
      }

      return configResponse;
    } catch (error) {
      throw InfrastructureServiceException('é…ç½®ç®¡ç†å¤±æ•—: ${error.toString()}');
    }
  }

  /**
   * I008: æ•ˆèƒ½å„ªåŒ–å·¥å…·
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   * @description è«‹æ±‚å„ªåŒ–ã€è³‡æºç®¡ç†èˆ‡æ•ˆèƒ½åˆ†æå·¥å…·
   */
  Future<PerformanceOptimizationResponse> optimizePerformance(PerformanceOptimizationRequest request) async {
    try {
      final response = await _apiClient.get(
        '/infrastructure/performance/metrics',
        queryParameters: request.toJson(),
      );

      final performanceResponse = PerformanceOptimizationResponse.fromJson(response.data);

      // æ‡‰ç”¨æ•ˆèƒ½å„ªåŒ–å»ºè­°
      if (performanceResponse.success) {
        await _applyPerformanceOptimizations(performanceResponse);
      }

      return performanceResponse;
    } catch (error) {
      throw InfrastructureServiceException('æ•ˆèƒ½å„ªåŒ–å¤±æ•—: ${error.toString()}');
    }
  }

  // ç§æœ‰æ–¹æ³• - å…§éƒ¨åŸºç¤è¨­æ–½ç®¡ç†

  /**
   * æ›´æ–°æœ¬åœ°APIå®¢æˆ¶ç«¯é…ç½®
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _updateLocalApiClientConfig(ClientConfiguration? config) async {
    if (config != null) {
      await _apiClient.updateConfiguration(config);
    }
  }

  /**
   * åŒæ­¥å¿«å–ç®¡ç†å™¨è¨­å®š
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _syncCacheManagerSettings(CacheConfiguration? config) async {
    if (config != null) {
      await _cacheManager.updateConfiguration(config);
    }
  }

  /**
   * æ•´åˆéŒ¯èª¤è™•ç†
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _integrateErrorHandling(ErrorHandlingResponse response) async {
    await _errorHandler.updateErrorHandling(response);
  }

  /**
   * æ›´æ–°å®‰å…¨ç®¡ç†å™¨
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _updateSecurityManager(SecurityOperationResponse response) async {
    await _securityManager.updateFromResponse(response);
  }

  /**
   * è™•ç†æœ¬åœ°æ—¥èªŒ
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _processLocalLogging(LogEntry logEntry) async {
    // æœ¬åœ°æ—¥èªŒè™•ç†é‚è¼¯
  }

  /**
   * æ›´æ–°ä¾è³´æ³¨å…¥å®¹å™¨
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _updateDIContainer(DependencyInjectionResponse response) async {
    // ä¾è³´æ³¨å…¥å®¹å™¨æ›´æ–°é‚è¼¯
  }

  /**
   * åŒæ­¥æœ¬åœ°é…ç½®
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _syncLocalConfiguration(ConfigurationResponse response) async {
    // æœ¬åœ°é…ç½®åŒæ­¥é‚è¼¯
  }

  /**
   * æ‡‰ç”¨æ•ˆèƒ½å„ªåŒ–
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> _applyPerformanceOptimizations(PerformanceOptimizationResponse response) async {
    // æ•ˆèƒ½å„ªåŒ–æ‡‰ç”¨é‚è¼¯
  }
}

/**
 * åŸºç¤è¨­æ–½æœå‹™ä¾‹å¤–é¡åˆ¥
 * @version v1.0.0
 * @date 2025-08-02 08:00:00
 */
class InfrastructureServiceException implements Exception {
  final String message;

  const InfrastructureServiceException(this.message);

  @override
  String toString() => 'InfrastructureServiceException: $message';
}
```

### 4.2 åŸºç¤è¨­æ–½æœå‹™å·¥å» 

```dart
/**
 * InfrastructureServiceFactory_åŸºç¤è¨­æ–½æœå‹™å·¥å» _v1.0.0
 * @module InfrastructureServiceFactory
 * @description åŸºç¤è¨­æ–½æœå‹™å·¥å»  - è² è²¬å‰µå»ºå’Œé…ç½®åŸºç¤è¨­æ–½æœå‹™å¯¦ä¾‹
 * @update 2025-08-02: åˆç‰ˆå»ºç«‹
 */
class InfrastructureServiceFactory {

  /**
   * å‰µå»ºåŸºç¤è¨­æ–½æœå‹™å¯¦ä¾‹
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  static InfrastructureService create({
    required ApiClient apiClient,
    required CacheManager cacheManager,
    required ErrorHandler errorHandler,
    required SecurityManager securityManager,
  }) {
    return InfrastructureService(
      apiClient,
      cacheManager,
      errorHandler,
      securityManager,
    );
  }

  /**
   * å‰µå»ºé è¨­é…ç½®çš„åŸºç¤è¨­æ–½æœå‹™
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  static Future<InfrastructureService> createDefault() async {
    final apiClient = await ApiClient.createDefault();
    final cacheManager = await CacheManager.createDefault();
    final errorHandler = await ErrorHandler.createDefault();
    final securityManager = await SecurityManager.createDefault();

    return create(
      apiClient: apiClient,
      cacheManager: cacheManager,
      errorHandler: errorHandler,
      securityManager: securityManager,
    );
  }
}
```

---

## 5.0 èˆ‡å…¶ä»–æœå‹™çš„æ•´åˆï¼ˆIntegration with Other Servicesï¼‰

### 5.1 æœå‹™ä¾è³´é—œä¿‚

```dart
/**
 * ServiceIntegration_æœå‹™æ•´åˆ_v1.0.0
 * @module ServiceIntegration
 * @description ç®¡ç†InfrastructureServiceèˆ‡å…¶ä»–7å€‹æœå‹™çš„æ•´åˆ
 * @update 2025-08-02: åˆç‰ˆå»ºç«‹
 */

// AuthServiceæ•´åˆ
class AuthServiceIntegration {
  final InfrastructureService _infrastructureService;

  AuthServiceIntegration(this._infrastructureService);

  /**
   * ç‚ºAuthServiceæä¾›å®‰å…¨æœå‹™
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<SecurityOperationResponse> validateToken(String token) async {
    final request = SecurityOperationRequest(
      operationType: SecurityOperationType.tokenManagement.name,
      tokenOperation: TokenOperation(
        action: TokenAction.validate.name,
        tokenData: TokenData(
          token: token,
          tokenType: TokenType.access,
        ),
      ),
    );

    return await _infrastructureService.performSecurityOperation(request);
  }
}

// EntryServiceæ•´åˆ
class EntryServiceIntegration {
  final InfrastructureService _infrastructureService;

  EntryServiceIntegration(this._infrastructureService);

  /**
   * ç‚ºEntryServiceæä¾›å¿«å–æœå‹™
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<CacheManagementResponse> cacheEntryData(String key, dynamic data) async {
    final request = CacheManagementRequest(
      operation: CacheOperation.configure.name,
      configuration: CacheConfiguration(
        cacheLevels: {
          'entry_cache': CacheLevel(
            levelName: 'entry_cache',
            cacheType: CacheType.memory,
            defaultTtl: Duration(minutes: 15),
            maxEntries: 1000,
            evictionPolicy: 'LRU',
            enableCompression: false,
          ),
        },
        defaultStrategy: CacheStrategy(
          strategyName: 'entry_strategy',
          applicableEndpoints: ['/entries'],
          cacheDuration: Duration(minutes: 15),
          refreshOnAccess: true,
          enablePrefetch: false,
          conditionalCaching: ConditionalCaching(
            cacheHeaders: ['Cache-Control', 'ETag'],
            invalidationTriggers: ['entry_updated', 'entry_deleted'],
            respectServerDirectives: true,
          ),
        ),
        expirationPolicy: ExpirationPolicy(
          policyType: 'sliding',
          defaultExpiration: Duration(minutes: 15),
          maxExpiration: Duration(hours: 1),
          enableSlidingExpiration: true,
          customRules: [],
        ),
        storageQuota: StorageQuota(
          maxMemoryMB: 50,
          maxDiskMB: 100,
          warningThreshold: 0.8,
          cleanupStrategy: 'LRU',
        ),
        compressionSettings: CompressionSettings(
          enableCompression: false,
          compressionAlgorithm: 'gzip',
          compressionLevel: 6,
          minSizeForCompression: 1024,
        ),
      ),
    );

    return await _infrastructureService.manageCacheStrategy(request);
  }
}

// å…¶ä»–æœå‹™æ•´åˆé¡ä¼¼å¯¦ä½œ...
```

### 5.2 åŸºç¤è¨­æ–½æœå‹™æ³¨å…¥

```dart
/**
 * InfrastructureServiceProvider_åŸºç¤è¨­æ–½æœå‹™æä¾›è€…_v1.0.0
 * @module InfrastructureServiceProvider
 * @description ç‚ºå…¶ä»–æœå‹™æä¾›åŸºç¤è¨­æ–½æœå‹™çš„ä¾è³´æ³¨å…¥
 * @update 2025-08-02: åˆç‰ˆå»ºç«‹
 */
class InfrastructureServiceProvider {
  static InfrastructureService? _instance;

  /**
   * ç²å–åŸºç¤è¨­æ–½æœå‹™å–®ä¾‹
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  static Future<InfrastructureService> getInstance() async {
    if (_instance == null) {
      _instance = await InfrastructureServiceFactory.createDefault();
    }
    return _instance!;
  }

  /**
   * ç‚ºæœå‹™æä¾›åŸºç¤è¨­æ–½èƒ½åŠ›
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  static Future<T> withInfrastructure<T>(
    Future<T> Function(InfrastructureService infrastructure) serviceCall,
  ) async {
    final infrastructure = await getInstance();
    return await serviceCall(infrastructure);
  }
}

/**
 * åŸºç¤è¨­æ–½èƒ½åŠ›æ··å…¥
 * @version v1.0.0
 * @date 2025-08-02 08:00:00
 */
mixin InfrastructureCapabilities {
  InfrastructureService? _infrastructure;

  /**
   * åˆå§‹åŒ–åŸºç¤è¨­æ–½èƒ½åŠ›
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> initializeInfrastructure() async {
    _infrastructure = await InfrastructureServiceProvider.getInstance();
  }

  /**
   * ç²å–åŸºç¤è¨­æ–½æœå‹™
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  InfrastructureService get infrastructure {
    if (_infrastructure == null) {
      throw StateError('Infrastructure not initialized. Call initializeInfrastructure() first.');
    }
    return _infrastructure!;
  }

  /**
   * è¨˜éŒ„æ—¥èªŒ
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<void> logEvent(LogLevel level, String message, {Map<String, dynamic>? contextData}) async {
    final request = LoggingRequest(
      logEntry: LogEntry(
        logId: DateTime.now().millisecondsSinceEpoch.toString(),
        logLevel: level,
        message: message,
        source: runtimeType.toString(),
        timestamp: DateTime.now(),
        contextData: contextData ?? {},
      ),
    );

    await infrastructure.logEvent(request);
  }

  /**
   * è™•ç†éŒ¯èª¤
   * @version v1.0.0
   * @date 2025-08-02 08:00:00
   */
  Future<ErrorHandlingResponse> handleError(Exception error, {Map<String, dynamic>? context}) async {
    final request = ErrorHandlingRequest(
      errorContext: ErrorContext(
        errorId: DateTime.now().millisecondsSinceEpoch.toString(),
        errorType: error.runtimeType.toString(),
        errorCode: 'UNKNOWN',
        errorMessage: error.toString(),
        sourceService: runtimeType.toString(),
        sourceFunction: 'handleError',
        timestamp: DateTime.now(),
        contextData: context ?? {},
      ),
    );

    return await infrastructure.handleError(request);
  }
}
```

---

## æ–‡ä»¶ç¶­è­·è¨˜éŒ„

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹è€… | ä¿®æ”¹å…§å®¹ |
|------|------|--------|----------|
| **v1.0.0** | **2025-08-02** | **LCAS SA Team** | **åˆç‰ˆå»ºç«‹ï¼šå»ºç«‹ç¬¬8å€‹æœå‹™æ¨¡çµ„InfrastructureServiceï¼Œå¯¦ä½œ8å€‹åŸºç¤è¨­æ–½APIç«¯é»ï¼ˆI001-I008ï¼‰ï¼Œæä¾›APIå®¢æˆ¶ç«¯ç®¡ç†ã€å¿«å–ç­–ç•¥ã€éŒ¯èª¤è™•ç†ã€å®‰å…¨èªè­‰ã€æ—¥èªŒç›£æ§ã€ä¾è³´æ³¨å…¥ã€é…ç½®ç®¡ç†ã€æ•ˆèƒ½å„ªåŒ–ç­‰å®Œæ•´åŸºç¤è¨­æ–½æœå‹™** |

---

## å‚™è¨»

- **ç‰ˆæœ¬1.0.0ç‰¹è‰²**: å®Œæ•´çš„åŸºç¤è¨­æ–½æœå‹™æ¨¡çµ„ï¼Œä½œç‚ºLCAS 2.0 Flutter AP Layerçš„ç¬¬8å€‹æ ¸å¿ƒæœå‹™
- **8å€‹APIç«¯é»**: I001-I008 åŸºç¤è¨­æ–½ç®¡ç†åŠŸèƒ½ï¼Œç‚ºå…¶ä»–7å€‹æœå‹™æä¾›åº•å±¤æ”¯æ’
- **æœå‹™æ¶æ§‹**: InfrastructureServiceä½œç‚ºåŸºç¤æœå‹™æä¾›è€…ï¼Œå…¶ä»–7å€‹æœå‹™ä½œç‚ºä¾è³´è€…
- **æ©«åˆ‡é—œæ³¨é»**: çµ±ä¸€è™•ç†APIå®¢æˆ¶ç«¯ã€å¿«å–ã€éŒ¯èª¤è™•ç†ã€å®‰å…¨ã€æ—¥èªŒã€ä¾è³´æ³¨å…¥ã€é…ç½®ã€æ•ˆèƒ½ç­‰åŸºç¤è¨­æ–½éœ€æ±‚
- **é«˜å¯é‡ç”¨æ€§**: æä¾›å¯è¢«å¤šå€‹æœå‹™é‡è¤‡ä½¿ç”¨çš„åŸºç¤è¨­æ–½çµ„ä»¶å’Œèƒ½åŠ›
- **é…ç½®é©…å‹•**: é€éé…ç½®æª”æ¡ˆç®¡ç†ä¸åŒç’°å¢ƒçš„åŸºç¤è¨­æ–½è¨­å®š
- **æ•ˆèƒ½å„ªå…ˆ**: å„ªåŒ–åŸºç¤è¨­æ–½æ•ˆèƒ½ä»¥æ¸›å°‘å°æ¥­å‹™æœå‹™çš„å½±éŸ¿
- **ä¾è³´æ³¨å…¥**: æä¾›InfrastructureCapabilitiesæ··å…¥ï¼Œè®“å…¶ä»–æœå‹™è¼•é¬†ç²å¾—åŸºç¤è¨­æ–½èƒ½åŠ›
- **å°æ‡‰æ¶æ§‹**: å®Œå–„LCAS 2.0 Flutter AP Layerçš„8æœå‹™æ¨¡çµ„æ¶æ§‹ï¼Œå½¢æˆå®Œæ•´çš„åŠŸèƒ½çŸ©é™£